{
  "version": 3,
  "sources": [
    "~lib/internal/allocator.ts",
    "~lib/allocator/tlsf.ts",
    "assembly/game/GameEngine.ts",
    "assembly/gomoku/constants.ts",
    "~lib/memory.ts",
    "~lib/internal/arraybuffer.ts",
    "~lib/internal/string.ts",
    "~lib/internal/typedarray.ts",
    "~lib/internal/memory.ts",
    "assembly/gomoku/GomokuEngine.ts",
    "assembly/engine.ts"
  ],
  "names": [],
  "mappings": "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",
  "sourceRoot": "assemblyscript:///",
  "sourceContents": [
    "/** Number of alignment bits. */\n@inline export const AL_BITS: u32 = 3;\n/** Number of possible alignment values. */\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n/** Mask to obtain just the alignment bits. */\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n/** Maximum 32-bit allocation size. */\n@inline export const MAX_SIZE_32: usize = 1 << 30; // 1GB\n",
    "/**\n * Two-Level Segregate Fit Memory Allocator.\n *\n * A general purpose dynamic memory allocator specifically designed to meet real-time requirements.\n * Always aligns to 8 bytes.\n *\n * @module std/assembly/allocator/tlsf\n *//***/\n\n// ╒══════════════ Block size interpretation (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┴─┴─┴─┴─╫─┴─┴─┤\n// │ |                    FL                       │ SB = SL + AL  │ ◄─ usize\n// └───────────────────────────────────────────────┴─────────╨─────┘\n// FL: first level, SL: second level, AL: alignment, SB: small block\n\nimport {\n  AL_BITS,\n  AL_SIZE,\n  AL_MASK\n} from \"../internal/allocator\";\n\nconst SL_BITS: u32 = 5;\nconst SL_SIZE: usize = 1 << <usize>SL_BITS;\n\nconst SB_BITS: usize = <usize>(SL_BITS + AL_BITS);\nconst SB_SIZE: usize = 1 << <usize>SB_BITS;\n\nconst FL_BITS: u32 = (sizeof<usize>() == sizeof<u32>()\n  ? 30 // ^= up to 1GB per block\n  : 32 // ^= up to 4GB per block\n) - SB_BITS;\n\n// ╒════════════════ Block structure layout (32-bit) ══════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┼─┤\n// │                          size                             │L│F│ ◄─┐ info\n// ╞═══════════════════════════════════════════════════════════╧═╧═╡   │      ┐\n// │                        if free: ◄ prev                        │ ◄─┤ usize\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                        if free: next ►                        │ ◄─┤\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                ... unused free space >= 0 ...                 │   │    = 0\n// ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤   │\n// │                        if free: jump ▲                        │ ◄─┘\n// └───────────────────────────────────────────────────────────────┘ MIN SIZE ┘\n// F: FREE, L: LEFT_FREE\n\n/** Tag indicating that this block is free. */\nconst FREE: usize = 1 << 0;\n/** Tag indicating that this block's left block is free. */\nconst LEFT_FREE: usize = 1 << 1;\n/** Mask to obtain all tags. */\nconst TAGS: usize = FREE | LEFT_FREE;\n\n/** Block structure. */\n@unmanaged\nclass Block {\n\n  /** Info field holding this block's size and tags. */\n  info: usize;\n\n  /** End offset of the {@link Block#info} field. User data starts here. */\n  static readonly INFO: usize = (sizeof<usize>() + AL_MASK) & ~AL_MASK;\n\n  /** Previous free block, if any. Only valid if free. */\n  prev: Block | null;\n  /** Next free block, if any. Only valid if free. */\n  next: Block | null;\n\n  /** Minimum size of a block, excluding {@link Block#info}. */\n  static readonly MIN_SIZE: usize = (3 * sizeof<usize>() + AL_MASK) & ~AL_MASK;// prev + next + jump\n\n  /** Maximum size of a used block, excluding {@link Block#info}. */\n  static readonly MAX_SIZE: usize = 1 << (FL_BITS + SB_BITS);\n\n  /** Gets this block's left (free) block in memory. */\n  get left(): Block {\n    assert(this.info & LEFT_FREE); // must be free to contain a jump\n    return assert(\n      load<Block>(changetype<usize>(this) - sizeof<usize>())\n    ); // can't be null\n  }\n\n  /** Gets this block's right block in memory. */\n  get right(): Block {\n    assert(this.info & ~TAGS); // can't skip beyond the tail block\n    return assert(\n      changetype<Block>(\n        changetype<usize>(this) + Block.INFO + (this.info & ~TAGS)\n      )\n    ); // can't be null\n  }\n}\n\n// ╒════════════════ Root structure layout (32-bit) ═══════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤          ┐\n// │        0        |           flMap                            S│ ◄────┐\n// ╞═══════════════════════════════════════════════════════════════╡      │\n// │                           slMap[0] S                          │ ◄─┐  │\n// ├───────────────────────────────────────────────────────────────┤   │  │\n// │                           slMap[1]                            │ ◄─┤  │\n// ├───────────────────────────────────────────────────────────────┤  u32 │\n// │                              ...                              │ ◄─┤  │\n// ├───────────────────────────────────────────────────────────────┤   │  │\n// │                           slMap[22] P                         │ ◄─┘  │\n// ╞═══════════════════════════════════════════════════════════════╡    usize\n// │                            head[0]                            │ ◄────┤\n// ├───────────────────────────────────────────────────────────────┤      │\n// │                              ...                              │ ◄────┤\n// ├───────────────────────────────────────────────────────────────┤      │\n// │                           head[736]                           │ ◄────┤\n// ╞═══════════════════════════════════════════════════════════════╡      │\n// │                            tailRef                            │ ◄────┘\n// └───────────────────────────────────────────────────────────────┘   SIZE   ┘\n// S: Small blocks map, P: Possibly padded if 64-bit\n\nassert((1 << SL_BITS) <= 32); // second level must fit into 32 bits\n\n/** Root structure. */\n@unmanaged\nclass Root {\n\n  /** First level bitmap. */\n  flMap: usize = 0;\n\n  /** Start offset of second level maps. */\n  private static readonly SL_START: usize = sizeof<usize>();\n\n  // Using *one* SL map per *FL bit*\n\n  /** Gets the second level map for the specified first level. */\n  getSLMap(fl: usize): u32 {\n    assert(fl < FL_BITS); // fl out of range\n    return load<u32>(changetype<usize>(this) + fl * 4, Root.SL_START);\n  }\n\n  /** Sets the second level map for the specified first level. */\n  setSLMap(fl: usize, value: u32): void {\n    assert(fl < FL_BITS); // fl out of range\n    store<u32>(changetype<usize>(this) + fl * 4, value, Root.SL_START);\n  }\n\n  /** End offset of second level maps. */\n  private static readonly SL_END: usize = Root.SL_START + FL_BITS * 4;\n\n  // Using *number bits per SL* heads per *FL bit*\n\n  /** Start offset of FL/SL heads. */\n  private static readonly HL_START: usize = (Root.SL_END + AL_MASK) & ~AL_MASK;\n\n  /** Gets the head of the specified first and second level index. */\n  getHead(fl: usize, sl: u32): Block | null {\n    assert(fl < FL_BITS); // fl out of range\n    assert(sl < SL_SIZE); // sl out of range\n    return changetype<Block>(load<usize>(\n      changetype<usize>(this) + (fl * SL_SIZE + <usize>sl) * sizeof<usize>()\n    , Root.HL_START));\n  }\n\n  /** Sets the head of the specified first and second level index. */\n  setHead(fl: usize, sl: u32, value: Block | null): void {\n    assert(fl < FL_BITS); // fl out of range\n    assert(sl < SL_SIZE); // sl out of range\n    store<usize>(\n      changetype<usize>(this) + (fl * SL_SIZE + <usize>sl) * sizeof<usize>()\n    , changetype<usize>(value)\n    , Root.HL_START);\n  }\n\n  /** End offset of FL/SL heads. */\n  private static readonly HL_END: usize = (\n    Root.HL_START + FL_BITS * SL_SIZE * sizeof<usize>()\n  );\n\n  get tailRef(): usize { return load<usize>(0, Root.HL_END); }\n  set tailRef(value: usize) { store<usize>(0, value, Root.HL_END); }\n\n  /** Total size of the {@link Root} structure. */\n  static readonly SIZE: usize = Root.HL_END + sizeof<usize>();\n\n  /** Inserts a previously used block back into the free list. */\n  insert(block: Block): void {\n    // check as much as possible here to prevent invalid free blocks\n    assert(block); // cannot be null\n    var blockInfo = block.info;\n    assert(blockInfo & FREE); // must be free\n    var size: usize;\n    assert(\n      (size = block.info & ~TAGS) >= Block.MIN_SIZE && size < Block.MAX_SIZE\n    ); // must be valid, not necessary to compute yet if noAssert=true\n\n    var right: Block = assert(block.right); // can't be null\n    var rightInfo = right.info;\n\n    // merge with right block if also free\n    if (rightInfo & FREE) {\n      this.remove(right);\n      block.info = (blockInfo += Block.INFO + (rightInfo & ~TAGS));\n      right = block.right;\n      rightInfo = right.info;\n      // jump is set below\n    }\n\n    // merge with left block if also free\n    if (blockInfo & LEFT_FREE) {\n      let left: Block = assert(block.left); // can't be null\n      let leftInfo = left.info;\n      assert(leftInfo & FREE); // must be free according to tags\n      this.remove(left);\n      left.info = (leftInfo += Block.INFO + (blockInfo & ~TAGS));\n      block = left;\n      blockInfo = leftInfo;\n      // jump is set below\n    }\n\n    right.info = rightInfo | LEFT_FREE;\n    this.setJump(block, right);\n    // right is no longer used now, hence rightInfo is not synced\n\n    size = blockInfo & ~TAGS;\n    assert(size >= Block.MIN_SIZE && size < Block.MAX_SIZE); // must be valid\n\n    // mapping_insert\n    var fl: usize, sl: u32;\n    if (size < SB_SIZE) {\n      fl = 0;\n      sl = <u32>(size / AL_SIZE);\n    } else {\n      fl = fls<usize>(size);\n      sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n      fl -= SB_BITS - 1;\n    }\n\n    // perform insertion\n    var head = this.getHead(fl, sl);\n    block.prev = null;\n    block.next = head;\n    if (head) head.prev = block;\n    this.setHead(fl, sl, block);\n\n    // update first and second level maps\n    this.flMap |= (1 << fl);\n    this.setSLMap(fl, this.getSLMap(fl) | (1 << sl));\n  }\n\n  /**\n   * Removes a free block from FL/SL maps. Does not alter left/jump because it\n   * is likely that splitting is performed afterwards, invalidating any changes\n   * again.\n   */\n  private remove(block: Block): void {\n    var blockInfo = block.info;\n    assert(blockInfo & FREE); // must be free\n    var size = blockInfo & ~TAGS;\n    assert(size >= Block.MIN_SIZE && size < Block.MAX_SIZE); // must be valid\n\n    // mapping_insert\n    var fl: usize, sl: u32;\n    if (size < SB_SIZE) {\n      fl = 0;\n      sl = <u32>(size / AL_SIZE);\n    } else {\n      fl = fls<usize>(size);\n      sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n      fl -= SB_BITS - 1;\n    }\n\n    // link previous and next free block\n    var prev = block.prev;\n    var next = block.next;\n    if (prev) prev.next = next;\n    if (next) next.prev = prev;\n\n    // update head if we are removing it\n    if (block == this.getHead(fl, sl)) {\n      this.setHead(fl, sl, next);\n\n      // clear second level map if head is empty now\n      if (!next) {\n        let slMap = this.getSLMap(fl);\n        this.setSLMap(fl, slMap &= ~(1 << sl));\n\n        // clear first level map if second level is empty now\n        if (!slMap) this.flMap &= ~(1 << fl);\n      }\n    }\n  }\n\n  /** Searches for a free block of at least the specified size. */\n  search(size: usize): Block | null {\n    assert(size >= Block.MIN_SIZE && size < Block.MAX_SIZE);\n\n    // mapping_search\n    var fl: usize, sl: u32;\n    if (size < SB_SIZE) {\n      fl = 0;\n      sl = <u32>(size / AL_SIZE);\n    } else {\n      // (*) size += (1 << (fls<usize>(size) - SL_BITS)) - 1;\n      fl = fls<usize>(size);\n      sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n      fl -= SB_BITS - 1;\n      // (*) instead of rounding up, use next second level list for better fit\n      if (sl < SL_SIZE - 1) ++sl;\n      else ++fl, sl = 0;\n    }\n\n    // search second level\n    var slMap = this.getSLMap(fl) & (~0 << sl);\n    var head: Block | null;\n    if (!slMap) {\n      // search next larger first level\n      let flMap = this.flMap & (~0 << (fl + 1));\n      if (!flMap) {\n        head = null;\n      } else {\n        fl = ffs<usize>(flMap);\n        slMap = assert(this.getSLMap(fl)); // can't be zero if fl points here\n        head = this.getHead(fl, ffs<u32>(slMap));\n      }\n    } else {\n      head = this.getHead(fl, ffs<u32>(slMap));\n    }\n    return head;\n  }\n\n  /** Links a free left with its right block in memory. */\n  private setJump(left: Block, right: Block): void {\n    assert(left.info & FREE);       // must be free\n    assert(left.right == right);    // right block must match\n    assert(right.info & LEFT_FREE); // right block must be tagged as LEFT_FREE\n    store<Block>(\n      changetype<usize>(right) - sizeof<usize>()\n    , left); // last word in left block's (free) data region\n  }\n\n  /**\n   * Uses the specified free block, removing it from internal maps and\n   * splitting it if possible, and returns its data pointer.\n   */\n  use(block: Block, size: usize): usize {\n    var blockInfo = block.info;\n    assert(blockInfo & FREE); // must be free so we can use it\n    assert(size >= Block.MIN_SIZE && size < Block.MAX_SIZE); // must be valid\n    assert(!(size & AL_MASK)); // size must be aligned so the new block is\n\n    this.remove(block);\n\n    // split if the block can hold another MIN_SIZE block\n    var remaining = (blockInfo & ~TAGS) - size;\n    if (remaining >= Block.INFO + Block.MIN_SIZE) {\n      block.info = size | (blockInfo & LEFT_FREE); // also discards FREE\n\n      let spare = changetype<Block>(\n        changetype<usize>(block) + Block.INFO + size\n      );\n      spare.info = (remaining - Block.INFO) | FREE; // not LEFT_FREE\n      this.insert(spare); // also sets jump\n\n    // otherwise tag block as no longer FREE and right as no longer LEFT_FREE\n    } else {\n      block.info = blockInfo & ~FREE;\n      let right: Block = assert(block.right); // can't be null (tail)\n      right.info &= ~LEFT_FREE;\n    }\n\n    return changetype<usize>(block) + Block.INFO;\n  }\n\n  /** Adds more memory to the pool. */\n  addMemory(start: usize, end: usize): bool {\n    assert(start <= end);\n    assert(!(start & AL_MASK)); // must be aligned\n    assert(!(end & AL_MASK)); // must be aligned\n\n    var tailRef = this.tailRef;\n    var tailInfo: usize = 0;\n    if (tailRef) {\n      assert(start >= tailRef + sizeof<usize>()); // starts after tail\n\n      // merge with current tail if adjacent\n      if (start - Block.INFO == tailRef) {\n        start -= Block.INFO;\n        tailInfo = changetype<Block>(tailRef).info;\n      }\n\n    } else {\n      assert(start >= changetype<usize>(this) + Root.SIZE); // starts after root\n    }\n\n    // check if size is large enough for a free block and the tail block\n    var size = end - start;\n    if (size < Block.INFO + Block.MIN_SIZE + Block.INFO) {\n      return false;\n    }\n\n    // left size is total minus its own and the zero-length tail's header\n    var leftSize = size - 2 * Block.INFO;\n    var left = changetype<Block>(start);\n    left.info = leftSize | FREE | (tailInfo & LEFT_FREE);\n    left.prev = null;\n    left.next = null;\n\n    // tail is a zero-length used block\n    var tail = changetype<Block>(start + size - Block.INFO);\n    tail.info = 0 | LEFT_FREE;\n    this.tailRef = changetype<usize>(tail);\n\n    this.insert(left); // also merges with free left before tail / sets jump\n\n    return true;\n  }\n}\n\n/** Determines the first (LSB to MSB) set bit's index of a word. */\nfunction ffs<T>(word: T): T {\n  assert(word != 0); // word cannot be 0\n  return ctz<T>(word);  // differs from ffs only for 0\n}\n\n/** Determines the last (LSB to MSB) set bit's index of a word. */\nfunction fls<T>(word: T): T {\n  assert(word != 0); // word cannot be 0\n  const inv: T = (sizeof<T>() << 3) - 1;\n  return inv - clz<T>(word);\n}\n\n/** Reference to the initialized {@link Root} structure, once initialized. */\nvar ROOT: Root = changetype<Root>(0);\n\n// Memory allocator interface\n\n/** Allocates a chunk of memory. */\n@global export function __memory_allocate(size: usize): usize {\n\n  // initialize if necessary\n  var root = ROOT;\n  if (!root) {\n    let rootOffset = (HEAP_BASE + AL_MASK) & ~AL_MASK;\n    let pagesBefore = memory.size();\n    let pagesNeeded = <i32>((((rootOffset + Root.SIZE) + 0xffff) & ~0xffff) >>> 16);\n    if (pagesNeeded > pagesBefore && memory.grow(pagesNeeded - pagesBefore) < 0) unreachable();\n    ROOT = root = changetype<Root>(rootOffset);\n    root.tailRef = 0;\n    root.flMap = 0;\n    for (let fl: usize = 0; fl < FL_BITS; ++fl) {\n      root.setSLMap(fl, 0);\n      for (let sl: u32 = 0; sl < SL_SIZE; ++sl) {\n        root.setHead(fl, sl, null);\n      }\n    }\n    root.addMemory((rootOffset + Root.SIZE + AL_MASK) & ~AL_MASK, memory.size() << 16);\n  }\n\n  // search for a suitable block\n  if (size > Block.MAX_SIZE) unreachable();\n\n  // 32-bit MAX_SIZE is 1 << 30 and itself aligned, hence the following can't overflow MAX_SIZE\n  size = max<usize>((size + AL_MASK) & ~AL_MASK, Block.MIN_SIZE);\n\n  var block = root.search(size);\n  if (!block) {\n\n    // request more memory\n    let pagesBefore = memory.size();\n    let pagesNeeded = <i32>(((size + 0xffff) & ~0xffff) >>> 16);\n    let pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n    if (memory.grow(pagesWanted) < 0) {\n      if (memory.grow(pagesNeeded) < 0) {\n        unreachable(); // out of memory\n      }\n    }\n    let pagesAfter = memory.size();\n    root.addMemory(<usize>pagesBefore << 16, <usize>pagesAfter << 16);\n    block = assert(root.search(size)); // must be found now\n  }\n\n  assert((block.info & ~TAGS) >= size);\n  return root.use(<Block>block, size);\n}\n\n/** Frees the chunk of memory at the specified address. */\n@global export function __memory_free(data: usize): void {\n  if (data) {\n    let root = ROOT;\n    if (root) {\n      let block = changetype<Block>(data - Block.INFO);\n      let blockInfo = block.info;\n      assert(!(blockInfo & FREE)); // must be used\n      block.info = blockInfo | FREE;\n      root.insert(changetype<Block>(data - Block.INFO));\n    }\n  }\n}\n\n@global export function __memory_reset(): void {\n  unreachable();\n}\n",
    "import {console} from \"./console\";\n\nexport enum PlayerRole {\n    None = 0,\n    First = 1,\n    Second = 2\n}\n\n\nexport declare namespace listener {\n\n    // @ts-ignore\n    @external(\"listener\", \"onUpdate\")\n    function onUpdate(player: PlayerRole, state: Int8Array): void;\n\n    // @ts-ignore\n    @external(\"listener\", \"onGameOver\")\n    function onGameOver(winner: PlayerRole): void;\n\n}\n\nexport abstract class GameEngine {\n\n    init(): void {\n    }\n\n    /**\n     *\n     * @param player\n     * @param state new increment state.\n     * @return is update success.\n     */\n    update(player: PlayerRole, state: Int8Array): boolean {\n        // console.log(\"GameEngine update\");\n        return false\n    }\n\n    loadState(fullState: Int8Array): void {\n    }\n\n    getState(): Int8Array {\n        return new Int8Array(0)\n    }\n\n    isGameOver(): boolean {\n        return false\n    }\n\n    getWinner(): PlayerRole {\n        return PlayerRole.None\n    }\n\n}\n",
    "import {PlayerRole} from \"../game/GameEngine\";\n\nexport enum Chess {\n    None = 0,\n    White = 1,\n    Black = 2\n}\n\nexport namespace constants {\n\n    export const boardDimension: i32 = 15;\n    export const boardSize: i32 = 15 * 15;\n\n    export function chessOfPlayer(player: PlayerRole): Chess {\n        if (player == PlayerRole.First) {\n            return Chess.White\n        } else if (player == PlayerRole.Second) {\n            return Chess.Black\n        } else {\n            return Chess.None\n        }\n    }\n\n    // @ts-ignore\n    @inline\n    export function chessOfRival(player: PlayerRole): Chess {\n        return chessOfPlayer(rivalPlayer(player));\n    }\n\n    export function rival(chess: Chess): Chess {\n        if (chess == Chess.Black) {\n            return Chess.White\n        } else if (chess == Chess.White) {\n            return Chess.Black\n        } else {\n            return Chess.None\n        }\n    }\n\n    // @ts-ignore\n    @inline\n    export function rivalPlayer(player: PlayerRole): PlayerRole {\n        if (player == PlayerRole.Second) {\n            return PlayerRole.First\n        } else {\n            return PlayerRole.Second\n        }\n    }\n\n    export function validRowAndCol(row: i32, col: i32): boolean {\n        let dim = constants.boardDimension\n        return (\n            row >= 0 && row < dim &&\n            col >= 0 && col < dim\n        )\n    }\n\n}\n",
    "import { memcmp, memmove, memset } from \"./internal/memory\";\n\n@builtin export declare const HEAP_BASE: usize; // tslint:disable-line\n\n/* tslint:disable */\n\nexport namespace memory {\n\n  @builtin export declare function size(): i32;\n\n  @builtin export declare function grow(pages: i32): i32;\n\n  @builtin @inline\n  export function fill(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\n    memset(dest, c, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  @builtin @inline\n  export function copy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\n    memmove(dest, src, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  @inline export function compare(vl: usize, vr: usize, n: usize): i32 { // see: musl/src/string/memcmp.c\n    return memcmp(vl, vr, n);\n  }\n\n  // Passive segments\n\n  // export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\n  //   __memory_init(segmentIndex, srcOffset, dstOffset);\n  // }\n\n  // export function drop(segmentIndex: u32): void {\n  //   __memory_drop(segmentIndex);\n  // }\n\n  // Allocator\n\n  @inline export function allocate(size: usize): usize {\n    if (isDefined(__memory_allocate)) return __memory_allocate(size);\n    WARNING(\"Calling 'memory.allocate' requires a memory manager to be present.\");\n    return <usize>unreachable();\n  }\n\n  @inline export function free(ptr: usize): void {\n    if (isDefined(__memory_free)) { __memory_free(ptr); return; }\n    WARNING(\"Calling 'memory.free' requires a memory manager to be present.\");\n    unreachable();\n  }\n\n  @inline export function reset(): void {\n    if (isDefined(__memory_reset)) { __memory_reset(); return; }\n    unreachable();\n  }\n}\n",
    "import {\n  AL_MASK,\n  MAX_SIZE_32\n } from \"./allocator\";\n\n/** Size of an ArrayBuffer header. */\n@inline export const HEADER_SIZE: usize = (offsetof<ArrayBuffer>() + AL_MASK) & ~AL_MASK;\n/** Maximum byte length of an ArrayBuffer. */\n@inline export const MAX_BLENGTH: i32 = <i32>MAX_SIZE_32 - HEADER_SIZE;\n\nfunction computeSize(byteLength: i32): usize {\n  // round up to power of 2, with HEADER_SIZE=8:\n  // 0            -> 2^3  = 8\n  // 1..8         -> 2^4  = 16\n  // 9..24        -> 2^5  = 32\n  // ...\n  // MAX_LENGTH   -> 2^30 = 0x40000000 (MAX_SIZE_32)\n  return <usize>1 << <usize>(<u32>32 - clz<u32>(byteLength + HEADER_SIZE - 1));\n}\n\n// Low-level utility\n\nfunction __gc(ref: usize): void {}\n\nexport function allocateUnsafe(byteLength: i32): ArrayBuffer {\n  assert(<u32>byteLength <= <u32>MAX_BLENGTH);\n  var buffer: usize;\n  if (isManaged<ArrayBuffer>()) {\n    buffer = __gc_allocate(computeSize(byteLength), __gc); // tslint:disable-line\n  } else {\n    buffer = memory.allocate(computeSize(byteLength));\n  }\n  store<i32>(buffer, byteLength, offsetof<ArrayBuffer>(\"byteLength\"));\n  return changetype<ArrayBuffer>(buffer);\n}\n\nexport function reallocateUnsafe(buffer: ArrayBuffer, newByteLength: i32): ArrayBuffer {\n  var oldByteLength = buffer.byteLength;\n  if (newByteLength > oldByteLength) {\n    assert(newByteLength <= MAX_BLENGTH);\n    if (newByteLength <= <i32>(computeSize(oldByteLength) - HEADER_SIZE)) { // fast path: zero out additional space\n      store<i32>(changetype<usize>(buffer), newByteLength, offsetof<ArrayBuffer>(\"byteLength\"));\n    } else { // slow path: copy to new buffer\n      let newBuffer = allocateUnsafe(newByteLength);\n      memory.copy(\n        changetype<usize>(newBuffer) + HEADER_SIZE,\n        changetype<usize>(buffer) + HEADER_SIZE,\n        <usize>oldByteLength\n      );\n      if (!isManaged<ArrayBuffer>()) {\n        memory.free(changetype<usize>(buffer));\n      }\n      buffer = newBuffer;\n    }\n    memory.fill(\n      changetype<usize>(buffer) + HEADER_SIZE + <usize>oldByteLength,\n      0,\n      <usize>(newByteLength - oldByteLength)\n    );\n  } else if (newByteLength < oldByteLength) { // fast path: override size\n    // TBD: worth to copy and release if size is significantly less than before?\n    assert(newByteLength >= 0);\n    store<i32>(changetype<usize>(buffer), newByteLength, offsetof<ArrayBuffer>(\"byteLength\"));\n  }\n  return buffer;\n}\n\n// The helpers below use two different types in order to emit loads and stores that load respectively\n// store one type to/from memory while returning/taking the desired output/input type. This allows to\n// emit instructions like\n//\n// * `i32.load8` ^= `<i32>load<i8>(...)` that reads an i8 but returns an i32, or\n// * `i64.load32_s` ^= `<i64>load<i32>(...)`) that reads a 32-bit as a 64-bit integer\n//\n// without having to emit an additional instruction for conversion purposes. The second parameter\n// can be omitted for references and other loads and stores that simply return the exact type.\n\n@inline export function LOAD<T,TOut = T>(buffer: ArrayBuffer, index: i32, byteOffset: i32 = 0): TOut {\n  return <TOut>load<T>(changetype<usize>(buffer) + (<usize>index << alignof<T>()) + <usize>byteOffset, HEADER_SIZE);\n}\n\n@inline export function STORE<T,TIn = T>(buffer: ArrayBuffer, index: i32, value: TIn, byteOffset: i32 = 0): void {\n  store<T>(changetype<usize>(buffer) + (<usize>index << alignof<T>()) + <usize>byteOffset, value, HEADER_SIZE);\n}\n",
    "import { MAX_SIZE_32 } from \"./allocator\";\nimport { String } from \"../string\";\n\n/** Size of a String header. */\n@inline export const HEADER_SIZE = (offsetof<String>() + 1) & ~1; // 2 byte aligned\n/** Maximum length of a String. */\n@inline export const MAX_LENGTH = (<i32>MAX_SIZE_32 - HEADER_SIZE) >>> 1;\n\n// Low-level utility\n\nfunction __gc(ref: usize): void {}\n\nexport function allocateUnsafe(length: i32): String {\n  assert(length > 0 && length <= MAX_LENGTH);\n  var buffer: usize;\n  if (isManaged<String>()) {\n    buffer = __gc_allocate(HEADER_SIZE + (<usize>length << 1), __gc);  // tslint:disable-line\n  } else {\n    buffer = memory.allocate(HEADER_SIZE + (<usize>length << 1));\n  }\n  store<i32>(buffer, length);\n  return changetype<String>(buffer);\n}\n\n@inline\nexport function freeUnsafe(buffer: String): void {\n  if (!isManaged<String>()) {\n    assert(buffer);\n    memory.free(changetype<usize>(buffer));\n  }\n}\n\nexport function copyUnsafe(dest: String, destOffset: usize, src: String, srcOffset: usize, len: usize): void {\n  memory.copy(\n    changetype<usize>(dest) + (destOffset << 1) + HEADER_SIZE,\n    changetype<usize>(src)  + (srcOffset  << 1) + HEADER_SIZE,\n    len << 1\n  );\n}\n\nexport function compareUnsafe(str1: String, offset1: usize, str2: String, offset2: usize, len: usize): i32 {\n  var cmp: i32 = 0;\n  var ptr1 = changetype<usize>(str1) + (offset1 << 1);\n  var ptr2 = changetype<usize>(str2) + (offset2 << 1);\n  while (len && !(cmp = <i32>load<u16>(ptr1, HEADER_SIZE) - <i32>load<u16>(ptr2, HEADER_SIZE))) {\n    --len, ptr1 += 2, ptr2 += 2;\n  }\n  return cmp;\n}\n\nexport function repeatUnsafe(dest: String, destOffset: usize, src: String, count: i32): void {\n  var length = src.length;\n  if (ASC_SHRINK_LEVEL > 1) {\n    let strLen = length << 1;\n    let to   = changetype<usize>(dest) + HEADER_SIZE + (destOffset << 1);\n    let from = changetype<usize>(src)  + HEADER_SIZE;\n    for (let i = 0, len = strLen * count; i < len; i += strLen) {\n      memory.copy(to + i, from, strLen);\n    }\n  } else {\n    switch (length) {\n      case 0: break;\n      case 1: {\n        let cc =  load<u16>(changetype<usize>(src), HEADER_SIZE);\n        let out = changetype<usize>(dest) + (destOffset << 1);\n        for (let i = 0; i < count; ++i) {\n          store<u16>(out + (i << 1), cc, HEADER_SIZE);\n        }\n        break;\n      }\n      case 2: {\n        let cc  = load<u32>(changetype<usize>(src), HEADER_SIZE);\n        let out = changetype<usize>(dest) + (destOffset << 1);\n        for (let i = 0; i < count; ++i) {\n          store<u32>(out + (i << 2), cc, HEADER_SIZE);\n        }\n        break;\n      }\n      case 3: {\n        let cc1 = load<u32>(changetype<usize>(src), HEADER_SIZE + 0);\n        let cc2 = load<u16>(changetype<usize>(src), HEADER_SIZE + 4);\n        let out = changetype<usize>(dest) + (destOffset << 1);\n        for (let i = 0; i < count; ++i) {\n          store<u32>(out + (i << 2), cc1, HEADER_SIZE + 0);\n          store<u16>(out + (i << 1), cc2, HEADER_SIZE + 4);\n        }\n        break;\n      }\n      case 4: {\n        let cc = load<u64>(changetype<usize>(src), HEADER_SIZE);\n        let out = changetype<usize>(dest) + (destOffset << 1);\n        for (let i = 0; i < count; ++i) {\n          store<u64>(out + (i << 3), cc, HEADER_SIZE);\n        }\n        break;\n      }\n      default: {\n        let strLen = length << 1;\n        let to   = changetype<usize>(dest) + HEADER_SIZE + (destOffset << 1);\n        let from = changetype<usize>(src)  + HEADER_SIZE;\n        for (let i = 0, len = strLen * count; i < len; i += strLen) {\n          memory.copy(to + i, from, strLen);\n        }\n        break;\n      }\n    }\n  }\n}\n\n// Helpers\n\n@inline export const enum CharCode {\n  PLUS = 0x2B,\n  MINUS = 0x2D,\n  DOT = 0x2E,\n  _0 = 0x30,\n  _1 = 0x31,\n  _2 = 0x32,\n  _3 = 0x33,\n  _4 = 0x34,\n  _5 = 0x35,\n  _6 = 0x36,\n  _7 = 0x37,\n  _8 = 0x38,\n  _9 = 0x39,\n  A = 0x41,\n  B = 0x42,\n  E = 0x45,\n  N = 0x4E,\n  O = 0x4F,\n  X = 0x58,\n  Z = 0x5a,\n  a = 0x61,\n  b = 0x62,\n  e = 0x65,\n  n = 0x6E,\n  o = 0x6F,\n  x = 0x78,\n  z = 0x7A\n}\n\nexport function isWhiteSpaceOrLineTerminator(c: u16): bool {\n  switch (c) {\n    case 9:    // <TAB>\n    case 10:   // <LF>\n    case 13:   // <CR>\n    case 11:   // <VT>\n    case 12:   // <FF>\n    case 32:   // <SP>\n    case 160:  // <NBSP>\n    case 8232: // <LS>\n    case 8233: // <PS>\n    case 65279: return true; // <ZWNBSP>\n    default: return false;\n  }\n}\n\n/** Parses a string to an integer (usually), using the specified radix. */\nexport function parse<T>(str: String, radix: i32 = 0): T {\n  var len: i32 = str.length;\n  if (!len) return <T>NaN;\n\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  var code = <i32>load<u16>(ptr, HEADER_SIZE);\n\n  // determine sign\n  var sign: T;\n  if (code == CharCode.MINUS) {\n    if (!--len) return <T>NaN;\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return <T>NaN;\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\n    sign = 1;\n  } else {\n    sign = 1;\n  }\n\n  // determine radix\n  if (!radix) {\n    if (code == CharCode._0 && len > 2) {\n      switch (<i32>load<u16>(ptr + 2, HEADER_SIZE)) {\n        case CharCode.B:\n        case CharCode.b: {\n          ptr += 4; len -= 2;\n          radix = 2;\n          break;\n        }\n        case CharCode.O:\n        case CharCode.o: {\n          ptr += 4; len -= 2;\n          radix = 8;\n          break;\n        }\n        case CharCode.X:\n        case CharCode.x: {\n          ptr += 4; len -= 2;\n          radix = 16;\n          break;\n        }\n        default: radix = 10;\n      }\n    } else radix = 10;\n  } else if (radix < 2 || radix > 36) {\n    return <T>NaN;\n  }\n\n  // calculate value\n  var num: T = 0;\n  while (len--) {\n    code = <i32>load<u16>(ptr, HEADER_SIZE);\n    if (code >= CharCode._0 && code <= CharCode._9) {\n      code -= CharCode._0;\n    } else if (code >= CharCode.A && code <= CharCode.Z) {\n      code -= CharCode.A - 10;\n    } else if (code >= CharCode.a && code <= CharCode.z) {\n      code -= CharCode.a - 10;\n    } else break;\n    if (code >= radix) break;\n    num = (num * radix) + code;\n    ptr += 2;\n  }\n  return sign * num;\n}\n",
    "import {\n  HEADER_SIZE as AB_HEADER_SIZE,\n  MAX_BLENGTH as AB_MAX_BLENGTH,\n  allocateUnsafe,\n  LOAD,\n  STORE\n} from \"./arraybuffer\";\n\nimport {\n  SORT as SORT_IMPL\n} from \"./sort\";\n\n/** Typed array base class. Not a global object. */\nexport abstract class TypedArray<T> {\n  [key: number]: T; // compatibility only\n\n  readonly buffer: ArrayBuffer;\n  readonly byteOffset: i32;\n  readonly byteLength: i32;\n\n  constructor(length: i32) {\n    const MAX_LENGTH = <u32>AB_MAX_BLENGTH / sizeof<T>();\n    if (<u32>length > MAX_LENGTH) throw new RangeError(\"Invalid typed array length\");\n    var byteLength = length << alignof<T>();\n    var buffer = allocateUnsafe(byteLength);\n    memory.fill(changetype<usize>(buffer) + AB_HEADER_SIZE, 0, <usize>byteLength);\n    this.buffer = buffer;\n    this.byteOffset = 0;\n    this.byteLength = byteLength;\n  }\n\n  @inline\n  get length(): i32 {\n    return this.byteLength >>> alignof<T>();\n  }\n\n  @operator(\"[]\")\n  protected __get(index: i32): T {\n    if (<u32>index >= <u32>(this.byteLength >>> alignof<T>())) throw new Error(\"Index out of bounds\");\n    return LOAD<T>(this.buffer, index, this.byteOffset);\n  }\n\n  @inline @operator(\"{}\")\n  protected __unchecked_get(index: i32): T {\n    return LOAD<T>(this.buffer, index, this.byteOffset);\n  }\n\n  @operator(\"[]=\")\n  protected __set(index: i32, value: native<T>): void {\n    if (<u32>index >= <u32>(this.byteLength >>> alignof<T>())) throw new Error(\"Index out of bounds\");\n    STORE<T,native<T>>(this.buffer, index, value, this.byteOffset);\n  }\n\n  @inline @operator(\"{}=\")\n  protected __unchecked_set(index: i32, value: native<T>): void {\n    STORE<T,native<T>>(this.buffer, index, value, this.byteOffset);\n  }\n\n  // copyWithin(target: i32, start: i32, end: i32 = this.length): this\n}\n\n@inline\nexport function FILL<TArray extends TypedArray<T>, T extends number>(\n  array: TArray,\n  value: native<T>,\n  start: i32,\n  end: i32\n): TArray {\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  var len = array.length;\n  start = start < 0 ? max(len + start, 0) : min(start, len);\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n  if (sizeof<T>() == 1) {\n    if (start < end) {\n      memory.fill(\n        changetype<usize>(buffer) + start + byteOffset + AB_HEADER_SIZE,\n        <u8>value,\n        <usize>(end - start)\n      );\n    }\n  } else {\n    for (; start < end; ++start) {\n      STORE<T,native<T>>(buffer, start, value, byteOffset);\n    }\n  }\n  return array;\n}\n\n@inline\nexport function SORT<TArray extends TypedArray<T>, T>(\n  array: TArray,\n  comparator: (a: T, b: T) => i32\n): TArray {\n  var byteOffset = array.byteOffset;\n  var length = array.length;\n  if (length <= 1) return array;\n  var buffer = array.buffer;\n  if (length == 2) {\n    let a = LOAD<T>(buffer, 1, byteOffset);\n    let b = LOAD<T>(buffer, 0, byteOffset);\n    if (comparator(a, b) < 0) {\n      STORE<T>(buffer, 1, b, byteOffset);\n      STORE<T>(buffer, 0, a, byteOffset);\n    }\n    return array;\n  }\n  SORT_IMPL<T>(buffer, byteOffset, length, comparator);\n  return array;\n}\n\n@inline\nexport function SUBARRAY<TArray extends TypedArray<T>, T>(\n  array: TArray,\n  begin: i32,\n  end: i32\n): TArray {\n  var length = <i32>array.length;\n  if (begin < 0) begin = max(length + begin, 0);\n  else begin = min(begin, length);\n  if (end < 0) end = max(length + end, begin);\n  else end = max(min(end, length), begin);\n  var slice = memory.allocate(offsetof<TArray>());\n  store<usize>(slice, array.buffer, offsetof<TArray>(\"buffer\"));\n  store<i32>(slice, <i32>array.byteOffset + (begin << alignof<T>()), offsetof<TArray>(\"byteOffset\"));\n  store<i32>(slice, (end - begin) << alignof<T>(), offsetof<TArray>(\"byteLength\"));\n  return changetype<TArray>(slice);\n}\n\n@inline\nexport function REDUCE<TArray extends TypedArray<T>, T, TRet>(\n  array: TArray,\n  callbackfn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  var length = array.length;\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  for (let i = 0; i < length; i++) {\n    initialValue = callbackfn(\n      initialValue,\n      LOAD<T>(buffer, i, byteOffset),\n      i,\n      array,\n    );\n  }\n  return initialValue;\n}\n\n@inline\nexport function REDUCE_RIGHT<TArray extends TypedArray<T>, T, TRet>(\n  array: TArray,\n  callbackfn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  for (let i = array.length - 1; i >= 0; i--) {\n    initialValue = callbackfn(\n      initialValue,\n      LOAD<T>(buffer, i, byteOffset),\n      i,\n      array,\n    );\n  }\n  return initialValue;\n}\n\n@inline\nexport function MAP<TArray extends TypedArray<T>, T>(\n  array: TArray,\n  callbackfn: (value: T, index: i32, self: TArray) => T,\n): TArray {\n  var length = array.length;\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  var result = instantiate<TArray>(length);\n  var resultBuffer = result.buffer;\n  for (let i = 0; i < length; i++) {\n    STORE<T, native<T>>(resultBuffer, i, <native<T>>callbackfn(LOAD<T>(buffer, i, byteOffset), i, array));\n  }\n\n  return result;\n}\n\n@inline\nexport function FIND_INDEX<TArray extends TypedArray<T>, T>(\n  array: TArray,\n  callbackfn: (value: T, index: i32, array: TArray) => bool,\n): i32 {\n  var length = array.length;\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  for (let i = 0; i < length; i++) {\n    if (callbackfn(LOAD<T>(buffer, i, byteOffset), i, array)) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n@inline\nexport function SOME<TArray extends TypedArray<T>, T>(\n  array: TArray,\n  callbackfn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  var length = array.length;\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  for (let i = 0; i < length; i++) {\n    if (callbackfn(LOAD<T>(buffer, i, byteOffset), i, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n@inline\nexport function EVERY<TArray extends TypedArray<T>, T>(\n  array: TArray,\n  callbackfn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  var length = array.length;\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  for (let i = 0; i < length; i++) {\n    if (callbackfn(LOAD<T>(buffer, i, byteOffset), i, array)) {\n      continue;\n    }\n    return false;\n  }\n  return true;\n}\n\n@inline\nexport function FOREACH<TArray extends TypedArray<T>, T>(\n  array: TArray,\n  callbackfn: (value: T, index: i32, array: TArray) => void,\n): void {\n  var length = array.length;\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  for (let i = 0; i < length; i++) {\n    callbackfn(LOAD<T>(buffer, i, byteOffset), i, array);\n  }\n}\n\n@inline\nexport function REVERSE<TArray extends TypedArray<T>, T>(array: TArray): TArray {\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n\n  for (let front = 0, back = array.length - 1; front < back; ++front, --back) {\n    let temp = LOAD<T>(buffer, front, byteOffset);\n    STORE<T>(buffer, front, LOAD<T>(buffer, back, byteOffset), byteOffset);\n    STORE<T>(buffer, back, temp, byteOffset);\n  }\n  return array;\n}\n",
    "// this function will go away once `memory.copy` becomes an intrinsic\nexport function memcpy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memcpy.c\n  var w: u32, x: u32;\n\n  // copy 1 byte each until src is aligned to 4 bytes\n  while (n && (src & 3)) {\n    store<u8>(dest++, load<u8>(src++));\n    n--;\n  }\n\n  // if dst is aligned to 4 bytes as well, copy 4 bytes each\n  if ((dest & 3) == 0) {\n    while (n >= 16) {\n      store<u32>(dest     , load<u32>(src     ));\n      store<u32>(dest +  4, load<u32>(src +  4));\n      store<u32>(dest +  8, load<u32>(src +  8));\n      store<u32>(dest + 12, load<u32>(src + 12));\n      src += 16; dest += 16; n -= 16;\n    }\n    if (n & 8) {\n      store<u32>(dest    , load<u32>(src    ));\n      store<u32>(dest + 4, load<u32>(src + 4));\n      dest += 8; src += 8;\n    }\n    if (n & 4) {\n      store<u32>(dest, load<u32>(src));\n      dest += 4; src += 4;\n    }\n    if (n & 2) { // drop to 2 bytes each\n      store<u16>(dest, load<u16>(src));\n      dest += 2; src += 2;\n    }\n    if (n & 1) { // drop to 1 byte\n      store<u8>(dest++, load<u8>(src++));\n    }\n    return;\n  }\n\n  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\n  // doing shifts if faster when copying enough bytes (here: 32 or more)\n  if (n >= 32) {\n    switch (dest & 3) {\n      // known to be != 0\n      case 1: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 3;\n        while (n >= 17) {\n          x = load<u32>(src + 1);\n          store<u32>(dest, w >> 24 | x << 8);\n          w = load<u32>(src + 5);\n          store<u32>(dest + 4, x >> 24 | w << 8);\n          x = load<u32>(src + 9);\n          store<u32>(dest + 8, w >> 24 | x << 8);\n          w = load<u32>(src + 13);\n          store<u32>(dest + 12, x >> 24 | w << 8);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 2: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 2;\n        while (n >= 18) {\n          x = load<u32>(src + 2);\n          store<u32>(dest, w >> 16 | x << 16);\n          w = load<u32>(src + 6);\n          store<u32>(dest + 4, x >> 16 | w << 16);\n          x = load<u32>(src + 10);\n          store<u32>(dest + 8, w >> 16 | x << 16);\n          w = load<u32>(src + 14);\n          store<u32>(dest + 12, x >> 16 | w << 16);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 3: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        n -= 1;\n        while (n >= 19) {\n          x = load<u32>(src + 3);\n          store<u32>(dest, w >> 8 | x << 24);\n          w = load<u32>(src + 7);\n          store<u32>(dest + 4, x >> 8 | w << 24);\n          x = load<u32>(src + 11);\n          store<u32>(dest + 8, w >> 8 | x << 24);\n          w = load<u32>(src + 15);\n          store<u32>(dest + 12, x >> 8 | w << 24);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n    }\n  }\n\n  // copy remaining bytes one by one\n  if (n & 16) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 8) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 4) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 2) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 1) {\n    store<u8>(dest++, load<u8>(src++));\n  }\n}\n\n// this function will go away once `memory.copy` becomes an intrinsic\nexport function memmove(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\n  if (dest === src) return;\n  if (src + n <= dest || dest + n <= src) {\n    memcpy(dest, src, n);\n    return;\n  }\n  if (dest < src) {\n    if ((src & 7) == (dest & 7)) {\n      while (dest & 7) {\n        if (!n) return;\n        --n;\n        store<u8>(dest++, load<u8>(src++));\n      }\n      while (n >= 8) {\n        store<u64>(dest, load<u64>(src));\n        n    -= 8;\n        dest += 8;\n        src  += 8;\n      }\n    }\n    while (n) {\n      store<u8>(dest++, load<u8>(src++));\n      --n;\n    }\n  } else {\n    if ((src & 7) == (dest & 7)) {\n      while ((dest + n) & 7) {\n        if (!n) return;\n        store<u8>(dest + --n, load<u8>(src + n));\n      }\n      while (n >= 8) {\n        n -= 8;\n        store<u64>(dest + n, load<u64>(src + n));\n      }\n    }\n    while (n) {\n      store<u8>(dest + --n, load<u8>(src + n));\n    }\n  }\n}\n\n// this function will go away once `memory.fill` becomes an intrinsic\nexport function memset(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\n\n  // fill head and tail with minimal branching\n  if (!n) return;\n  store<u8>(dest, c);\n  store<u8>(dest + n - 1, c);\n  if (n <= 2) return;\n\n  store<u8>(dest + 1, c);\n  store<u8>(dest + 2, c);\n  store<u8>(dest + n - 2, c);\n  store<u8>(dest + n - 3, c);\n  if (n <= 6) return;\n  store<u8>(dest + 3, c);\n  store<u8>(dest + n - 4, c);\n  if (n <= 8) return;\n\n  // advance pointer to align it at 4-byte boundary\n  var k: usize = -dest & 3;\n  dest += k;\n  n -= k;\n  n &= -4;\n\n  var c32: u32 = <u32>-1 / 255 * c;\n\n  // fill head/tail up to 28 bytes each in preparation\n  store<u32>(dest, c32);\n  store<u32>(dest + n - 4, c32);\n  if (n <= 8) return;\n  store<u32>(dest + 4, c32);\n  store<u32>(dest + 8, c32);\n  store<u32>(dest + n - 12, c32);\n  store<u32>(dest + n - 8, c32);\n  if (n <= 24) return;\n  store<u32>(dest + 12, c32);\n  store<u32>(dest + 16, c32);\n  store<u32>(dest + 20, c32);\n  store<u32>(dest + 24, c32);\n  store<u32>(dest + n - 28, c32);\n  store<u32>(dest + n - 24, c32);\n  store<u32>(dest + n - 20, c32);\n  store<u32>(dest + n - 16, c32);\n\n  // align to a multiple of 8\n  k = 24 + (dest & 4);\n  dest += k;\n  n -= k;\n\n  // copy 32 bytes each\n  var c64: u64 = <u64>c32 | (<u64>c32 << 32);\n  while (n >= 32) {\n    store<u64>(dest, c64);\n    store<u64>(dest + 8, c64);\n    store<u64>(dest + 16, c64);\n    store<u64>(dest + 24, c64);\n    n -= 32;\n    dest += 32;\n  }\n}\n\nexport function memcmp(vl: usize, vr: usize, n: usize): i32 { // see: musl/src/string/memcmp.c\n  if (vl == vr) return 0;\n  while (n != 0 && load<u8>(vl) == load<u8>(vr)) {\n    n--; vl++; vr++;\n  }\n  return n ? <i32>load<u8>(vl) - <i32>load<u8>(vr) : 0;\n}\n",
    "import {GameEngine, listener, PlayerRole} from \"../game/GameEngine\";\nimport {console} from \"../game/console\";\nimport {Chess, constants} from \"./constants\";\n\nclass Position {\n\n    constructor(public row: i32, public col: i32) {\n    }\n\n    static fromState(state: Int8Array): Position {\n        if (state.length != 2) {\n            throw ERROR(\"Invalid state\")\n        }\n        return new Position(state[0], state[1])\n    }\n\n    static fromIndex(idx: i32): Position {\n        if (idx < 0 || idx >= constants.boardSize) {\n            throw ERROR(\"Invalid index\")\n        }\n        return new Position(idx / constants.boardDimension, idx % constants.boardDimension)\n    }\n\n    toIndex(): i32 {\n        if (this.row >= constants.boardDimension || this.col >= constants.boardDimension) {\n            return -1\n        }\n        return constants.boardDimension * this.row + this.col;\n    }\n\n    toState(): Int8Array {\n        let state = new Int8Array(2);\n        state[0] = this.row;\n        state[1] = this.col;\n        return state;\n    }\n\n    toString(): String {\n        return this.row.toString() + \":\" + this.col.toString()\n    }\n}\n\nclass Chessboard {\n    readonly board: Int8Array = new Int8Array(constants.boardSize);\n\n    hasChess(row: i32, col: i32): boolean {\n        return constants.validRowAndCol(row, col) ? this.get(row, col) != Chess.None : false;\n    }\n\n    getChess(row: i32, col: i32): Chess {\n        return constants.validRowAndCol(row, col) ? this.get(row, col) : Chess.None\n    }\n\n    @inline\n    get(row: i32, col: i32): Chess {\n        return this.board[constants.boardDimension * row + col];\n    }\n\n    @inline\n    put(row: i32, col: i32, chess: Chess): void {\n        this.board[constants.boardDimension * row + col] = chess\n    }\n\n    @inline\n    clear(row: i32, col: i32): void {\n        this.board[constants.boardDimension * row + col] = Chess.None\n    }\n\n    putChess(row: i32, col: i32, chess: Chess): void {\n        if (constants.validRowAndCol(row, col)) {\n            this.put(row, col, chess);\n        } else {\n            throw ERROR(\"Invalid put position.\")\n        }\n    }\n\n    // @ts-ignore\n    @inline\n    isFull(): boolean {\n        return this.findEmptyPosition() == null;\n    }\n\n    // @ts-ignore\n    @inline\n    isEmpty(): boolean {\n        for (let i = 0, len = this.board.length; i < len; i++) {\n            if (this.board[i] != Chess.None) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // @ts-ignore\n    @inline\n    findEmptyPosition(): Position | null {\n        return this.findPosition(Chess.None);\n    }\n\n    findPosition(chess: Chess): Position | null {\n        let position: Position | null = null;\n        for (let i = 0, len = this.board.length; i < len; i++) {\n            if (this.board[i] == chess) {\n                position = Position.fromIndex(i);\n                break\n            }\n        }\n        return position\n    }\n\n    load(fullState: Int8Array): void {\n        let len = this.board.length;\n        assert(len == fullState.length);\n        for (let i = 0; i < len; i++) {\n            this.board[i] = fullState[i];\n        }\n    }\n\n    nextPlayer(): PlayerRole {\n        let chessDiff = 0;\n        for (let i = 0, len = this.board.length; i < len; i++) {\n            let value = this.board[i];\n            if (value == Chess.Black) {\n                chessDiff = chessDiff - 1;\n            } else if (value == Chess.White) {\n                chessDiff = chessDiff + 1;\n            }\n        }\n        if (chessDiff == 0) {\n            return PlayerRole.First\n        } else if (chessDiff > 0) {\n            return PlayerRole.Second\n        } else {\n            throw ERROR(\"Invalid state.\");\n        }\n    }\n}\n\nclass GomokuAction {\n    row: i32;\n    col: i32;\n    player: PlayerRole;\n}\n\nclass GomokuEngine extends GameEngine {\n\n    private readonly chessboard: Chessboard = new Chessboard();\n\n    lastAction: GomokuAction;\n    currentPlayer: PlayerRole = PlayerRole.First;\n    gameIsOver: boolean = false;\n\n    init(): void {\n        // console.log(\"GomokuEngine init\");\n    }\n\n    update(player: PlayerRole, state: Int8Array): boolean {\n        if (this.gameIsOver) {\n            // console.log(\"game is over.\")\n            return false\n        }\n        console.logAction(\"GomokuEngine update\", player, state);\n        if (state.length != 2) {\n            // console.log(\"Invalid state\");\n            return false;\n        }\n        if (this.currentPlayer != player) {\n            // console.log(\"Not your turn.\")\n            return false;\n        }\n        let row: i32 = state[0];\n        let col: i32 = state[1];\n        if (this.putChessOn(row, col)) {\n            listener.onUpdate(player, state);\n            this.lastAction = {\n                row,\n                col,\n                player: this.currentPlayer\n            };\n            if (!this.checkLastAction()) {\n                this.currentPlayer = constants.rivalPlayer(this.currentPlayer);\n            }\n            return true;\n        }\n        return false;\n    }\n\n    @inline\n    loadState(fullState: Int8Array): void {\n        this.chessboard.load(fullState);\n        this.currentPlayer = this.chessboard.nextPlayer();\n    }\n\n    @inline\n    getState(): Int8Array {\n        return this.chessboard.board;\n    }\n\n    @inline\n    isGameOver(): boolean {\n        return this.gameIsOver;\n    }\n\n    @inline\n    getWinner(): PlayerRole {\n        if(this.gameIsOver){\n            return this.currentPlayer;\n        }else{\n            return PlayerRole.None\n        }\n    }\n\n    private putChessOn(row: i32, col: i32): boolean {\n        if (constants.validRowAndCol(row, col) && !this.chessboard.hasChess(row, col)) {\n            this.chessboard.putChess(row, col, constants.chessOfPlayer(this.currentPlayer));\n            return true\n        }\n        return false\n    }\n\n    @inline\n    public getChessOn(row: i32, col: i32): Chess {\n        return this.chessboard.getChess(row, col)\n    }\n\n    /**\n     * return is gamer over.\n     */\n    private checkLastAction(): boolean {\n        let lastAction = this.lastAction;\n        let row = lastAction.row;\n        let col = lastAction.col;\n        let player = lastAction.player;\n        if (this.checkRow(row, player)\n            || this.checkColumn(col, player)\n            || this.checkMainDiagonal(row, col, player)\n            || this.checkSubDiagonal(row, col, player)) {\n\n            this.gameIsOver = true;\n            // console.logAction(\"Game is over, winner:\", this.currentPlayer, this.chessboard.board);\n            listener.onGameOver(this.currentPlayer)\n            return true;\n        }\n        return false;\n    }\n\n    private checkRow(row: i32, forPlayer: PlayerRole): boolean {\n        let count = 0\n        for (let col = 0, dim = constants.boardDimension; col < dim; col++) {\n            if (this.chessboard.getChess(row, col) == constants.chessOfPlayer(forPlayer)) {\n                count = count + 1\n                if (count == 5) {\n                    // console.log(\"checkRow gameIsOver\")\n                    return true\n                }\n            } else {\n                count = 0\n            }\n        }\n        return false\n    }\n\n    private checkColumn(col: i32, forPlayer: PlayerRole): boolean {\n        let count = 0\n        for (let row = 0, dim = constants.boardDimension; row <= dim; row++) {\n            if (this.chessboard.getChess(row, col) == constants.chessOfPlayer(forPlayer)) {\n                count = count + 1\n                if (count == 5) {\n                    // console.log(\"checkColumn gameIsOver\")\n                    return true\n                }\n            } else {\n                count = 0\n            }\n        }\n        return false\n    }\n\n    private checkMainDiagonal(row: i32, col: i32, forPlayer: PlayerRole): boolean {\n        let count = 0\n        let fromR: i32, fromC: i32, toR: i32, toC: i32\n        if (col >= row) {\n            fromR = 0\n            fromC = col - row\n            toR = 15 - col + row - 1\n            toC = 15 - 1\n        } else {\n            fromR = row - col\n            fromC = 0\n            toR = 15 - 1\n            toC = 15 + col - row - 1\n        }\n        while (fromR <= toR && fromC <= toC) {\n            if (this.chessboard.getChess(fromR, fromC) == constants.chessOfPlayer(forPlayer)) {\n                count = count + 1\n                if (count == 5) {\n                    // console.log(\"checkMainDiagonal gameIsOver\")\n                    return true\n                }\n            } else {\n                count = 0\n            }\n            fromR++\n            fromC++\n        }\n        return false\n    }\n\n    private checkSubDiagonal(row: i32, col: i32, forPlayer: PlayerRole): boolean {\n        let count = 0\n        let fromR: i32, fromC: i32, toR: i32, toC: i32\n        if (col + row <= 16) {\n            fromR = 0\n            fromC = row + col\n            toR = row + col\n            toC = 0\n        } else {\n            fromR = row + col - (15 - 1)\n            fromC = (15 - 1)\n            toR = (15 - 1)\n            toC = row + col - (15 - 1)\n        }\n        let chessboard = this.chessboard;\n        while (fromR <= toR && fromC >= toC) {\n            if (chessboard.getChess(fromR, fromC) == constants.chessOfPlayer(forPlayer)) {\n                count = count + 1\n                if (count == 5) {\n                    // console.log(\"checkSubDiagonal gameIsOver\")\n                    return true\n                }\n            } else {\n                count = 0\n            }\n            fromR++\n            fromC--\n        }\n        return false\n    }\n\n    @inline\n    getChessBoard(): Int8Array {\n        return this.chessboard.board\n    }\n\n}\n\nexport {GomokuAction, Chessboard, Position, GomokuEngine}\n",
    "import \"allocator/tlsf\";\nimport {GomokuEngine} from \"./gomoku/GomokuEngine\";\nimport {PlayerRole} from \"./game/GameEngine\";\n\nlet engine = new GomokuEngine();\n\nexport function isGameOver(): boolean {\n    return engine.isGameOver()\n}\n\nexport function getState(): Int8Array {\n    return engine.getState()\n}\n\nexport function init(): void {\n    engine.init();\n}\n\nexport function update(player: PlayerRole, state: Int8Array): boolean {\n    return engine.update(player, state);\n}\n\nexport function loadState(fullState: Int8Array): void {\n    engine.loadState(fullState)\n}\n\nexport function getWinner(): PlayerRole {\n    return engine.getWinner();\n}\n\n// @ts-ignore\nexport {memory}\n"
  ]
}
