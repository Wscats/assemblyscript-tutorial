{
  "version": 3,
  "sources": [
    "node_modules/as2d/src/shared/CanvasInstruction.ts",
    "~lib/internal/allocator.ts",
    "~lib/internal/arraybuffer.ts",
    "node_modules/as2d/src/shared/CanvasDirection.ts",
    "node_modules/as2d/src/shared/CanvasPatternRepetition.ts",
    "node_modules/as2d/src/shared/GlobalCompositeOperation.ts",
    "node_modules/as2d/src/shared/ImageSmoothingQuality.ts",
    "node_modules/as2d/src/shared/LineCap.ts",
    "node_modules/as2d/src/shared/LineJoin.ts",
    "node_modules/as2d/src/shared/TextAlign.ts",
    "node_modules/as2d/src/shared/TextBaseline.ts",
    "node_modules/as2d/src/shared/FillRule.ts",
    "node_modules/as2d/assembly/renderer/CanvasRenderingContext2D.ts",
    "~lib/internal/string.ts",
    "~lib/internal/typedarray.ts",
    "~lib/memory.ts",
    "~lib/allocator/tlsf.ts",
    "~lib/internal/memory.ts",
    "~lib/map.ts",
    "~lib/internal/hash.ts",
    "~lib/arraybuffer.ts",
    "node_modules/as2d/assembly/internal/getContext.ts",
    "node_modules/as2d/assembly/internal/Buffer.ts",
    "~lib/internal/number.ts",
    "~lib/builtins.ts",
    "~lib/array.ts",
    "node_modules/as2d/assembly/internal/Path2DElement.ts",
    "~lib/string.ts",
    "node_modules/as2d/assembly/renderer/Image.ts",
    "assembly/game/GameEngine.ts",
    "assembly/gomoku/constants.ts",
    "assembly/gomoku/GomokuGUI.ts",
    "assembly/gomoku/ai/BigbenAI.ts",
    "assembly/gui.ts",
    "assembly/game/GameGUI.ts",
    "assembly/gomoku/GomokuEngine.ts",
    "~lib/typedarray.ts",
    "node_modules/as2d/assembly/internal/util.ts"
  ],
  "names": [],
  "mappings": "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",
  "sourceRoot": "assemblyscript:///",
  "sourceContents": [
    "export const enum CanvasInstruction {\n  Arc = 0,\n  ArcTo = 1,\n  BeginPath = 2,\n  BezierCurveTo = 3,\n  Clip = 4,\n  ClosePath = 5,\n  Commit = 6,\n  ClearRect = 7,\n  Direction = 8,\n  DrawFocusIfNeeded = 9,\n  DrawImage = 10,\n  Ellipse = 11,\n  Fill = 12,\n  FillGradient = 13,\n  FillPattern = 14,\n  FillRect = 15,\n  FillStyle = 16,\n  FillText = 17,\n  FillTextWidth = 18,\n  Filter = 19,\n  Font = 20,\n  GlobalAlpha = 21,\n  GlobalCompositeOperation = 22,\n  ImageSmoothingEnabled = 23,\n  ImageSmoothingQuality = 24,\n  Inspect = 25,\n  LineCap = 26,\n  LineDash = 27,\n  LineDashOffset = 28,\n  LineJoin = 29,\n  LineTo = 30,\n  LineWidth = 31,\n  MiterLimit = 32,\n  MoveTo = 33,\n  QuadraticCurveTo = 34,\n  Rect = 35,\n  Restore = 36,\n  Rotate = 37,\n  Save = 38,\n  Scale = 39,\n  SetTransform = 40,\n  ShadowBlur = 41,\n  ShadowColor = 42,\n  ShadowOffsetX = 43,\n  ShadowOffsetY = 44,\n  Stroke = 45,\n  StrokeGradient = 46,\n  StrokePattern = 47,\n  StrokeRect = 48,\n  StrokeStyle = 49,\n  StrokeText = 50,\n  StrokeTextWidth = 51,\n  TextAlign = 52,\n  TextBaseline = 53,\n  Translate = 54,\n  Transform = 55,\n}\n",
    "/** Number of alignment bits. */\n@inline export const AL_BITS: u32 = 3;\n/** Number of possible alignment values. */\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n/** Mask to obtain just the alignment bits. */\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n/** Maximum 32-bit allocation size. */\n@inline export const MAX_SIZE_32: usize = 1 << 30; // 1GB\n",
    "import {\n  AL_MASK,\n  MAX_SIZE_32\n } from \"./allocator\";\n\n/** Size of an ArrayBuffer header. */\n@inline export const HEADER_SIZE: usize = (offsetof<ArrayBuffer>() + AL_MASK) & ~AL_MASK;\n/** Maximum byte length of an ArrayBuffer. */\n@inline export const MAX_BLENGTH: i32 = <i32>MAX_SIZE_32 - HEADER_SIZE;\n\nfunction computeSize(byteLength: i32): usize {\n  // round up to power of 2, with HEADER_SIZE=8:\n  // 0            -> 2^3  = 8\n  // 1..8         -> 2^4  = 16\n  // 9..24        -> 2^5  = 32\n  // ...\n  // MAX_LENGTH   -> 2^30 = 0x40000000 (MAX_SIZE_32)\n  return <usize>1 << <usize>(<u32>32 - clz<u32>(byteLength + HEADER_SIZE - 1));\n}\n\n// Low-level utility\n\nfunction __gc(ref: usize): void {}\n\nexport function allocateUnsafe(byteLength: i32): ArrayBuffer {\n  assert(<u32>byteLength <= <u32>MAX_BLENGTH);\n  var buffer: usize;\n  if (isManaged<ArrayBuffer>()) {\n    buffer = __gc_allocate(computeSize(byteLength), __gc); // tslint:disable-line\n  } else {\n    buffer = memory.allocate(computeSize(byteLength));\n  }\n  store<i32>(buffer, byteLength, offsetof<ArrayBuffer>(\"byteLength\"));\n  return changetype<ArrayBuffer>(buffer);\n}\n\nexport function reallocateUnsafe(buffer: ArrayBuffer, newByteLength: i32): ArrayBuffer {\n  var oldByteLength = buffer.byteLength;\n  if (newByteLength > oldByteLength) {\n    assert(newByteLength <= MAX_BLENGTH);\n    if (newByteLength <= <i32>(computeSize(oldByteLength) - HEADER_SIZE)) { // fast path: zero out additional space\n      store<i32>(changetype<usize>(buffer), newByteLength, offsetof<ArrayBuffer>(\"byteLength\"));\n    } else { // slow path: copy to new buffer\n      let newBuffer = allocateUnsafe(newByteLength);\n      memory.copy(\n        changetype<usize>(newBuffer) + HEADER_SIZE,\n        changetype<usize>(buffer) + HEADER_SIZE,\n        <usize>oldByteLength\n      );\n      if (!isManaged<ArrayBuffer>()) {\n        memory.free(changetype<usize>(buffer));\n      }\n      buffer = newBuffer;\n    }\n    memory.fill(\n      changetype<usize>(buffer) + HEADER_SIZE + <usize>oldByteLength,\n      0,\n      <usize>(newByteLength - oldByteLength)\n    );\n  } else if (newByteLength < oldByteLength) { // fast path: override size\n    // TBD: worth to copy and release if size is significantly less than before?\n    assert(newByteLength >= 0);\n    store<i32>(changetype<usize>(buffer), newByteLength, offsetof<ArrayBuffer>(\"byteLength\"));\n  }\n  return buffer;\n}\n\n// The helpers below use two different types in order to emit loads and stores that load respectively\n// store one type to/from memory while returning/taking the desired output/input type. This allows to\n// emit instructions like\n//\n// * `i32.load8` ^= `<i32>load<i8>(...)` that reads an i8 but returns an i32, or\n// * `i64.load32_s` ^= `<i64>load<i32>(...)`) that reads a 32-bit as a 64-bit integer\n//\n// without having to emit an additional instruction for conversion purposes. The second parameter\n// can be omitted for references and other loads and stores that simply return the exact type.\n\n@inline export function LOAD<T,TOut = T>(buffer: ArrayBuffer, index: i32, byteOffset: i32 = 0): TOut {\n  return <TOut>load<T>(changetype<usize>(buffer) + (<usize>index << alignof<T>()) + <usize>byteOffset, HEADER_SIZE);\n}\n\n@inline export function STORE<T,TIn = T>(buffer: ArrayBuffer, index: i32, value: TIn, byteOffset: i32 = 0): void {\n  store<T>(changetype<usize>(buffer) + (<usize>index << alignof<T>()) + <usize>byteOffset, value, HEADER_SIZE);\n}\n",
    "/**\n * The CanvasRenderingContext2D.direction value of the Canvas 2D API specifies the current text\n * direction used to draw text onto the canvas.\n */\nexport enum CanvasDirection {\n  /**\n   * The text direction is left-to-right.\n   */\n  ltr = 0,\n  /**\n   * The text direction is right-to-left.\n   */\n  rtl = 1,\n  /**\n   * The text direction is inherited from the <canvas> element or the Document as appropriate. Default value.\n   */\n  inherit = 2,\n}\n",
    "/**\n * A value indicating how to repeat the pattern's image.\n */\nexport enum CanvasPatternRepetition {\n  /**\n   * A canvas pattern repetition indicating a repeating pattern in both the x and y directions.\n   */\n  repeat = 0,\n  /**\n   * A canvas pattern repetition indicating a repeating pattern only the x direction.\n   */\n  repeat_x = 1,\n  /**\n   * A canvas pattern repetition indicating a repeating pattern only the y direction.\n   */\n  repeat_y = 2,\n  /**\n   * A canvas pattern repetition indicationg no repeating pattern.\n   */\n  no_repeat = 3,\n}\n",
    "/**\n * The GlobalCompositeOperation enum for the globalCompositeOperation property sets the type\n * of compositing operation to apply when drawing new shapes.\n */\nexport enum GlobalCompositeOperation {\n  /**\n   * This is the default setting and draws new shapes on top of the existing canvas content\n   */\n  source_over = 0,\n  /**\n   * The new shape is drawn only where both the new shape and the destination canvas overlap.\n   * Everything else is made transparent.\n   */\n  source_in = 1,\n  /**\n   * The new shape is drawn where it doesn't overlap the existing canvas content.\n   */\n  source_out = 2,\n  /**\n   * The new shape is only drawn where it overlaps the existing canvas content.\n   */\n  source_atop = 3,\n  /**\n   * New shapes are drawn behind the existing canvas content.\n   */\n  destination_over = 4,\n  /**\n   * The existing canvas content is kept where both the new shape and existing canvas content\n   * overlap. Everything else is made transparent.\n   */\n  destination_in = 5,\n  /**\n   * The existing content is kept where it doesn't overlap the new shape.\n   */\n  destination_out = 6,\n  /**\n   * The existing canvas is only kept where it overlaps the new shape. The new shape is drawn\n   * behind the canvas content.\n   */\n  destination_atop = 7,\n  /**\n   * Where both shapes overlap the color is determined by adding color values.\n   */\n  lighter = 8,\n  /**\n   * Only the new shape is shown.\n   */\n  copy = 9,\n  /**\n   * Shapes are made transparent where both overlap and drawn normal everywhere else.\n   */\n  xor = 10,\n  /**\n   * The pixels are of the top layer are multiplied with the corresponding pixel of the bottom\n   * layer. A darker picture is the result.\n   */\n  multiply = 11,\n  /**\n   * The pixels are inverted, multiplied, and inverted again. A lighter picture is the result\n   * (opposite of multiply)\n   */\n  screen = 12,\n  /**\n   * A combination of multiply and screen. Dark parts on the base layer become darker, and light\n   * parts become lighter.\n   */\n  overlay = 13,\n  /**\n   * Retains the darkest pixels of both layers.\n   */\n  darken = 14,\n  /**\n   * Retains the lightest pixels of both layers.\n   */\n  lighten = 15,\n  /**\n   * Divides the bottom layer by the inverted top layer.\n   */\n  color_dodge = 16,\n  /**\n   * Divides the inverted bottom layer by the top layer, and then inverts the result.\n   */\n  color_burn = 17,\n  /**\n   * A combination of multiply and screen like overlay, but with top and bottom layer swapped.\n   */\n  hard_light = 18,\n  /**\n   * A softer version of hard-light. Pure black or white does not result in pure black or white.\n   */\n  soft_light = 19,\n  /**\n   * Subtracts the bottom layer from the top layer or the other way round to always get a positive\n   * value.\n   */\n  difference = 20,\n  /**\n   * Like difference, but with lower contrast.\n   */\n  exclusion = 21,\n  /**\n   * Preserves the luma and chroma of the bottom layer, while adopting the hue of the top layer.\n   */\n  hue = 22,\n  /**\n   * Preserves the luma and hue of the bottom layer, while adopting the chroma of the top layer.\n   */\n  saturation = 23,\n  /**\n   * Preserves the luma of the bottom layer, while adopting the hue and chroma of the top layer.\n   */\n  color = 24,\n  /**\n   * Preserves the hue and chroma of the bottom layer, while adopting the luma of the top layer.\n   */\n  luminosity = 25,\n}\n",
    "export enum ImageSmoothingQuality {\n  low = 0,\n  medium = 1,\n  high = 2,\n}",
    "export enum LineCap {\n  butt = 0,\n  round = 1,\n  square = 2,\n}\n",
    "/**\n * The LineJoin enum responsible for setting the lineJoin property of the Canvas 2D API determines\n * the shape used to join two line segments where they meet.\n *\n * This property has no effect wherever two connected segments have the same direction, because no\n * joining area will be added in this case. Degenerate segments with a length of zero (i.e., with\n * all endpoints and control points at the exact same position) are also ignored.\n */\nexport enum LineJoin {\n  /**\n   * Rounds off the corners of a shape by filling an additional sector of disc centered at the\n   * common endpoint of connected segments. The radius for these rounded corners is equal to the\n   * line width.\n   */\n  bevel = 0,\n  /**\n   * Fills an additional triangular area between the common endpoint of connected segments, and the\n   * separate outside rectangular corners of each segment.\n   */\n  round = 1,\n  /**\n   * Connected segments are joined by extending their outside edges to connect at a single point,\n   * with the effect of filling an additional lozenge-shaped area. This setting is affected by the\n   * miterLimit property. Default value.\n   */\n  miter = 2,\n}",
    "/**\n * The TextAlign enum specifies the current text alignment used when drawing text.\n *\n * The alignment is relative to the x value of the fillText() method. For example, if textAlign is\n * \"center\", then the text's left edge will be at x - (textWidth / 2).\n */\nexport enum TextAlign {\n  /**\n   * The text is left-aligned.\n   **/\n  left = 0,\n  /**\n   * The text is right-aligned.\n   **/\n  right = 1,\n  /**\n   * The text is centered.\n   **/\n  center = 2,\n  /**\n   * The text is aligned at the normal start of the line (left-aligned for left-to-right locales, right-aligned for right-to-left locales).\n   **/\n  start = 3,\n  /**\n   * The text is aligned at the normal end of the line (right-aligned for left-to-right locales, left-aligned for right-to-left locales).\n   **/\n  end = 4,\n}\n",
    "/**\n * The TextBasline enum specifies the current text baseline used when drawing text.\n */\nexport enum TextBaseline {\n  /**\n   * The text baseline is the top of the em square.\n   **/\n  top = 0,\n  /**\n   * The text baseline is the hanging baseline. (Used by Tibetan and other Indic scripts.)\n   **/\n  hanging = 1,\n  /**\n   * The text baseline is the middle of the em square.\n   **/\n  middle = 2,\n  /**\n   * The text baseline is the normal alphabetic baseline. Default value.\n   **/\n  alphabetic = 3,\n  /**\n   * The text baseline is the ideographic baseline; this is the bottom of the body of the characters, if the main body of characters protrudes beneath the alphabetic baseline. (Used by Chinese, Japanese, and Korean scripts.)\n   **/\n  ideographic = 4,\n  /**\n   * The text baseline is the bottom of the bounding box. This differs from the ideographic baseline in that the ideographic baseline doesn't consider descenders.\n   **/\n  bottom = 5,\n}",
    "export enum FillRule {\n  nonzero = 0,\n  evenodd = 1,\n}\n",
    "import { CanvasInstruction } from \"../../src/shared/CanvasInstruction\";\nimport { Buffer } from \"../internal/Buffer\";\nimport { LOAD, STORE } from \"internal/arraybuffer\";\nimport { DOMMatrix } from \"./DOMMatrix\";\nimport { CanvasDirection } from \"../../src/shared/CanvasDirection\";\nimport { CanvasPattern } from \"./CanvasPattern\";\nimport { CanvasGradient } from \"./CanvasGradient\";\nimport { Image, getImageID } from \"./Image\";\nimport { CanvasPatternRepetition } from \"../../src/shared/CanvasPatternRepetition\";\nimport { GlobalCompositeOperation } from \"../../src/shared/GlobalCompositeOperation\";\nimport { ImageSmoothingQuality } from \"../../src/shared/ImageSmoothingQuality\";\nimport { LineCap } from \"../../src/shared/LineCap\";\nimport { LineJoin } from \"../../src/shared/LineJoin\";\nimport { TextAlign } from \"../../src/shared/TextAlign\";\nimport { TextBaseline } from \"../../src/shared/TextBaseline\";\nimport { arraysEqual } from \"../internal/util\";\nimport { Path2DElement } from \"../internal/Path2DElement\";\nimport { FillRule } from \"../../src/shared/FillRule\";\n\n//#region EXTERNALS\n\n// @ts-ignore: linked functions can have decorators\n@external(\"__canvas_sys\", \"render\")\ndeclare function render(ctxid: i32, data: usize): void;\n\n// @ts-ignore: linked functions can have decorators\n@external(\"__canvas_sys\", \"createLinearGradient\")\ndeclare function createLinearGradient(id: i32, x0: f64, y0: f64, x1: f64, y1: f64): i32;\n\n// @ts-ignore: linked functions can have decorators\n@external(\"__canvas_sys\", \"createRadialGradient\")\ndeclare function createRadialGradient(id: i32, x0: f64, y0: f64, r0: f64, x1: f64, y1: f64, r1: f64): i32;\n\n// @ts-ignore: linked functions can have decorators\n@external(\"__canvas_sys\", \"createPattern\")\ndeclare function createPattern(ctxid: i32, imageid: i32, repetition: CanvasPatternRepetition): i32;\n\n// @ts-ignore: linked functions can have decorators\n@external(\"__canvas_sys\", \"measureText\")\ndeclare function measureText(id: i32, text: string): f64;\n\n// @ts-ignore: linked functions can have decorators\n@external(\"__canvas_sys\", \"isPointInPath\")\ndeclare function isPointInPath(id: i32, x: f64, y: f64, fillRule: FillRule): bool;\n\n// @ts-ignore: linked functions can have decorators\n@external(\"__canvas_sys\", \"isPointInStroke\")\ndeclare function isPointInStroke(id: i32, x: f64, y: f64): bool;\n//#endregion EXTERNALS\n\n\nconst enum FillStrokeStyleType {\n  String = 0,\n  CanvasPattern = 1,\n  CanvasGradient = 2,\n}\n\nvar defaultBlack: string = \"#000\";\nvar defaultNone: string = \"none\";\nvar defaultFont: string = \"10px sans-serif\";\nvar defaultShadowColor: string = \"rgba(0, 0, 0, 0)\";\nvar defaultLineDash: Float64Array = new Float64Array(0);\n\n//#region ARRAYBUFFERINITIALIZER\n/**\n * Utility function for setting the given ArrayBuffer to the identity 2d transform matrix inline.\n *\n * @param ArrayBuffer buff\n */\n// @ts-ignore: Decorators are valid here\nfunction setArrayBufferIdentity(buff: ArrayBuffer): ArrayBuffer {\n  STORE<f64>(buff, 0, 1.0);\n  STORE<f64>(buff, 1, 0.0);\n  STORE<f64>(buff, 2, 0.0);\n  STORE<f64>(buff, 3, 1.0);\n  STORE<f64>(buff, 4, 0.0);\n  STORE<f64>(buff, 5, 0.0);\n  return buff;\n}\n\n/**\n * Utility function for setting the given ArrayBuffer's first value to the specified value inline.\n *\n * @param ArrayBuffer buff\n * @param T value\n */\n// @ts-ignore: Decorators are valid here\nfunction setArrayBufferValue<T>(buff: ArrayBuffer, value: T): ArrayBuffer {\n  STORE<T>(buff, 0, value);\n  return buff;\n}\n\n/**\n * Utility function for setting the given ArrayBuffer's first value to the specified value inline.\n *\n * @param ArrayBuffer buff\n * @param T value\n */\n// @ts-ignore: Decorators are valid here\nfunction setArrayBufferValue2<T>(buff: ArrayBuffer, a: T, b: T): ArrayBuffer {\n  STORE<T>(buff, 0, a);\n  STORE<T>(buff, 1, b);\n  return buff;\n}\n//#endregion ARRAYBUFFERINITIALIZER\n\n/** The path element initializer. */\nfunction createPathElements(): Path2DElement[] {\n  var path: Path2DElement[] = new Array<Path2DElement>(0xFF);\n  for (var i = 0; i < 0x1000; i++) {\n    path[i] = new Path2DElement();\n  }\n  var el = unchecked(path[0]);\n  el.instruction = CanvasInstruction.BeginPath;\n  el.count = 0;\n  el.updateTransform = true;\n  return path;\n}\n\n/**\n * An AssemblyScript virtual representation of an actual CanvasRenderingContext2D Object. The\n * CanvasRenderingContext2D interface, part of the Canvas API, provides the 2D rendering context\n * for the drawing surface of a <canvas> element. It is used for drawing shapes, text, images, and\n * other objects.\n */\n@sealed\nexport class CanvasRenderingContext2D extends Buffer<CanvasInstruction> {\n  /**\n   * The component's external object id. It initializes to -1, which will never be an actual object\n   * id externally. If it actually returns -1, it will cause the host to error saying it cannot\n   * find the specified canvas context.\n   */\n  private id: i32 = -1;\n\n  /**\n   * The virutal stack index offset that keeps track of the number of `save()` and `restore()`\n   * stack states.\n   */\n  private _stackOffset: u8 = <u8>0;\n\n  //#region CREATELINEARGRADIENT\n  /**\n   * The CanvasRenderingContext2D.createLinearGradient() method of the Canvas 2D API creates a\n   * gradient along the line connecting two given coordinates.\n   *\n   * @param {f64} x0 - A float number representing the first x coordinate point of the gradient.\n   * @param {f64} y0 - A float number representing the first y coordinate point of the gradient.\n   * @param {f64} x1 - A float number representing the second x coordinate point of the gradient.\n   * @param {f64} y1 - A float number representing the second y coordinate point of the gradient.\n   */\n  public createLinearGradient(x0: f64, y0: f64, x1: f64, y1: f64): CanvasGradient {\n    var id: i32 = createLinearGradient(this.id, x0, y0, x1, y1);\n    var result: CanvasGradient = new CanvasGradient();\n    store<i32>(changetype<usize>(result) + offsetof<CanvasGradient>(\"id\"), id);\n    return result;\n  }\n  //#endregion CREATELINEARGRADIENT\n\n  //#region CREATERADIALGRADIENT\n  /**\n   * The CanvasRenderingContext2D.createRadialGradient() method of the Canvas 2D API creates a\n   * radial gradient using the size and coordinates of two circles.\n   *\n   * @param {f64} x0 - The x-axis coordinate of the start circle.\n   * @param {f64} y0 - The y-axis coordinate of the start circle.\n   * @param {f64} r0 - The radius of the start circle. Must be non-negative and finite.\n   * @param {f64} x1 - The x-axis coordinate of the end circle.\n   * @param {f64} y1 - The y-axis coordinate of the end circle.\n   * @param {f64} r1 - The radius of the end circle. Must be non-negative and finite.\n   */\n  public createRadialGradient(x0: f64, y0: f64, r0: f64, x1: f64, y1: f64, r1: f64): CanvasGradient {\n    var id: i32 = createRadialGradient(this.id, x0, y0, r0, x1, y1, r1);\n    var result: CanvasGradient = new CanvasGradient();\n    store<i32>(changetype<usize>(result) + offsetof<CanvasGradient>(\"id\"), id);\n    return result;\n  }\n  //#endregion CREATERADIALGRADIENT\n\n  //#region TRANSFORM\n  /**\n   * An ArrayBuffer that contains 256 sets of transforms. Each transform value is a set of 6 numbers\n   * stored in a repeated pattern of [a0, b0, c0, d0, e0, f0, a1, b1, c1, d1, e1, f1, ...].\n   */\n  private _transformStack: ArrayBuffer = setArrayBufferIdentity(new ArrayBuffer(0xFF * sizeof<f64>() * 6));\n\n  /**\n   * An ArrayBuffer that contains a single transform value that represents the last transform\n   * written by a `setTransform()` operation\n   */\n  private _currentTransform: ArrayBuffer = setArrayBufferIdentity(new ArrayBuffer(sizeof<f64>() * 6));\n\n  /**\n   * An operation that generates a DOMMatrix reflecting the current transform on the `_transformStack\n   */\n  @inline\n  private _getTransform(): DOMMatrix {\n    var result: DOMMatrix = new DOMMatrix();\n    var index: i32 = 6 * <i32>this._stackOffset;\n    var stack: ArrayBuffer = this._transformStack;\n    result.m11 = LOAD<f64>(stack, index);\n    result.m12 = LOAD<f64>(stack, index + 1);\n    result.m21 = LOAD<f64>(stack, index + 2);\n    result.m22 = LOAD<f64>(stack, index + 3);\n    result.m41 = LOAD<f64>(stack, index + 4);\n    result.m42 = LOAD<f64>(stack, index + 5);\n    return result;\n  }\n\n  /**\n   * An function that sets the current transform on the `_transformStack` to the specified\n   * DOMMatrix values.\n   *\n   * @param {f64} a - The a property of the transform matrix.\n   * @param {f64} b - The b property of the transform matrix.\n   * @param {f64} c - The c property of the transform matrix.\n   * @param {f64} d - The d property of the transform matrix.\n   * @param {f64} e - The e property of the transform matrix.\n   * @param {f64} f - The f property of the transform matrix.\n   */\n  @inline\n  private _setTransform(a: f64, b: f64, c: f64, d: f64, e: f64, f: f64): void {\n    var index: i32 = 6 * <i32>this._stackOffset;\n    var stack: ArrayBuffer = this._transformStack;\n    STORE<f64>(stack, index, a);\n    STORE<f64>(stack, index + 1, b);\n    STORE<f64>(stack, index + 2, c);\n    STORE<f64>(stack, index + 3, d);\n    STORE<f64>(stack, index + 4, e);\n    STORE<f64>(stack, index + 5, f);\n  }\n\n  /**\n   * The CanvasRenderingContext2D.currentTransform property of the Canvas 2D API returns or sets a\n   * DOMMatrix (current specification) object for the current transformation matrix\n  */\n  public get currentTransform(): DOMMatrix {\n    return this._getTransform();\n  }\n\n  public set currentTransform(value: DOMMatrix) {\n    this._setTransform(value.m11, value.m12, value.m21, value.m22, value.m41, value.m42);\n  }\n\n  /**\n   * The CanvasRenderingContext2D.getTransform() method of the Canvas 2D API gets the current\n   * transformation matrix, and returns a DOMMatrix\n   */\n  public getTransform(): DOMMatrix {\n    return this._getTransform();\n  }\n\n  /**\n   * An internal function that writes the current transform value on the _transformStack to the\n   * buffer if it currently does not match the last written transform.\n   */\n  private _updateTransform(): void {\n    var index: i32 = this._stackOffset * 6;\n    var stack: ArrayBuffer = this._transformStack;\n    var a = LOAD<f64>(stack, index);\n    var b = LOAD<f64>(stack, index + 1);\n    var c = LOAD<f64>(stack, index + 2);\n    var d = LOAD<f64>(stack, index + 3);\n    var e = LOAD<f64>(stack, index + 4);\n    var f = LOAD<f64>(stack, index + 5);\n\n    var current: ArrayBuffer = this._currentTransform;\n    if ( a != LOAD<f64>(current, 0)\n      || b != LOAD<f64>(current, 1)\n      || c != LOAD<f64>(current, 2)\n      || d != LOAD<f64>(current, 3)\n      || e != LOAD<f64>(current, 4)\n      || f != LOAD<f64>(current, 5)) {\n      super._writeSix(CanvasInstruction.SetTransform, a, b, c, d, e, f);\n      STORE<f64>(current, 0, a);\n      STORE<f64>(current, 1, b);\n      STORE<f64>(current, 2, c);\n      STORE<f64>(current, 3, d);\n      STORE<f64>(current, 4, e);\n      STORE<f64>(current, 5, f);\n    }\n  }\n  //#endregion TRANSFORM\n\n  //#region DIRECTION\n  /**\n   * An ArrayBuffer that contains 256 sets of CanvasDirection values, stored as `i32` values\n   */\n  private _directionStack: ArrayBuffer\n    = setArrayBufferValue<CanvasDirection>(new ArrayBuffer(0xFF * 4), CanvasDirection.inherit);\n\n  /**\n   * A private member that contains a single CanvasDirection value that represents the last\n   * CanvasDirection value written by a drawing operation\n   */\n  private _currentDirection: CanvasDirection = CanvasDirection.inherit;\n\n  /**\n   * The CanvasRenderingContext2D.direction property of the Canvas 2D API specifies the current text\n   * direction used to draw text\n   */\n  public get direction(): CanvasDirection {\n    return LOAD<CanvasDirection>(this._directionStack, <i32>this._stackOffset);\n  }\n\n  public set direction(value: CanvasDirection) {\n    STORE<CanvasDirection>(this._directionStack, <i32>this._stackOffset, value);\n  }\n\n  /**\n   * An internal function that writes the current CanvasDirection value on the _directionStack to\n   * the buffer if it currently does not match the last written CanvasDirection.\n   */\n  @inline\n  private _updateDirection(): void {\n    var value: CanvasDirection = LOAD<CanvasDirection>(this._directionStack, <i32>this._stackOffset);\n    if (value != this._currentDirection) {\n      this._currentDirection = value;\n      super._writeOne(CanvasInstruction.Direction, <f64>value);\n    }\n  }\n  //#endregion DIRECTION\n\n  //#region FILLSTYLE\n  /**\n   * An ArrayBuffer that contains 256 sets of 2 i32 values. For each fillStyle, if the fillStyle is\n   * a string, the second i32 value will be a pointer, otherwise, it's a `usize` representing the\n   * style's external objectID.\n   */\n  private _fillStyleStack: ArrayBuffer = setArrayBufferValue2<usize>(\n    new ArrayBuffer(0xFF * sizeof<usize>() * 2),\n    <usize>FillStrokeStyleType.String,\n    changetype<usize>(defaultBlack),\n  );\n\n  /**\n   * A private member that contains a single StrokeFillStyleType value that represents the last\n   * fillStyle value written by a drawing operation\n   */\n  private _currentFillStyleType: FillStrokeStyleType = FillStrokeStyleType.String;\n\n  /**\n   * A private member that contains a single pointer or id value that represents the last\n   * fillStyle value written by a drawing operation\n   */\n  private _currentFillStyleValue: usize = changetype<usize>(defaultBlack);\n\n  /**\n   * The CanvasRenderingContext2D.fillStyle property of the Canvas 2D API specifies the current text\n   * representing a CSS Color\n   */\n  public get fillStyle(): string | null {\n    var index: i32 = this._stackOffset * 2;\n    var fillStyleType: FillStrokeStyleType = <FillStrokeStyleType>LOAD<usize>(\n      this._fillStyleStack,\n      index,\n    );\n    if (fillStyleType == FillStrokeStyleType.String) {\n      return changetype<string>(LOAD<usize>(this._fillStyleStack, index + 1));\n    }\n    return null;\n  }\n\n  public set fillStyle(value: string | null) {\n    if (value == null) value = defaultBlack;\n    var index: i32 = this._stackOffset * 2;\n    var buff: ArrayBuffer = this._fillStyleStack;\n    STORE<usize>(buff, index, <usize>FillStrokeStyleType.String);\n    STORE<usize>(buff, index + 1, changetype<usize>(value));\n  }\n\n  /**\n   * An internal function that writes the current fillStyle value on the _fillStyleStack to the\n   * buffer if it currently does not match the last written fillStyle.\n   */\n  @inline\n  private _updateFillStyle(): void {\n    var buff: ArrayBuffer = this._fillStyleStack;\n    var index: i32 = <i32>this._stackOffset * 2;\n    var styleType: FillStrokeStyleType = <FillStrokeStyleType>LOAD<usize>(buff, index);\n    var value: usize = LOAD<usize>(buff, index + 1);\n    if (styleType != this._currentFillStyleType || value != this._currentFillStyleValue) {\n      var inst: CanvasInstruction;\n      if (styleType == FillStrokeStyleType.String) inst = CanvasInstruction.FillStyle;\n      else if (styleType == FillStrokeStyleType.CanvasGradient) inst = CanvasInstruction.FillGradient;\n      else inst = CanvasInstruction.FillPattern;\n      super._writeOne(inst, <f64>value);\n    }\n  }\n  //#endregion FILLSTYLE\n\n  //#region FILLPATTERN\n  /**\n   * The CanvasRenderingContext2D.fillPattern property of the Canvas 2D API specifies the current\n   * fillStyle pattern\n   */\n  public get fillPattern(): CanvasPattern | null {\n    var index: i32 = this._stackOffset * 2;\n    var buff: ArrayBuffer = this._fillStyleStack;\n    var fillStyleType: FillStrokeStyleType = <FillStrokeStyleType>LOAD<i32>(\n      buff,\n      index,\n    );\n\n    if (fillStyleType == FillStrokeStyleType.CanvasPattern) {\n      var result: CanvasPattern = new CanvasPattern();\n      store<i32>(\n        changetype<usize>(result) + offsetof<CanvasPattern>(\"id\"),\n        LOAD<i32>(buff, index + 1),\n      );\n      return result;\n    }\n\n    return null;\n  }\n\n  public set fillPattern(value: CanvasPattern | null) {\n    if (value == null) {\n      this.fillStyle = defaultBlack;\n      return;\n    }\n    var index: i32 = this._stackOffset * 2;\n    var buff: ArrayBuffer = this._fillStyleStack;\n    STORE<i32>(buff, index, FillStrokeStyleType.CanvasPattern);\n    STORE<i32>(buff, index + 1, load<i32>(changetype<usize>(value) + offsetof<CanvasPattern>(\"id\")));\n  }\n  //#endregion FILLPATTERN\n\n  //#region FILLGRADIENT\n  /**\n   * The CanvasRenderingContext2D.fillGradient property of the Canvas 2D API specifies the current\n   * fillStyle gradient\n   */\n  public get fillGradient(): CanvasGradient | null {\n    var index: i32 = this._stackOffset * 2;\n    var buff: ArrayBuffer = this._fillStyleStack;\n    var fillStyleType: FillStrokeStyleType = <FillStrokeStyleType>LOAD<i32>(\n      buff,\n      index,\n    );\n    if (fillStyleType == FillStrokeStyleType.CanvasGradient) {\n      var result: CanvasGradient = new CanvasGradient();\n      store<i32>(\n        changetype<usize>(result) + offsetof<CanvasGradient>(\"id\"),\n        LOAD<i32>(buff, index + 1),\n      );\n      return result;\n    }\n\n    return null;\n  }\n\n  public set fillGradient(value: CanvasGradient | null) {\n    if (value == null) {\n      this.fillStyle = defaultBlack;\n      return;\n    }\n    var index: i32 = this._stackOffset * 2;\n    var buff: ArrayBuffer = this._fillStyleStack;\n    STORE<i32>(buff, index, FillStrokeStyleType.CanvasGradient);\n    STORE<i32>(buff, index + 1, load<i32>(changetype<usize>(value) + offsetof<CanvasGradient>(\"id\")));\n  }\n  //#endregion FILLGRADIENT\n\n  //#region CREATEPATTERN\n  /**\n   * The CanvasRenderingContext2D.createPattern() method of the Canvas 2D API creates a pattern\n   * using the specified image and repetition.\n   *\n   * @param {Image} img - A CanvasImageSource to be used as the pattern's Image.\n   * @param {CanvasPatternRepetition} repetition - An enum value indicating how to repeat the pattern's image.\n   */\n  public createPattern(img: Image, repetition: CanvasPatternRepetition): CanvasPattern {\n    var result = new CanvasPattern();\n    var id: i32 = load<i32>(changetype<usize>(img) + offsetof<Image>(\"_id\"));\n    store<i32>(changetype<usize>(result) + offsetof<CanvasPattern>(\"id\"), createPattern(this.id, id, repetition));\n    return result;\n  }\n  //#endregion CREATEPATTERN\n\n  //#region FILTER\n  /**\n   * An ArrayBuffer that contains 256 sets of string pointer values.\n   */\n  private _filterStack: ArrayBuffer = setArrayBufferValue(\n    new ArrayBuffer(0xFF * sizeof<usize>()),\n    changetype<usize>(defaultNone),\n  );\n\n  /**\n   * A private member that contains a single string value that represents the last\n   * filter value written by a drawing operation.\n   */\n  private _currentFilter: string = defaultNone;\n\n  /**\n   * The CanvasRenderingContext2D.filter property of the Canvas 2D API provides filter effects such\n   * as blurring and grayscaling. It is similar to the CSS filter property and accepts the same\n   * values.\n   */\n  public get filter(): string {\n    return changetype<string>(LOAD<usize>(this._filterStack, <i32>this._stackOffset));\n  }\n\n  public set filter(value: string) {\n    STORE<usize>(this._filterStack, <i32>this._stackOffset, changetype<usize>(value));\n  }\n\n  /**\n   * An internal function that writes the current filter value on the _filterStack if it currently\n   * does not match the last written filter string value to the buffer using write_one.\n   */\n  @inline\n  private _updateFilter(): void {\n    var value: string = changetype<string>(LOAD<usize>(this._filterStack, <i32>this._stackOffset));\n    if (value != this._currentFilter) {\n      this._currentFilter = value;\n      super._writeOne(CanvasInstruction.Filter, changetype<usize>(value));\n    }\n  }\n  //#endregion FILTER\n\n  //#region FONT\n  /**\n   * An ArrayBuffer that contains 256 sets of string pointer values.\n   */\n  private _fontStack: ArrayBuffer = setArrayBufferValue(\n    new ArrayBuffer(0xFF * sizeof<usize>()),\n    changetype<usize>(defaultFont),\n  );\n\n  /**\n   * A private member that contains a single string value that represents the last\n   * font value written by a drawing operation.\n   */\n  private _currentFont: string = defaultFont;\n\n  /**\n   * The CanvasRenderingContext2D.font property of the Canvas 2D API specifies the current text\n   * style to use when drawing text. This string uses the same syntax as the CSS font specifier.\n   */\n  public get font(): string {\n    return changetype<string>(LOAD<usize>(this._fontStack, <i32>this._stackOffset));\n  }\n\n  public set font(value: string) {\n    STORE<usize>(this._fontStack, <i32>this._stackOffset, changetype<usize>(value));\n  }\n\n  /**\n   * An internal function that writes the current font value on the _fontStack to the buffer if it\n   * currently does not match the last written font string value.\n   */\n  @inline\n  private _updateFont(): void {\n    var value: string = changetype<string>(LOAD<usize>(this._fontStack, <i32>this._stackOffset));\n    if (value != this._currentFont) {\n      this._currentFont = value;\n      super._writeOne(CanvasInstruction.Font, changetype<usize>(value));\n    }\n  }\n  //#endregion FONT\n\n  //#region GLOBALALPHA\n  /**\n   * An ArrayBuffer that contains 256 sets of f64 values.\n   */\n  private _globalAlphaStack: ArrayBuffer = setArrayBufferValue(\n    new ArrayBuffer(0xFF * sizeof<f64>()),\n    1.0,\n  );\n\n  /**\n   * A private member that contains a single float value that represents the last globalAlpha value\n   * written by a drawing operation.\n   */\n  private _currentGlobalAlpha: f64 = 1.0;\n\n  /**\n   * The CanvasRenderingContext2D.globalAlpha property of the Canvas 2D API specifies the alpha\n   * (transparency) value that is applied to shapes and images before they are drawn onto the\n   * canvas.\n   */\n  public get globalAlpha(): f64 {\n    return LOAD<f64>(this._globalAlphaStack, <i32>this._stackOffset);\n  }\n\n  public set globalAlpha(value: f64) {\n    if (!isFinite(value) || value < 0.0 || value > 1.0) return;\n    STORE<f64>(this._globalAlphaStack, <i32>this._stackOffset, value);\n  }\n\n  /**\n   * An internal function that writes the current globalAlpha value on the _globalAlphaStack to the\n   * buffer if it currently does not match the last written globalAlpha value.\n   */\n  @inline\n  private _updateGlobalAlpha(): void {\n    var value: f64 = LOAD<f64>(this._globalAlphaStack, <i32>this._stackOffset);\n    if (value != this._currentGlobalAlpha) {\n      this._currentGlobalAlpha = value;\n      super._writeOne(CanvasInstruction.GlobalAlpha, value);\n    }\n  }\n  //#endregion GLOBALALPHA\n\n  //#region GLOBALCOMPOSITEOPERATION\n  /**\n   * An ArrayBuffer that contains 256 sets of GlobalCompositeOperation values.\n   */\n  private _globalCompositeOperationStack: ArrayBuffer = setArrayBufferValue<GlobalCompositeOperation>(\n    new ArrayBuffer(0xFF * sizeof<GlobalCompositeOperation>()),\n    GlobalCompositeOperation.source_over,\n  );\n\n  /**\n   * A private member that contains a single GlobalCompositeOperation value that represents the last\n   * globalCompositeOperation value written by a drawing operation.\n   */\n  private _currentGlobalCompositeOperation: GlobalCompositeOperation = GlobalCompositeOperation.source_over;\n\n  /**\n   * The CanvasRenderingContext2D.globalCompositeOperation property of the Canvas 2D API sets the\n   * type of compositing operation to apply when drawing new shapes.\n   */\n  public get globalCompositeOperation(): GlobalCompositeOperation {\n    return LOAD<GlobalCompositeOperation>(this._globalCompositeOperationStack, <i32>this._stackOffset);\n  }\n\n  public set globalCompositeOperation(value: GlobalCompositeOperation) {\n    STORE<GlobalCompositeOperation>(this._globalCompositeOperationStack, <i32>this._stackOffset, value);\n  }\n\n  /**\n   * An internal function that writes the current globalCompositeOperation value on the\n   * _globalCompositeOperationStack to the buffer if it currently does not match the last written\n   * globalCompositeOperation value.\n   */\n  @inline\n  private _updateGlobalCompositeOperation(): void {\n    var value: GlobalCompositeOperation = LOAD<GlobalCompositeOperation>(\n      this._globalCompositeOperationStack,\n      <i32>this._stackOffset,\n    );\n    if (value != this._currentGlobalCompositeOperation) {\n      this._currentGlobalCompositeOperation = value;\n      super._writeOne(CanvasInstruction.GlobalCompositeOperation, <f64>value);\n    }\n  }\n  //#endregion GLOBALCOMPOSITEOPERATION\n\n  //#region IMAGESMOOTHINGENABLED\n  /**\n   * An ArrayBuffer that contains 256 sets of bool values.\n   */\n  private _imageSmoothingEnabledStack: ArrayBuffer = setArrayBufferValue<bool>(\n    new ArrayBuffer(0xFF * sizeof<bool>()),\n    true,\n  );\n\n  /**\n   * A private member that contains a single bool value that represents the last\n   * imageSmoothingEnabled value written by a drawing operation.\n   */\n  private _currentImageSmoothingEnabled: bool = true;\n\n  /**\n   * The imageSmoothingEnabled property of the CanvasRenderingContext2D interface, part of the\n   * Canvas API, determines whether scaled images are smoothed (true, default) or not (false). On\n   * getting the imageSmoothingEnabled property, the last value it was set to is returned.\n   */\n  public get imageSmoothingEnabled(): bool {\n    return LOAD<bool>(this._imageSmoothingEnabledStack, <i32>this._stackOffset);\n  }\n\n  public set imageSmoothingEnabled(value: bool) {\n    STORE<bool>(this._imageSmoothingEnabledStack, <i32>this._stackOffset, value);\n  }\n\n  /**\n   * An internal function that writes the current imageSmoothingEnabled value on the\n   * _imageSmoothingEnabledStack to the buffer if it currently does not match the last written\n   * imageSmoothingEnabled value.\n   */\n  @inline\n  private _updateImageSmoothingEnabled(): void {\n    var value: bool = LOAD<bool>(this._imageSmoothingEnabledStack, <i32>this._stackOffset);\n    if (value != this._currentImageSmoothingEnabled) {\n      this._currentImageSmoothingEnabled = value;\n      super._writeOne(CanvasInstruction.ImageSmoothingEnabled, value ? 1.0 : 0.0);\n    }\n  }\n  //#endregion IMAGESMOOTHINGENABLED\n\n  //#region IMAGESMOOTHINGQUALITY\n  /**\n   * An ArrayBuffer that contains 256 sets of ImageSmoothingQuality values.\n   */\n  private _imageSmoothingQualityStack: ArrayBuffer = setArrayBufferValue<ImageSmoothingQuality>(\n    new ArrayBuffer(0xFF * sizeof<ImageSmoothingQuality>()),\n    ImageSmoothingQuality.low,\n  );\n\n  /**\n   * A private member that contains a single ImageSmoothingQuality value that represents the last\n   * imageSmoothingQuality value written by a drawing operation.\n   */\n  private _currentImageSmoothingQuality: ImageSmoothingQuality = ImageSmoothingQuality.low;\n\n  /**\n   * The imageSmoothingQuality property of the CanvasRenderingContext2D interface, part of the\n   * Canvas API, lets you set the quality of image smoothing.\n   */\n  public get imageSmoothingQuality(): ImageSmoothingQuality {\n    return LOAD<ImageSmoothingQuality>(this._imageSmoothingQualityStack, <i32>this._stackOffset);\n  }\n\n  public set imageSmoothingQuality(value: ImageSmoothingQuality) {\n    STORE<ImageSmoothingQuality>(this._imageSmoothingQualityStack, <i32>this._stackOffset, value);\n  }\n\n  /**\n   * An internal function that writes the current imageSmoothingQuality value on the\n   * _imageSmoothingQualityStack to the buffer if it currently does not match the last written\n   * imageSmoothingQuality value, and imageSmoothingEnabled is true.\n   */\n  @inline\n  private _updateImageSmoothingQuality(): void {\n    if (LOAD<bool>(this._imageSmoothingEnabledStack, <i32>this._stackOffset)) {\n      var value: ImageSmoothingQuality = LOAD<ImageSmoothingQuality>(\n        this._imageSmoothingQualityStack,\n        <i32>this._stackOffset,\n      );\n      if (value != this._currentImageSmoothingQuality) {\n        this._currentImageSmoothingQuality = value;\n        super._writeOne(CanvasInstruction.ImageSmoothingQuality, <f64>value);\n      }\n    }\n  }\n  //#endregion IMAGESMOOTHINGQUALITY\n\n  //#region LINECAP\n  /**\n   * An ArrayBuffer that contains 256 sets of LineCap values.\n   */\n  private _lineCapStack: ArrayBuffer = setArrayBufferValue<LineCap>(\n    new ArrayBuffer(0xFF * sizeof<LineCap>()),\n    LineCap.butt,\n  );\n\n  /**\n   * A private member that contains a single LineCap value that represents the last\n   * lineCap value written by a drawing operation.\n   */\n  private _currentLineCap: LineCap = LineCap.butt;\n\n  /**\n   * The CanvasRenderingContext2D.lineCap property of the Canvas 2D API determines the shape used\n   * to draw the end points of lines.\n   */\n  public get lineCap(): LineCap {\n    return LOAD<LineCap>(this._lineCapStack, <i32>this._stackOffset);\n  }\n\n  public set lineCap(value: LineCap) {\n    STORE<LineCap>(this._lineCapStack, <i32>this._stackOffset, value);\n  }\n\n  /**\n   * An internal function that writes the current lineCap value on the _lineCapStack to the buffer\n   * if it currently does not match the last written lineCap value.\n   */\n  @inline\n  private _updateLineCap(): void {\n    var value: LineCap = LOAD<LineCap>(\n      this._lineCapStack,\n      <i32>this._stackOffset,\n    );\n    if (value != this._currentLineCap) {\n      this._currentLineCap = value;\n      super._writeOne(CanvasInstruction.LineCap, <f64>value);\n    }\n  }\n  //#endregion LINECAP\n\n  //#region LINEDASH\n  /**\n   * An ArrayBuffer that contains 256 sets of usize pointer values.\n   */\n  private _lineDashStack: ArrayBuffer = setArrayBufferValue<usize>(\n    new ArrayBuffer(0xFF * sizeof<usize>()),\n    changetype<usize>(defaultLineDash),\n  );\n\n  /**\n   * A private member that contains a single LineCap value that represents the last\n   * lineCap value written by a drawing operation.\n   */\n  private _currentLineDash: Float64Array = defaultLineDash;\n\n  /**\n   * The getLineDash() method of the Canvas 2D API's CanvasRenderingContext2D interface gets the\n   * current line dash pattern.\n   */\n  public getLineDash(): Float64Array {\n    return this._getLineDash();\n  }\n\n  /**\n   * The setLineDash() method of the Canvas 2D API's CanvasRenderingContext2D interface sets the\n   * line dash pattern used when stroking lines. It uses a Float64Array of values that specify\n   * alternating lengths of lines and gaps which describe the pattern.\n   *\n   * @param {Float64Array} value - An Array of numbers that specify distances to alternately draw a\n   * line and a gap (in coordinate space units). If the number of elements in the array is odd, the\n   * elements of the array get copied and concatenated. For example, Float64Array [5, 15, 25] will\n   * become Float64Array [5, 15, 25, 5, 15, 25]. If the array is empty, the line dash list is\n   * cleared and line strokes return to being solid.\n   */\n  public setLineDash(value: Float64Array): void {\n    STORE<usize>(this._lineDashStack, <i32>this._stackOffset, changetype<usize>(value));\n  }\n\n  /**\n   * An internal getLineDash function that loops backwards from the current stackOffset until it\n   * doesn't find a null pointer, then returns the reference.\n   */\n  @inline\n  private _getLineDash(): Float64Array {\n    var offset: i32 = this._stackOffset;\n    var pointer: usize = LOAD<usize>(this._lineDashStack, offset);\n    while (changetype<Float64Array>(pointer) == null) {\n      --offset;\n      pointer = LOAD<usize>(this._lineDashStack, offset);\n    }\n    return changetype<Float64Array>(pointer);\n  }\n\n  /**\n   * An internal function that writes the current lineDash value on the _lineDashStack to the buffer\n   * if it currently does not match the last written lineCap value.\n   */\n  @inline\n  private _updateLineDash(): void {\n    var lineDash: Float64Array = this._getLineDash();\n    var current: Float64Array = this._currentLineDash;\n\n    if (!arraysEqual(current, lineDash)) {\n      this._currentLineDash = lineDash;\n      super._writeOne(CanvasInstruction.LineDash, <f64>changetype<usize>(lineDash));\n    }\n  }\n  //#endregion LINEDASH\n\n  //#region LINEDASHOFFSET\n  /**\n   * An ArrayBuffer that contains 256 sets of f64 values.\n   */\n  private _lineDashOffsetStack: ArrayBuffer = setArrayBufferValue(\n    new ArrayBuffer(0xFF * sizeof<f64>()),\n    0.0,\n  );\n\n  /**\n   * A private member that contains a single float value that represents the last lineDashOffset value\n   * written by a drawing operation.\n   */\n  private _currentLineDashOffset: f64 = 0.0;\n\n  /**\n   * The CanvasRenderingContext2D.lineDashOffset property of the Canvas 2D API sets the line dash\n   * offset, or \"phase.\"\n   */\n  public get lineDashOffset(): f64 {\n    return LOAD<f64>(this._lineDashOffsetStack, <i32>this._stackOffset);\n  }\n\n  public set lineDashOffset(value: f64) {\n    if (!isFinite(value)) return;\n    STORE<f64>(this._lineDashOffsetStack, <i32>this._stackOffset, value);\n  }\n\n  /**\n   * An internal function that writes the current lineDashOffset value on the _lineDashOffsetStack\n   * to the buffer if it currently does not match the last written lineDashOffset value.\n   */\n  @inline\n  private _updateLineDashOffset(): void {\n    var value: f64 = LOAD<f64>(this._lineDashOffsetStack, <i32>this._stackOffset);\n    if (value != this._currentLineDashOffset) {\n      this._currentLineDashOffset = value;\n      super._writeOne(CanvasInstruction.LineDashOffset, value);\n    }\n  }\n  //#endregion LINEDASHOFFSET\n\n  //#region LINEJOIN\n  /**\n   * An ArrayBuffer that contains 256 sets of LineJoin values.\n   */\n  private _lineJoinStack: ArrayBuffer = setArrayBufferValue<LineJoin>(\n    new ArrayBuffer(0xFF * sizeof<LineJoin>()),\n    LineJoin.miter,\n  );\n\n  /**\n   * A private member that contains a single LineJoin value that represents the last\n   * lineJoin value written by a drawing operation.\n   */\n  private _currentLineJoin: LineJoin = LineJoin.miter;\n\n  /**\n   * The CanvasRenderingContext2D.lineJoin property of the Canvas 2D API determines the shape used\n   * to join two line segments where they meet.\n   *\n   * This property has no effect wherever two connected segments have the same direction, because\n   * no joining area will be added in this case. Degenerate segments with a length of zero (i.e.,\n   * with all endpoints and control points at the exact same position) are also ignored.\n   */\n  public get lineJoin(): LineJoin {\n    return LOAD<LineJoin>(this._lineJoinStack, <i32>this._stackOffset);\n  }\n\n  public set lineJoin(value: LineJoin) {\n    STORE<LineJoin>(this._lineJoinStack, <i32>this._stackOffset, value);\n  }\n\n  /**\n   * An internal function that writes the current lineJoin value on the  _lineJoinStack if it\n   * currently does not match the last written lineJoin value.\n   */\n  @inline\n  private _updateLineJoin(): void {\n    var value: LineJoin = LOAD<LineJoin>(\n      this._lineJoinStack,\n      <i32>this._stackOffset,\n    );\n    if (value != this._currentLineJoin) {\n      this._currentLineJoin = value;\n      super._writeOne(CanvasInstruction.LineJoin, <f64>value);\n    }\n  }\n  //#endregion\n\n  //#region LINEWIDTH\n  /**\n   * An ArrayBuffer that contains 256 sets of f64 values.\n   */\n  private _lineWidthStack: ArrayBuffer = setArrayBufferValue(\n    new ArrayBuffer(0xFF * sizeof<f64>()),\n    1.0,\n  );\n\n  /**\n   * A private member that contains a single float value that represents the last lineWidth value\n   * written by a drawing operation.\n   */\n  private _currentLineWidth: f64 = 1.0;\n\n  /**\n   * The CanvasRenderingContext2D.lineWidth property of the Canvas 2D API sets the line dash\n   * offset, or \"phase.\"\n   */\n  public get lineWidth(): f64 {\n    return LOAD<f64>(this._lineWidthStack, <i32>this._stackOffset);\n  }\n\n  public set lineWidth(value: f64) {\n    if (!isFinite(value) || value < 0) return;\n    STORE<f64>(this._lineWidthStack, <i32>this._stackOffset, value);\n  }\n\n  /**\n   * An internal function that writes the current lineWidth value on the _lineWidthStack to the\n   * buffer if it currently does not match the last written lineWidth value.\n   */\n  @inline\n  private _updateLineWidth(): void {\n    var value: f64 = LOAD<f64>(this._lineWidthStack, <i32>this._stackOffset);\n    if (value != this._currentLineWidth) {\n      this._currentLineWidth = value;\n      super._writeOne(CanvasInstruction.LineWidth, value);\n    }\n  }\n  //#endregion\n\n  //#region MITERLIMIT\n  /**\n   * An ArrayBuffer that contains 256 sets of f64 values.\n   */\n  private _miterLimitStack: ArrayBuffer = setArrayBufferValue(\n    new ArrayBuffer(0xFF * sizeof<f64>()),\n    10.0,\n  );\n\n  /**\n   * A private member that contains a single float value that represents the last miterLimit value\n   * written by a drawing operation.\n   */\n  private _currentMiterLimit: f64 = 10.0;\n\n  /**\n   * The CanvasRenderingContext2D.miterLimit property of the Canvas 2D API sets the miter limit\n   * ratio. It establishes a limit on the miter when two lines join at a sharp angle, to let you\n   * control how thick the junction becomes.\n   */\n  public get miterLimit(): f64 {\n    return LOAD<f64>(this._miterLimitStack, <i32>this._stackOffset);\n  }\n\n  public set miterLimit(value: f64) {\n    if (!isFinite(value) || value < 0) return;\n    STORE<f64>(this._miterLimitStack, <i32>this._stackOffset, value);\n  }\n\n  /**\n   * An internal function that writes the current miterLimit value on the _miterLimitStack to the\n   * buffer if it currently does not match the last written miterLimit value.\n   */\n  @inline\n  private _updateMiterLimit(): void {\n    var value: f64 = LOAD<f64>(this._miterLimitStack, <i32>this._stackOffset);\n    if (value != this._currentMiterLimit) {\n      this._currentMiterLimit = value;\n      super._writeOne(CanvasInstruction.MiterLimit, value);\n    }\n  }\n  //#endregion MITERLIMIT\n\n  //#region SHADOWBLUR\n  /**\n   * An ArrayBuffer that contains 256 sets of f64 values.\n   */\n  private _shadowBlurStack: ArrayBuffer = new ArrayBuffer(0xFF * sizeof<f64>());\n\n  /**\n   * A private member that contains a single float value that represents the last shadowBlur value\n   * written by a drawing operation.\n   */\n  private _currentShadowBlur: f64 = 0.0;\n\n  /**\n   * The CanvasRenderingContext2D.shadowBlur property of the Canvas 2D API specifies the amount of\n   * blur applied to shadows. The default is 0 (no blur).\n   *\n   * The shadowBlur value is a non-negative float specifying the level of shadow blur, where 0\n   * represents no blur and larger numbers represent increasingly more blur. This value doesn't\n   * correspond to a number of pixels, and is not affected by the current transformation matrix. The\n   * default value is 0. Negative, Infinity, and NaN values are ignored.\n   */\n  public get shadowBlur(): f64 {\n    return LOAD<f64>(this._shadowBlurStack, <i32>this._stackOffset);\n  }\n\n  public set shadowBlur(value: f64) {\n    if (!isFinite(value) || value < 0) return;\n    STORE<f64>(this._shadowBlurStack, <i32>this._stackOffset, value);\n  }\n\n  /**\n   * An internal function that writes the current shadowBlur value on the _shadowBlurStack to the\n   * buffer if it currently does not match the last written shadowBlur value.\n   */\n  @inline\n  private _updateShadowBlur(): void {\n    var value: f64 = LOAD<f64>(this._shadowBlurStack, <i32>this._stackOffset);\n    if (value != this._currentShadowBlur) {\n      this._currentShadowBlur = value;\n      super._writeOne(CanvasInstruction.ShadowBlur, value);\n    }\n  }\n  //#endregion SHADOWBLUR\n\n  //#region SHADOWCOLOR\n  /**\n   * An ArrayBuffer that contains 256 pointers to shadowColor strings.\n   */\n  private _shadowColorStack: ArrayBuffer = setArrayBufferValue<usize>(\n    new ArrayBuffer(0xFF * sizeof<usize>()),\n    changetype<usize>(defaultShadowColor),\n  );\n\n  /**\n   * A private member that contains a single StrokeShadowColorType value that represents the last\n   * shadowColor value written by a drawing operation\n   */\n  private _currentShadowColor: string = defaultShadowColor;\n\n\n  /**\n   * The CanvasRenderingContext2D.shadowColor property of the Canvas 2D API specifies the current text\n   * representing a CSS Color\n   */\n  public get shadowColor(): string {\n    return changetype<string>(LOAD<usize>(this._shadowColorStack, this._stackOffset));\n  }\n\n  public set shadowColor(value: string) {\n    if (value == null) value = defaultShadowColor;\n    STORE<usize>(this._shadowColorStack, this._stackOffset, changetype<usize>(value));\n  }\n\n  /**\n   * An internal function that writes the current shadowColor value on the _shadowColorStack to the\n   * buffer if it currently does not match the last written shadowColor.\n   */\n  @inline\n  private _updateShadowColor(): void {\n    var value: string = changetype<string>(LOAD<usize>(this._shadowColorStack, <i32>this._stackOffset));\n    if (value != this._currentShadowColor) {\n      this._currentFilter = value;\n      super._writeOne(CanvasInstruction.ShadowColor, changetype<usize>(value));\n    }\n  }\n  //#endregion\n\n  //#region SHADOWOFFSETX\n  /**\n   * An ArrayBuffer that contains 256 sets of f64 values.\n   */\n  private _shadowOffsetXStack: ArrayBuffer = new ArrayBuffer(0xFF * sizeof<f64>());\n\n  /**\n   * A private member that contains a single float value that represents the last shadowOffsetX value\n   * written by a drawing operation.\n   */\n  private _currentShadowOffsetX: f64 = 0.0;\n\n  /**\n   * The CanvasRenderingContext2D.shadowOffsetX property of the Canvas 2D API specifies the distance\n   * that shadows will be offset horizontally.\n   *\n   * The value is a f64 specifying the distance that shadows will be offset horizontally. Positive\n   * values are to the right, and negative to the left. The default value is 0 (no horizontal\n   * offset). Infinity and NaN values are ignored.\n   */\n  public get shadowOffsetX(): f64 {\n    return LOAD<f64>(this._shadowOffsetXStack, <i32>this._stackOffset);\n  }\n\n  public set shadowOffsetX(value: f64) {\n    if (!isFinite(value)) return;\n    STORE<f64>(this._shadowOffsetXStack, <i32>this._stackOffset, value);\n  }\n\n  /**\n   * An internal function that writes the current shadowOffsetX value on the _shadowOffsetXStack to the\n   * buffer if it currently does not match the last written shadowOffsetX value.\n   */\n  @inline\n  private _updateShadowOffsetX(): void {\n    var value: f64 = LOAD<f64>(this._shadowOffsetXStack, <i32>this._stackOffset);\n    if (value != this._currentShadowOffsetX) {\n      this._currentShadowOffsetX = value;\n      super._writeOne(CanvasInstruction.ShadowOffsetX, value);\n    }\n  }\n  //#endregion SHADOWOFFSETX\n\n  //#region SHADOWOFFSETY\n  /**\n   * An ArrayBuffer that contains 256 sets of f64 values.\n   */\n  private _shadowOffsetYStack: ArrayBuffer = new ArrayBuffer(0xFF * sizeof<f64>());\n\n  /**\n   * A private member that contains a single float value that represents the last shadowOffsetY value\n   * written by a drawing operation.\n   */\n  private _currentShadowOffsetY: f64 = 0.0;\n\n  /**\n   * The CanvasRenderingContext2D.shadowOffsetY property of the Canvas 2D API specifies the distance\n   * that shadows will be offset vertically.\n   *\n   * The value is a f64 specifying the distance that shadows will be offset horizontally. Positive\n   * values are down, and negative are up. The default value is 0 (no vertical offset). Infinity and\n   * NaN values are ignored\n   */\n  public get shadowOffsetY(): f64 {\n    return LOAD<f64>(this._shadowOffsetYStack, <i32>this._stackOffset);\n  }\n\n  public set shadowOffsetY(value: f64) {\n    if (!isFinite(value)) return;\n    STORE<f64>(this._shadowOffsetYStack, <i32>this._stackOffset, value);\n  }\n\n  /**\n   * An internal function that writes the current shadowOffsetY value on the _shadowOffsetYStack to the\n   * buffer if it currently does not match the last written shadowOffsetY value.\n   */\n  @inline\n  private _updateShadowOffsetY(): void {\n    var value: f64 = LOAD<f64>(this._shadowOffsetYStack, <i32>this._stackOffset);\n    if (value != this._currentShadowOffsetY) {\n      this._currentShadowOffsetY = value;\n      super._writeOne(CanvasInstruction.ShadowOffsetY, value);\n    }\n  }\n  //#endregion SHADOWOFFSETY\n\n  //#region STROKESTYLE\n  /**\n   * An ArrayBuffer that contains 256 sets of 2 usize values. For each strokeStyle, if the strokeStyle is\n   * a string, the second i32 value will be a pointer, otherwise, it's a `usize` representing the\n   * style's external objectID.\n   */\n  private _strokeStyleStack: ArrayBuffer = setArrayBufferValue2<usize>(\n    new ArrayBuffer(0xFF * sizeof<usize>() * 2),\n    <usize>FillStrokeStyleType.String,\n    changetype<usize>(defaultBlack),\n  );\n\n  /**\n   * A private member that contains a single StrokeFillStyleType value that represents the last\n   * strokeStyle value written by a drawing operation\n   */\n  private _currentStrokeStyleType: FillStrokeStyleType = FillStrokeStyleType.String;\n\n  /**\n   * A private member that contains a single pointer or id value that represents the last\n   * strokeStyle value written by a drawing operation\n   */\n  private _currentStrokeStyleValue: usize = changetype<usize>(defaultBlack);\n\n  /**\n   * The CanvasRenderingContext2D.strokeStyle property of the Canvas 2D API specifies the color,\n   * gradient, or pattern to use for the strokes (outlines) around shapes. The default is #000\n   * (black).\n   */\n  public get strokeStyle(): string | null {\n    var index: i32 = this._stackOffset * 2;\n    var strokeStyleType: FillStrokeStyleType = <FillStrokeStyleType>LOAD<usize>(\n      this._strokeStyleStack,\n      index,\n    );\n    if (strokeStyleType == FillStrokeStyleType.String) {\n      return changetype<string>(LOAD<usize>(this._strokeStyleStack, index + 1));\n    }\n    return null;\n  }\n\n  public set strokeStyle(value: string | null) {\n    if (value == null) value = defaultBlack;\n    var index: i32 = this._stackOffset * 2;\n    var buff: ArrayBuffer = this._strokeStyleStack;\n    STORE<usize>(buff, index, <usize>FillStrokeStyleType.String);\n    STORE<usize>(buff, index + 1, changetype<usize>(value));\n  }\n\n  /**\n   * An internal function that writes the current strokeStyle value on the _strokeStyleStack to the\n   * buffer if it currently does not match the last written strokeStyle.\n   */\n  @inline\n  private _updateStrokeStyle(): void {\n    var buff: ArrayBuffer = this._strokeStyleStack;\n    var index: i32 = <i32>this._stackOffset * 2;\n    var styleType: FillStrokeStyleType = <FillStrokeStyleType>LOAD<usize>(buff, index);\n    var value: usize = LOAD<usize>(buff, index + 1);\n    if (styleType != this._currentStrokeStyleType || value != this._currentStrokeStyleValue) {\n      var inst: CanvasInstruction;\n      if (styleType == FillStrokeStyleType.String) inst = CanvasInstruction.StrokeStyle;\n      else if (styleType == FillStrokeStyleType.CanvasGradient) inst = CanvasInstruction.StrokeGradient;\n      else inst = CanvasInstruction.StrokePattern;\n      super._writeOne(inst, <f64>value);\n    }\n  }\n  //#endregion STROKESTYLE\n\n  //#region STROKEPATTERN\n  /**\n   * The CanvasRenderingContext2D.strokePattern property of the Canvas 2D API specifies pattern to\n   * use for the strokes (outlines) around shapes. The default is null.\n   */\n  public get strokePattern(): CanvasPattern | null {\n    var index: i32 = this._stackOffset * 2;\n    var buff: ArrayBuffer = this._strokeStyleStack;\n    var strokeStyleType: FillStrokeStyleType = <FillStrokeStyleType>LOAD<i32>(\n      buff,\n      index,\n    );\n\n    if (strokeStyleType == FillStrokeStyleType.CanvasPattern) {\n      var result: CanvasPattern = new CanvasPattern();\n      store<i32>(\n        changetype<usize>(result) + offsetof<CanvasPattern>(\"id\"),\n        LOAD<i32>(buff, index + 1),\n      );\n      return result;\n    }\n\n    return null;\n  }\n\n  public set strokePattern(value: CanvasPattern | null) {\n    if (value == null) {\n      this.strokeStyle = defaultBlack;\n      return;\n    }\n    var index: i32 = this._stackOffset * 2;\n    var buff: ArrayBuffer = this._strokeStyleStack;\n    STORE<i32>(buff, index, FillStrokeStyleType.CanvasPattern);\n    STORE<i32>(buff, index + 1, load<i32>(changetype<usize>(value) + offsetof<CanvasPattern>(\"id\")));\n  }\n  //#endregion STROKEPATTERN\n\n  //#region STROKEGRADIENT\n  /**\n   * The CanvasRenderingContext2D.strokeGradient property of the Canvas 2D API specifies the\n   * gradient to use for the strokes (outlines) around shapes. The default is null.\n   */\n  public get strokeGradient(): CanvasGradient | null {\n    var index: i32 = this._stackOffset * 2;\n    var buff: ArrayBuffer = this._strokeStyleStack;\n    var strokeStyleType: FillStrokeStyleType = <FillStrokeStyleType>LOAD<i32>(\n      buff,\n      index,\n    );\n    if (strokeStyleType == FillStrokeStyleType.CanvasGradient) {\n      var result: CanvasGradient = new CanvasGradient();\n      store<i32>(\n        changetype<usize>(result) + offsetof<CanvasGradient>(\"id\"),\n        LOAD<i32>(buff, index + 1),\n      );\n      return result;\n    }\n\n    return null;\n  }\n\n  public set strokeGradient(value: CanvasGradient | null) {\n    if (value == null) {\n      this.strokeStyle = defaultBlack;\n      return;\n    }\n    var index: i32 = this._stackOffset * 2;\n    var buff: ArrayBuffer = this._strokeStyleStack;\n    STORE<i32>(buff, index, FillStrokeStyleType.CanvasGradient);\n    STORE<i32>(buff, index + 1, load<i32>(changetype<usize>(value) + offsetof<CanvasGradient>(\"id\")));\n  }\n  //#endregion STROKEGRADIENT\n\n  //#region TEXTALIGN\n  /**\n   * An ArrayBuffer that contains 256 sets of TextAlign values.\n   */\n  private _textAlignStack: ArrayBuffer = setArrayBufferValue<TextAlign>(\n    new ArrayBuffer(0xFF * sizeof<TextAlign>()),\n    TextAlign.start,\n  );\n\n  /**\n   * A private member that contains a single LineCap value that represents the last\n   * lineCap value written by a drawing operation.\n   */\n  private _currentTextAlign: TextAlign = TextAlign.start;\n\n  /**\n   * The CanvasRenderingContext2D.textAlign property of the Canvas 2D API specifies the current text\n   * alignment used when drawing text.\n   *\n   * The alignment is relative to the x value of the fillText() method. For example, if textAlign is\n   * \"center\", then the text's left edge will be at x - (textWidth / 2).\n   */\n  public get textAlign(): TextAlign {\n    return LOAD<TextAlign>(this._textAlignStack, <i32>this._stackOffset);\n  }\n\n  public set textAlign(value: TextAlign) {\n    STORE<TextAlign>(this._textAlignStack, <i32>this._stackOffset, value);\n  }\n\n  /**\n   * An internal function that writes the current textAlign value on the _textAlignStack to the\n   * buffer if it currently does not match the last written textAlign value.\n   */\n  @inline\n  private _updateTextAlign(): void {\n    var value: TextAlign = LOAD<TextAlign>(\n      this._textAlignStack,\n      <i32>this._stackOffset,\n    );\n    if (value != this._currentTextAlign) {\n      this._currentTextAlign = value;\n      super._writeOne(CanvasInstruction.TextAlign, <f64>value);\n    }\n  }\n  //#endregion TEXTALIGN\n\n  //#region TEXTBASELINE\n  /**\n   * An ArrayBuffer that contains 256 sets of TextBaseline values.\n   */\n  private _textBaselineStack: ArrayBuffer = setArrayBufferValue<TextBaseline>(\n    new ArrayBuffer(0xFF * sizeof<TextBaseline>()),\n    TextBaseline.alphabetic,\n  );\n\n  /**\n   * A private member that contains a single LineCap value that represents the last\n   * lineCap value written by a drawing operation.\n   */\n  private _currentTextBaseline: TextBaseline = TextBaseline.alphabetic;\n\n  /**\n   * The CanvasRenderingContext2D.textBaseline property of the Canvas 2D API specifies the current\n   * text baseline used when drawing text.\n   */\n  public get textBaseline(): TextBaseline {\n    return LOAD<TextBaseline>(this._textBaselineStack, <i32>this._stackOffset);\n  }\n\n  public set textBaseline(value: TextBaseline) {\n    STORE<TextBaseline>(this._textBaselineStack, <i32>this._stackOffset, value);\n  }\n\n  /**\n   * An internal function that writes the current textBaseline value on the _textBaselineStack to the\n   * buffer if it currently does not match the last written textBaseline value.\n   */\n  @inline\n  private _updateTextBaseline(): void {\n    var value: TextBaseline = LOAD<TextBaseline>(\n      this._textBaselineStack,\n      <i32>this._stackOffset,\n    );\n    if (value != this._currentTextBaseline) {\n      this._currentTextBaseline = value;\n      super._writeOne(CanvasInstruction.TextBaseline, <f64>value);\n    }\n  }\n  //#endregion TEXTBASELINE\n\n  //#region SAVE\n  /**\n   * An ArrayBuffer that contains 256 sets of bool values.\n   */\n  private _saveStack: ArrayBuffer = new ArrayBuffer(0xFF * sizeof<bool>());\n\n  /**\n   * The CanvasRenderingContext2D.save() method of the Canvas 2D API saves the entire state of the\n   * canvas by pushing the current state onto a stack.\n   *\n   * The drawing state that gets saved onto a stack consists of:\n   *\n   * - The current transformation matrix.\n   * - The current clipping region.\n   * - The current dash list.\n   * - The current values of the following attributes: strokeStyle, fillStyle, globalAlpha, lineWidth, lineCap, lineJoin, miterLimit, lineDashOffset, shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor, globalCompositeOperation, font, textAlign, textBaseline, direction, imageSmoothingEnabled.\n   *\n   * @param {bool} hard - Tells the context to perform an actual `save()` operation. Default value is false.\n   */\n  public save(hard: bool = false): void {\n    var offset: i32 = <i32>this._stackOffset;\n    var nextOffset: i32 = offset + 1;\n    if (nextOffset >= <i32>u8.MAX_VALUE) unreachable();\n    var transformIndex: i32 = offset * 6;\n    var nextTransformIndex: i32 = transformIndex + 6;\n    var styleIndex: i32 = offset << 1;\n    var nextStyleIndex = styleIndex + 2;\n\n    // currentTransform\n    var target: ArrayBuffer = this._transformStack;\n    STORE<f64>(target, nextTransformIndex, LOAD<f64>(target, transformIndex));\n    STORE<f64>(target, nextTransformIndex + 1, LOAD<f64>(target, transformIndex + 1));\n    STORE<f64>(target, nextTransformIndex + 2, LOAD<f64>(target, transformIndex + 2));\n    STORE<f64>(target, nextTransformIndex + 3, LOAD<f64>(target, transformIndex + 3));\n    STORE<f64>(target, nextTransformIndex + 4, LOAD<f64>(target, transformIndex + 4));\n    STORE<f64>(target, nextTransformIndex + 5, LOAD<f64>(target, transformIndex + 5));\n\n    // direction\n    target = this._directionStack;\n    STORE<CanvasDirection>(target, nextOffset, LOAD<CanvasDirection>(target, offset));\n\n    // fillStyle\n    target = this._fillStyleStack;\n    STORE<usize>(target, nextStyleIndex, LOAD<usize>(target, styleIndex));\n    STORE<usize>(target, nextStyleIndex + 1, LOAD<usize>(target, styleIndex + 1));\n\n    // filter\n    target = this._filterStack;\n    STORE<usize>(target, nextOffset, LOAD<usize>(target, offset));\n\n    // font\n    target = this._fontStack;\n    STORE<usize>(target, nextOffset, LOAD<usize>(target, offset));\n\n    // globalAlpha\n    target = this._globalAlphaStack;\n    STORE<f64>(target, nextOffset, LOAD<f64>(target, offset));\n\n    // globalCompositeOperation\n    target = this._globalCompositeOperationStack;\n    STORE<GlobalCompositeOperation>(target, nextOffset, LOAD<GlobalCompositeOperation>(target, offset));\n\n    // imageSmoothingEnabled\n    target = this._imageSmoothingEnabledStack;\n    STORE<bool>(target, nextOffset, LOAD<bool>(target, offset));\n\n    // imageSmoothingQuality\n    target = this._imageSmoothingQualityStack;\n    STORE<ImageSmoothingQuality>(target, nextOffset, LOAD<ImageSmoothingQuality>(target, offset));\n\n    // lineCap\n    target = this._lineCapStack;\n    STORE<LineCap>(target, nextOffset, LOAD<LineCap>(target, offset));\n\n    // lineDash\n\n    /**\n     * Whenever a save occurs, if it would overwrite a reference that already exists, we must free\n     * it manually.\n     */\n    var nextLineDash: usize = LOAD<usize>(this._lineDashStack, nextOffset);\n    if (changetype<Float64Array>(nextLineDash) != null) {\n      // always free the underlying buffer FIRST\n      memory.free(changetype<usize>(changetype<Float64Array>(nextLineDash).buffer));\n      memory.free(nextLineDash);\n    }\n\n    STORE<usize>(this._lineDashStack, nextOffset, changetype<usize>(null));\n\n    // lineDashOffset\n    target = this._lineDashOffsetStack;\n    STORE<f64>(target, nextOffset, LOAD<f64>(target, offset));\n\n    // lineJoin\n    target = this._lineJoinStack;\n    STORE<LineJoin>(target, nextOffset, LOAD<LineJoin>(target, offset));\n\n    // lineWidth\n    target = this._lineWidthStack;\n    STORE<f64>(target, nextOffset, LOAD<f64>(target, offset));\n\n    // miterLimit\n    target = this._miterLimitStack;\n    STORE<f64>(target, nextOffset, LOAD<f64>(target, offset));\n\n    // shadowBlur\n    target = this._shadowBlurStack;\n    STORE<f64>(target, nextOffset, LOAD<f64>(target, offset));\n\n    // shadowColor\n    target = this._shadowColorStack;\n    STORE<usize>(target, nextOffset, LOAD<usize>(target, offset));\n\n    // shadowOffsetX\n    target = this._shadowOffsetXStack;\n    STORE<f64>(target, nextOffset, LOAD<f64>(target, offset));\n\n    // shadowOffsetY\n    target = this._shadowOffsetYStack;\n    STORE<f64>(target, nextOffset, LOAD<f64>(target, offset));\n\n    // strokeStyle\n    target = this._strokeStyleStack;\n    STORE<usize>(target, nextStyleIndex, LOAD<usize>(target, styleIndex));\n    STORE<usize>(target, nextStyleIndex + 1, LOAD<usize>(target, styleIndex + 1));\n\n    // textBaseline\n    target = this._textBaselineStack;\n    STORE<TextBaseline>(target, nextOffset, LOAD<TextBaseline>(target, offset));\n\n    // textAlign\n    target = this._textAlignStack;\n    STORE<TextAlign>(target, nextOffset, LOAD<TextAlign>(target, offset));\n\n    if (hard) {\n      STORE<bool>(this._saveStack, nextOffset, true);\n      super._writeZero(CanvasInstruction.Save);\n    }\n\n    this._stackOffset = <u8>nextOffset;\n  }\n  //#endregion SAVE\n\n  //#region RESTORE\n  /**\n   * The CanvasRenderingContext2D.restore() method of the Canvas 2D API restores the most recently\n   * saved canvas state by popping the top entry in the drawing state stack. If there is no saved\n   * state, this method does nothing.\n   *\n   * In the case of the hard restore, this function will mirror what the browser does, and modifies\n   * the last written values instead of just moving the stack pointer. This ensures that the writer\n   * emulates the browser state machine as accurately as possible.\n   */\n  public restore(): void {\n    if (this._stackOffset == <u8>0) return;\n    var currentOffset: i32 = <i32>this._stackOffset;\n    var nextOffset: i32 = currentOffset - 1;\n    var styleOffset: i32 = nextOffset * 2;\n    var target: ArrayBuffer;\n    var source: ArrayBuffer;\n    var transformOffset: i32 = nextOffset * 6;\n\n    if (LOAD<bool>(this._saveStack, currentOffset)) {\n      target = this._currentTransform;\n      source = this._transformStack;\n\n      // transformCurrent\n      STORE<f64>(target, 0, LOAD<f64>(source, transformOffset));\n      STORE<f64>(target, 1, LOAD<f64>(source, transformOffset + 1));\n      STORE<f64>(target, 2, LOAD<f64>(source, transformOffset + 2));\n      STORE<f64>(target, 3, LOAD<f64>(source, transformOffset + 3));\n      STORE<f64>(target, 4, LOAD<f64>(source, transformOffset + 4));\n      STORE<f64>(target, 5, LOAD<f64>(source, transformOffset + 5));\n\n      // direction\n      this._currentDirection = LOAD<CanvasDirection>(this._directionStack, nextOffset);\n\n      // fillStyle\n      source = this._fillStyleStack;\n      this._currentFillStyleType = <FillStrokeStyleType>LOAD<usize>(source, styleOffset);\n      this._currentFillStyleValue = LOAD<usize>(source, styleOffset + 1);\n\n      // filter\n      this._currentFilter = changetype<string>(LOAD<usize>(this._filterStack, nextOffset));\n\n      // font\n      this._currentFont = changetype<string>(LOAD<usize>(this._fontStack, nextOffset));\n\n      // globalAlpha\n      this._currentGlobalAlpha = LOAD<f64>(this._globalAlphaStack, nextOffset);\n\n      // globalCompositeOperation\n      this._currentGlobalCompositeOperation = LOAD<GlobalCompositeOperation>(this._globalCompositeOperationStack, nextOffset);\n\n      // imageSmoothingEnabled\n      this._currentImageSmoothingEnabled = LOAD<bool>(this._imageSmoothingEnabledStack, nextOffset);\n\n      // imageSmoothingQuality\n      this._currentImageSmoothingQuality = LOAD<ImageSmoothingQuality>(this._imageSmoothingQualityStack, nextOffset);\n\n      // lineCap\n      this._currentLineCap = LOAD<LineCap>(this._lineCapStack, nextOffset);\n\n      // lineDash\n      this._currentLineDash = changetype<Float64Array>(LOAD<usize>(this._lineDashStack, nextOffset));\n\n      // lineDashOffset\n      this._currentLineDashOffset = LOAD<f64>(this._lineDashOffsetStack, nextOffset);\n\n      // lineJoin\n      this._currentLineJoin = LOAD<LineJoin>(this._lineJoinStack, nextOffset);\n\n      // lineWidth\n      this._currentLineWidth = LOAD<f64>(this._lineWidthStack, nextOffset);\n\n      // miterLimit\n      this._currentMiterLimit = LOAD<f64>(this._miterLimitStack, nextOffset);\n\n      // shadowBlur\n      this._currentShadowBlur = LOAD<f64>(this._shadowBlurStack, nextOffset);\n\n      // shadowColor\n      this._currentShadowColor = changetype<string>(LOAD<usize>(this._shadowColorStack, nextOffset));\n\n      // shadowOffsetX\n      this._currentShadowOffsetX = LOAD<f64>(this._shadowOffsetXStack, nextOffset);\n\n      // shadowOffsetY\n      this._currentShadowOffsetY = LOAD<f64>(this._shadowOffsetYStack, nextOffset);\n\n      // strokeStyle\n      source = this._strokeStyleStack;\n      this._currentStrokeStyleType = <FillStrokeStyleType>LOAD<usize>(source, styleOffset);\n      this._currentStrokeStyleValue = LOAD<usize>(source, styleOffset + 1);\n\n      // textAlign\n      this._currentTextAlign = LOAD<TextAlign>(this._textAlignStack, nextOffset);\n\n      // textBaseline\n      this._currentTextBaseline = LOAD<TextBaseline>(this._textBaselineStack, nextOffset);\n      super._writeZero(CanvasInstruction.Restore);\n    }\n\n    this._stackOffset = <u8>nextOffset;\n  }\n  //#endregion RESTORE\n\n  //#region PATH\n  /**\n   * An internal array of path items.\n   */\n  private _path: Path2DElement[] = createPathElements();\n\n  /**\n   * The path offset is an index that always points to the next path index to be written to.\n   * Every time beginPath is called, this value should be set to 1.\n   */\n  private _pathOffset: i32 = 1;\n\n  /**\n   * The path buffer offset is an index that always points to the next path item to be written to\n   * the buffer. Every time beginPath is called, this value should be set to 0.\n   */\n  private _pathBufferOffset: i32 = 0;\n\n  /**\n   * An internal function that writes a single path item to the _path. \n   *\n   * @param {CanvasInstruction} inst - The CanvasInstruction that represents the current pathing\n   * operation that should be written to the path buffer.\n   * @param {bool} updateTransform - The bool value that determines if the PathElement should store\n   * the _currentTransform values.\n   * @param {i32} count - The number of parameters for this PathElement's instruction.\n   * @param {f64} a - The first parameter for this PathElement's instruction.\n   * @param {f64} b - The second parameter for this PathElement's instruction.\n   * @param {f64} c - The third parameter for this PathElement's instruction.\n   * @param {f64} d - The fourth parameter for this PathElement's instruction.\n   * @param {f64} e - The five parameter for this PathElement's instruction.\n   * @param {f64} f - The six parameter for this PathElement's instruction.\n   * @param {f64} g - The seven parameter for this PathElement's instruction.\n   * @param {f64} h - The eighth parameter for this PathElement's instruction.\n   */\n  @inline\n  private _writePath(\n    inst: CanvasInstruction,\n    updateTransform: bool = false,\n    count: i32 = 0,\n    a: f64 = 0.0,\n    b: f64 = 0.0,\n    c: f64 = 0.0,\n    d: f64 = 0.0,\n    e: f64 = 0.0,\n    f: f64 = 0.0,\n    g: f64 = 0.0,\n    h: f64 = 0.0,\n  ): void {\n    var el: Path2DElement = unchecked(this._path[this._pathOffset]);\n    var index: i32;\n    var current: ArrayBuffer;\n    el.instruction = inst;\n    el.updateTransform = updateTransform;\n    if (updateTransform) {\n      index = this._stackOffset * 6;\n      current = this._transformStack;\n      el.transformA = LOAD<f64>(current, index + 0);\n      el.transformB = LOAD<f64>(current, index + 1);\n      el.transformC = LOAD<f64>(current, index + 2);\n      el.transformD = LOAD<f64>(current, index + 3);\n      el.transformE = LOAD<f64>(current, index + 4);\n      el.transformF = LOAD<f64>(current, index + 5);\n    }\n    el.count = count;\n    el.a = a;\n    el.b = b;\n    el.c = c;\n    el.d = d;\n    el.e = e;\n    el.f = f;\n    el.g = g;\n    el.h = h;\n    ++this._pathOffset;\n  }\n\n  /**\n   * An internal function that writes the queued up path items to the buffer. It optionally calls\n   * setTransform if the transform was modified between path calls.\n   */\n  @inline\n  private _updatePath(): void {\n    var end: i32 = this._pathOffset;\n    var el: Path2DElement;\n    var a: f64;\n    var b: f64;\n    var c: f64;\n    var d: f64;\n    var e: f64;\n    var f: f64;\n    var current: ArrayBuffer = this._currentTransform;\n    for (var i: i32 = this._pathBufferOffset; i <= end; i++) {\n      el = unchecked(this._path[i]);\n      if (el.updateTransform) {\n        a = el.transformA;\n        b = el.transformB;\n        c = el.transformC;\n        d = el.transformD;\n        e = el.transformE;\n        f = el.transformF;\n\n        if (\n          a != LOAD<f64>(current, 0) ||\n          b != LOAD<f64>(current, 1) ||\n          c != LOAD<f64>(current, 2) ||\n          d != LOAD<f64>(current, 3) ||\n          e != LOAD<f64>(current, 4) ||\n          f != LOAD<f64>(current, 5)\n        ) {\n          super._writeSix(CanvasInstruction.SetTransform, a, b, c, d, e, f);\n          STORE<f64>(current, 0, a);\n          STORE<f64>(current, 1, b);\n          STORE<f64>(current, 2, c);\n          STORE<f64>(current, 3, d);\n          STORE<f64>(current, 4, e);\n          STORE<f64>(current, 5, f);\n        }\n        switch (el.count) {\n          case 0: {\n            super._writeZero(el.instruction);\n            break;\n          }\n          case 1: {\n            super._writeOne(el.instruction, el.a);\n            break;\n          }\n          case 2: {\n            super._writeTwo(el.instruction, el.a, el.b);\n            break;\n          }\n          case 4: {\n            super._writeFour(el.instruction, el.a, el.b, el.c, el.d);\n            break;\n          }\n          case 5: {\n            super._writeFive(el.instruction, el.a, el.b, el.c, el.d, el.e);\n            break;\n          }\n          case 6: {\n            super._writeSix(el.instruction, el.a, el.b, el.c, el.d, el.e, el.f);\n            break;\n          }\n          case 8: {\n            super._writeEight(el.instruction, el.a, el.b, el.c, el.d, el.e, el.f, el.g, el.h);\n          }\n        }\n      }\n    }\n  }\n  //#endregion PATH\n\n  //#region ARC\n  /**\n   * The CanvasRenderingContext2D.arc() method of the Canvas 2D API adds a circular arc to\n   * the current sub-path.\n   *\n   * @param {f64} x - The x-axis (horizontal) coordinate of the arc's center.\n   * @param {f64} y - The y-axis (vertical) coordinate of the arc's center.\n   * @param {f64} radius - The arc's radius. Must be non-negative.\n   * @param {f64} startAngle - The angle at which the arc starts, measured clockwise from the positive x-axis\n   * and expressed in radians.\n   * @param {f64} endAngle - The angle at which the arc ends, measured clockwise from the positive x-axis and\n   * expressed in radians.\n   * @param {bool} anticlockwise - An optional bool which, if true, causes the arc to be drawn\n   * counter-clockwise between the start and end angles. The default value is false (clockwise).\n   */\n  public arc(x: f64, y: f64, radius: f64, startAngle: f64, endAngle: f64 , anticlockwise: bool = false): void {\n    if (!isFinite(x + y + radius + startAngle + endAngle) || radius < 0) return;\n    this._writePath(CanvasInstruction.Arc, true, 6, x, y, radius, startAngle, endAngle, anticlockwise ? 1.0 : 0.0);\n  }\n  //#endregion ARC\n\n  //#region ARCTO\n  /**\n   * The CanvasRenderingContext2D.arcTo() method of the Canvas 2D API adds a circular arc to the current\n   * sub-path, using the given control points and radius. The arc is automatically connected to the\n   * path's latest point with a straight line, if necessary for the specified parameters. This method is\n   * commonly used for making rounded corners.\n   *\n   * @param {f64} x1 - The x-axis coordinate of the first control point.\n   * @param {f64} y1 - The y-axis coordinate of the first control point.\n   * @param {f64} x2 - The x-axis coordinate of the second control point.\n   * @param {f64} y2 - The y-axis coordinate of the second control point.\n   * @param {f64} radius - The arc's radius. Must be non-negative.\n   */\n  public arcTo(x1: f64, y1: f64, x2: f64, y2: f64, radius: f64): void {\n    if (!isFinite(x1 + y1 + x2 + y2 + radius) || radius < 0) return;\n    this._writePath(CanvasInstruction.ArcTo, true, 5, x1, y1, x2, y2, radius);\n  }\n  //#endregion ARCTO\n\n  //#region BEGINPATH\n  /**\n   * The CanvasRenderingContext2D.beginPath() method of the Canvas 2D API starts a new path by\n   * emptying the list of sub-paths. Call this method when you want to create a new path.\n   */\n  public beginPath(): void {\n    this._pathOffset = 1;\n    this._pathBufferOffset = 0;\n  }\n  //#endregion BEGINPATH\n\n  //#region BEZIERCURVETO\n  /**\n   * The CanvasRenderingContext2D.bezierCurveTo() method of the Canvas 2D API adds a cubic Bézier\n   * curve to the current sub-path. It requires three points: the first two are control points and\n   * the third one is the end point. The starting point is the latest point in the current path, which\n   * can be changed using moveTo() before creating the Bézier curve.\n   *\n   * @param {f64} cp1x - The x-axis coordinate of the first control point.\n   * @param {f64} cp1y - The y-axis coordinate of the first control point.\n   * @param {f64} cp2x - The x-axis coordinate of the second control point.\n   * @param {f64} cp2y - The y-axis coordinate of the second control point.\n   * @param {f64} x - The x-axis coordinate of the end point.\n   * @param {f64} y - The y-axis coordinate of the end point.\n   */\n  public bezierCurveTo(cp1x: f64, cp1y: f64, cp2x: f64, cp2y: f64, x: f64, y: f64): void {\n    if (!isFinite(cp1x + cp1y + cp2x + cp2y + x + y)) return;\n    this._writePath(CanvasInstruction.BezierCurveTo, true, 6, cp1x, cp1y, cp2x, cp2y, x, y);\n  }\n  //#endregion BEZIERCURVETO\n\n  //#region CLEARRECT\n  /**\n   * The CanvasRenderingContext2D.clearRect() method of the Canvas 2D API erases the pixels in a\n   * rectangular area by setting them to transparent black.\n   *\n   * @param {f64} x - The x-axis coordinate of the rectangle's starting point.\n   * @param {f64} y - The y-axis coordinate of the rectangle's starting point.\n   * @param {f64} width - The rectangle's width. Positive values are to the right, and negative to\n   * the left.\n   * @param {f64} height - The rectangle's height. Positive values are down, and negative are up.\n   */\n  public clearRect(x: f64, y: f64, width: f64, height: f64): void {\n    if (!isFinite(x + y + width + height)) return;\n    this._updateTransform();\n    super._writeFour(CanvasInstruction.ClearRect, x, y, width, height);\n  }\n  //#endregion CLEARRECT\n\n  //#region CLIP\n  /**\n   * The CanvasRenderingContext2D.clip() method of the Canvas 2D API turns the current or given path\n   * into the current clipping region. It replaces any previous clipping region. In the image below,\n   * the red outline represents a clipping region shaped like a star. Only those parts of the\n   * checkerboard pattern that are within the clipping region get drawn.\n   */\n  public clip(): void {\n    this._updatePath();\n    super._writeZero(CanvasInstruction.Clip);\n  }\n  //#endregion CLIP\n\n  //#region CLOSEPATH\n  /**\n   * The CanvasRenderingContext2D.closePath() method of the Canvas 2D API attempts to add a straight\n   * line from the current point to the start of the current sub-path. If the shape has already been\n   * closed or has only one point, this function does nothing. This method doesn't draw anything to\n   * the canvas directly. You can render the path using the stroke() or fill() methods.\n   */\n  public closePath(): void {\n    if (this._pathOffset == 1 || this._lastPathItem.instruction === CanvasInstruction.ClosePath) return;\n    this._writePath(CanvasInstruction.ClosePath, true, 0);\n  }\n\n  @inline\n  private get _lastPathItem(): Path2DElement {\n    return unchecked(this._path[this._pathOffset - 1]);\n  }\n  //#endregion CLOSEPATH\n\n  //#region DRAWIMAGE\n  /**\n   * The CanvasRenderingContext2D.drawImagePosition() method of the Canvas 2D API provides a simple\n   * method for drawing an image onto the canvas at a specific position.\n   *\n   * @param {Image} image - An element to draw into the context. The specification permits any canvas\n   * image source (Image).\n   * @param {f64} dx - The x-axis coordinate in the destination canvas at which to place the top-left\n   * corner of the source image.\n   * @param {f64} dy - The y-axis coordinate in the destination canvas at which to place the top-left\n   * corner of the source image.\n   */\n  public drawImage(image: Image, dx: f64, dy: f64): void {\n    if (image == null || !isFinite(dx + dy) || !image.loaded) return;\n    this._updateFilter();\n    this._updateGlobalAlpha();\n    this._updateGlobalCompositeOperation();\n    this._updateImageSmoothingEnabled();\n    this._updateImageSmoothingQuality();\n    this._updateShadowBlur();\n    this._updateShadowColor();\n    this._updateShadowOffsetX();\n    this._updateShadowOffsetY();\n    this._updateTransform();\n    this._writeNine(\n      CanvasInstruction.DrawImage,\n      <f64>getImageID(image),\n      0.0, 0.0, <f64>image.width, <f64>image.height,\n      dx, dy, <f64>image.width, <f64>image.height,\n    );\n  }\n\n  /**\n   * The CanvasRenderingContext2D.drawImageSize() method of the Canvas 2D API provides a simple\n   * method for drawing an image onto the canvas at a specific position.\n   *\n   * @param {Image} image - An element to draw into the context. The specification permits any canvas\n   * image source (Image).\n   * @param {f64} dx - The x-axis coordinate in the destination canvas at which to place the top-left\n   * corner of the source image.\n   * @param {f64} dy - The y-axis coordinate in the destination canvas at which to place the top-left\n   * corner of the source image.\n   * @param {f64} dWidth - The width to draw the image in the destination canvas. This allows scaling\n   * of the drawn image. If not specified, the image is not scaled in width when drawn.\n   * @param {f64} dHeight - The height to draw the image in the destination canvas. This allows scaling\n   * of the drawn image. If not specified, the image is not scaled in height when drawn.\n   */\n  public drawImageSize(image: Image, dx: f64, dy: f64, dWidth: f64, dHeight: f64): void {\n    if (image == null || !isFinite(dx + dy + dWidth + dHeight) || !image.loaded) return;\n    this._updateFilter();\n    this._updateGlobalAlpha();\n    this._updateGlobalCompositeOperation();\n    this._updateImageSmoothingEnabled();\n    this._updateImageSmoothingQuality();\n    this._updateShadowBlur();\n    this._updateShadowColor();\n    this._updateShadowOffsetX();\n    this._updateShadowOffsetY();\n    this._updateTransform();\n    this._writeNine(\n      CanvasInstruction.DrawImage,\n      <f64>getImageID(image),\n      0.0, 0.0, <f64>image.width, <f64>image.height,\n      dx, dy, dWidth, dHeight,\n    );\n  }\n\n  /**\n   * The CanvasRenderingContext2D.drawImageSource() method of the Canvas 2D API provides a simple\n   * method for drawing an image onto the canvas at a specific position.\n   *\n   * @param {Image} image - An element to draw into the context. The specification permits any canvas\n   * image source (Image).\n   * @param {f64} sx - The x-axis coordinate of the top left corner of the sub-rectangle of the source\n   * image to draw into the destination context.\n   * @param {f64} sy - The y-axis coordinate of the top left corner of the sub-rectangle of the source\n   * image to draw into the destination context.\n   * @param {f64} sWidth - The width of the sub-rectangle of the source image to draw into the\n   * destination context. If not specified, the entire rectangle from the coordinates specified by sx\n   * and sy to the bottom-right corner of the image is used.\n   * @param {f64} sHeight - The height of the sub-rectangle of the source image to draw into the\n   * destination context.\n   * @param {f64} dx - The x-axis coordinate in the destination canvas at which to place the top-left\n   * corner of the source image.\n   * @param {f64} dy - The y-axis coordinate in the destination canvas at which to place the top-left\n   * corner of the source image.\n   * @param {f64} dWidth - The width to draw the image in the destination canvas. This allows scaling\n   * of the drawn image. If not specified, the image is not scaled in width when drawn.\n   * @param {f64} dHeight - The height to draw the image in the destination canvas. This allows scaling\n   * of the drawn image. If not specified, the image is not scaled in height when drawn.\n   */\n  public drawImageSource(image: Image, sx: f64, sy: f64, sWidth: f64, sHeight: f64, dx: f64, dy: f64, dWidth: f64, dHeight: f64): void {\n    if (image == null || !isFinite(sx + sy + sWidth + sHeight + dx + dy + dWidth + dHeight) || !image.loaded) return;\n    this._updateFilter();\n    this._updateGlobalAlpha();\n    this._updateGlobalCompositeOperation();\n    this._updateImageSmoothingEnabled();\n    this._updateImageSmoothingQuality();\n    this._updateShadowBlur();\n    this._updateShadowColor();\n    this._updateShadowOffsetX();\n    this._updateShadowOffsetY();\n    this._updateTransform();\n    this._writeNine(\n      CanvasInstruction.DrawImage,\n      <f64>getImageID(image),\n      sx, sy, sWidth, sHeight,\n      dx, dy, dWidth, dHeight,\n    );\n  }\n  //#endregion DRAWIMAGE\n\n  //#region ELLIPSE\n  /**\n   * The CanvasRenderingContext2D.ellipse() method of the Canvas 2D API adds an elliptical arc to the current sub-path.\n   *\n   * @param {f64} x - The x-axis (horizontal) coordinate of the ellipse's center.\n   * @param {f64} y - The y-axis (vertical) coordinate of the ellipse's center.\n   * @param {f64} radiusX - The ellipse's major-axis radius. Must be non-negative.\n   * @param {f64} radiusY - The ellipse's minor-axis radius. Must be non-negative.\n   * @param {f64} rotation - The rotation of the ellipse, expressed in radians.\n   * @param {f64} startAngle - The angle at which the ellipse starts, measured clockwise from the positive x-axis\n   * and expressed in radians.\n   * @param {f64} endAngle - The angle at which the ellipse ends, measured clockwise from the positive x-axis and\n   * expressed in radians.\n   * @param {bool} anticlockwise - An optional Boolean which, if true, draws the ellipse anticlockwise\n   * (counter-clockwise). The default value is false (clockwise).\n   */\n  public ellipse(x: f64, y: f64, radiusX: f64, radiusY: f64, rotation: f64, startAngle: f64, endAngle: f64, anticlockwise: bool = false): void {\n    if (!isFinite(x + y + radiusX + radiusY + rotation + startAngle + endAngle) || radiusX < 0 || radiusY < 0) return;\n    this._writePath(\n      CanvasInstruction.Ellipse,\n      true, 8,\n      x, y, radiusX, radiusY,\n      rotation, startAngle, endAngle, anticlockwise ? 1.0 : 0.0,\n    );\n  }\n  //#endregion ELLIPSE\n\n  //#region FILL\n  /**\n   * The CanvasRenderingContext2D.fill() method of the Canvas 2D API fills the current or given path\n   * with the current fillStyle.\n   *\n   * @param {FillRule} fillRule - The algorithm by which to determine if a point is inside or\n   * outside the filling region.\n   *\n   * Possible values:\n   * - `FillRule.nonzero`: The non-zero winding rule. Default rule.\n   * - `FillRule.evenodd`: The even-odd winding rule.\n   */\n  public fill(fillRule: FillRule = FillRule.nonzero): void {\n    /**\n     * If there are no items on the path, there is no reason to fill. Index 1 means the path buffer\n     * is pointing to a single `beginPath()` operation and it does not matter if fill is called at\n     * this point.\n     */\n    if (this._pathOffset == 1) return;\n    this._updateFillStyle();\n    this._updateFilter();\n    this._updateGlobalAlpha();\n    this._updateGlobalCompositeOperation();\n    this._updateImageSmoothingEnabled();\n    this._updateImageSmoothingQuality();\n\n    /**\n     * This function must be called *before* _updateTransform(), because both the path operations and the\n     * fill operations affect the transform. Each pathing operation has it's own transform, and the\n     * transform value when the fill operation occurs might be different.\n     */\n    this._updatePath();\n    this._updateShadowBlur();\n    this._updateShadowColor();\n    this._updateShadowOffsetX();\n    this._updateShadowOffsetY();\n    this._updateTransform();\n    super._writeOne(CanvasInstruction.Fill, <f64>fillRule);\n  }\n  //#endregion FILL\n\n  //#region FILLRECT\n  /**\n   * The CanvasRenderingContext2D.fillRect() method of the Canvas 2D API draws a rectangle that is\n   * filled according to the current fillStyle. This method draws directly to the canvas without\n   * modifying the current path, so any subsequent fill() or stroke() calls will have no effect on\n   * it.\n   *\n   * @param x - The x-axis coordinate of the rectangle's starting point.\n   * @param y - The y-axis coordinate of the rectangle's starting point.\n   * @param width - The rectangle's width. Positive values are to the right, and negative to the\n   * left.\n   * @param height - The rectangle's height. Positive values are down, and negative are up.\n   */\n  public fillRect(x: f64, y: f64, width: f64, height: f64): void {\n    if (!isFinite(x + y + width + height)) return;\n    this._updateFillStyle();\n    this._updateFilter();\n    this._updateGlobalAlpha();\n    this._updateGlobalCompositeOperation();\n    this._updateImageSmoothingEnabled();\n    this._updateImageSmoothingQuality();\n    this._updateShadowBlur();\n    this._updateShadowColor();\n    this._updateShadowOffsetX();\n    this._updateShadowOffsetY();\n    this._updateTransform();\n    super._writeFour(CanvasInstruction.FillRect, x, y, width, height);\n  }\n  //#endregion FILLRECT\n\n  //#region FILLTEXT\n  /**\n   * The CanvasRenderingContext2D method fillText(), part of the Canvas 2D API, draws a text string\n   * at the specified coordinates, filling the string's characters with the current fillStyle. An\n   * optional parameter allows specifying a maximum width for the rendered text, which the user\n   * agent will achieve by condensing the text or by using a lower font size. This method draws\n   * directly to the canvas without modifying the current path, so any subsequent fill() or stroke()\n   * calls will have no effect on it. The text is rendered using the font and text layout\n   * configuration as defined by the font, textAlign, textBaseline, and direction properties.\n   *\n   * The fillText function can accept an optional maxWidth property. Use the fillTextWidth function\n   * to enable the use of that parameter.\n   *\n   * @param text - A DOMString specifying the text string to render into the context. The text is\n   * rendered using the settings specified by font, textAlign, textBaseline, and direction.\n   * @param x - The x-axis coordinate of the point at which to begin drawing the text, in pixels.\n   * @param y - The y-axis coordinate of the point at which to begin drawing the text, in pixels.\n   */\n  public fillText(text: string, x: f64, y: f64): void {\n    if (!isFinite(x + y) || text == null || text.length == 0) return;\n    this._updateDirection();\n    this._updateFillStyle();\n    this._updateFilter();\n    this._updateFont();\n    this._updateGlobalAlpha();\n    this._updateGlobalCompositeOperation();\n    this._updateImageSmoothingEnabled();\n    this._updateImageSmoothingQuality();\n    this._updateShadowBlur();\n    this._updateShadowColor();\n    this._updateShadowOffsetX();\n    this._updateShadowOffsetY();\n    this._updateTextAlign();\n    this._updateTextBaseline();\n    this._updateTransform();\n    super._writeThree(CanvasInstruction.FillText, <f64>changetype<usize>(text), x, y);\n  }\n\n  /**\n   * The CanvasRenderingContext2D method fillText(), part of the Canvas 2D API, draws a text string\n   * at the specified coordinates, filling the string's characters with the current fillStyle. An\n   * optional parameter allows specifying a maximum width for the rendered text, which the user\n   * agent will achieve by condensing the text or by using a lower font size. This method draws\n   * directly to the canvas without modifying the current path, so any subsequent fill() or stroke()\n   * calls will have no effect on it. The text is rendered using the font and text layout\n   * configuration as defined by the font, textAlign, textBaseline, and direction properties.\n   *\n   * The fillText function can accept an optional maxWidth property. Use the fillTextWidth function\n   * to enable the use of that parameter.\n   *\n   * @param text - A DOMString specifying the text string to render into the context. The text is\n   * rendered using the settings specified by font, textAlign, textBaseline, and direction.\n   * @param x - The x-axis coordinate of the point at which to begin drawing the text, in pixels.\n   * @param y - The y-axis coordinate of the point at which to begin drawing the text, in pixels.\n   * @param maxWidth - The maximum number of pixels wide the text may be once rendered. If not\n   * specified, there is no limit to the width of the text. However, if this value is provided, the\n   * user agent will adjust the kerning, select a more horizontally condensed font (if one is available or can be generated without loss of quality), or scale down to a smaller font size in order to fit the text in the specified width.\n   */\n  public fillTextWidth(text: string, x: f64, y: f64, maxWidth: f64): void {\n    if (!isFinite(x + y + maxWidth) || text == null || text.length == 0 || maxWidth < 0) return;\n    this._updateDirection();\n    this._updateFillStyle();\n    this._updateFilter();\n    this._updateFont();\n    this._updateGlobalAlpha();\n    this._updateGlobalCompositeOperation();\n    this._updateImageSmoothingEnabled();\n    this._updateImageSmoothingQuality();\n    this._updateShadowBlur();\n    this._updateShadowColor();\n    this._updateShadowOffsetX();\n    this._updateShadowOffsetY();\n    this._updateTextAlign();\n    this._updateTextBaseline();\n    this._updateTransform();\n    super._writeFour(CanvasInstruction.FillTextWidth, <f64>changetype<usize>(text), x, y, maxWidth);\n  }\n  //#endregion FILLTEXT\n\n  //#region ISPOINTINPATH\n  /**\n   * The CanvasRenderingContext2D.isPointInPath() method of the Canvas 2D API reports whether or not\n   * the specified point is contained in the current path. It forces a commit to flush all the\n   * current instructions to the buffer, updates the path, and then performs a pointInPath function\n   * call on the canvas.\n   *\n   * @param {f64} x - The x-axis coordinate of the point to check.\n   * @param {f64} y - The y-axis coordinate of the point to check.\n   * @param {FillRule} fillRule - The algorithm by which to determine if a point is inside or\n   * outside the path.\n   *\n   * Possible values:\n   * - `FillRule.nonzero`: The non-zero winding rule. Default rule.\n   * - `FillRule.evenodd`: The even-odd winding rule.\n   */\n  public isPointInPath(x: f64, y: f64, fillRule: FillRule = FillRule.nonzero): bool {\n    if (!isFinite(x + y)) return false;\n    this._updatePath();\n    this.commit();\n    return isPointInPath(this.id, x, y, fillRule);\n  }\n  //#endregion ISPOINTINPATH\n\n  //#region ISPOINTINSTROKE\n  /**\n   * The CanvasRenderingContext2D.isPointInStroke() method of the Canvas 2D API reports whether or\n   * not the specified point is inside the area contained by the stroking of a path. It forces a\n   * commit to flush all the current instructions to the buffer, updates the path, and then performs\n   * a pointInPath function call on the canvas.\n   *\n   * @param {f64} x - The x-axis coordinate of the point to check.\n   * @param {f64} y - The y-axis coordinate of the point to check.\n   */\n  public isPointInStroke(x: f64, y: f64): bool {\n    if (!isFinite(x + y)) return false;\n    this._updatePath();\n    this.commit();\n    return isPointInStroke(this.id, x, y);\n  }\n  //#endregion ISPOINTINSTROKE\n\n  //#region LINETO\n  /**\n   * The CanvasRenderingContext2D method lineTo(), part of the Canvas 2D API, adds a straight line\n   * to the current sub-path by connecting the sub-path's last point to the specified (x, y)\n   * coordinates. Like other methods that modify the current path, this method does not directly\n   * render anything. To draw the path onto a canvas, you can use the fill() or stroke() methods.\n   *\n   * @param {f64} x - The x-axis coordinate of the line's end point.\n   * @param {f64} y - The y-axis coordinate of the line's end point.\n   */\n  public lineTo(x: f64, y: f64): void {\n    if (!isFinite(x + y)) return;\n    this._writePath(CanvasInstruction.LineTo, true, 2, x, y);\n  }\n  //#endregion LINETO\n\n  //#region MEASURETEXT\n  /**\n   * The CanvasRenderingContext2D.measureText() method returns a TextMetrics object that contains\n   * information about the measured text (such as its width, for example). The as2d implementation\n   * only returns the resulting width property value.\n   *\n   * @param {string} text - The text string to measure.\n   */\n  public measureText(text: string): f64 {\n    this._updateFont();\n    this.commit();\n    return measureText(this.id, text);\n  }\n  //#endregion MEASURETEXT\n\n  //#region MOVETO\n  /**\n   * The CanvasRenderingContext2D.moveTo() method of the Canvas 2D API begins a new sub-path at the\n   * point specified by the given (x, y) coordinates.\n   *\n   * @param {f64} x - The x-axis (horizontal) coordinate of the point.\n   * @param {f64} y - The y-axis (vertical) coordinate of the point.\n   */\n  public moveTo(x: f64, y: f64): void {\n    if (!isFinite(x + y)) return;\n    this._writePath(CanvasInstruction.MoveTo, true, 2, x, y);\n  }\n  //#endregion MOVETO\n\n  //#region QUADRATICCURVETO\n  /**\n   * The CanvasRenderingContext2D.quadraticCurveTo() method of the Canvas 2D API adds a quadratic\n   * Bézier curve to the current sub-path. It requires two points: the first one is a control point\n   * and the second one is the end point. The starting point is the latest point in the current\n   * path, which can be changed using moveTo() before creating the quadratic Bézier curve.\n   *\n   * @param cpx - The x-axis coordinate of the control point.\n   * @param cpy - The y-axis coordinate of the control point.\n   * @param x - The x-axis coordinate of the end point.\n   * @param y - The y-axis coordinate of the end point.\n   */\n  public quadraticCurveTo(cpx: f64, cpy: f64, x: f64, y: f64): void {\n    if (!isFinite(cpx + cpy + x + y)) return;\n    this._writePath(CanvasInstruction.QuadraticCurveTo, true, 4, cpx, cpy, x, y);\n  }\n  //#endregion QUADRATICCURVETO\n\n  //#region RECT\n  /**\n   * The CanvasRenderingContext2D.rect() method of the Canvas 2D API adds a rectangle to the current\n   * path. Like other methods that modify the current path, this method does not directly render\n   * anything. To draw the rectangle onto a canvas, you can use the fill() or stroke() methods.\n   *\n   * @param {f64} x - The x-axis coordinate of the rectangle's starting point.\n   * @param {f64} y - The y-axis coordinate of the rectangle's starting point.\n   * @param {f64} width - The rectangle's width. Positive values are to the right, and negative to\n   * the left.\n   * @param {f64} height - The rectangle's height. Positive values are down, and negative are up.\n   */\n  public rect(x: f64, y: f64, width: f64, height: f64): void {\n    if (!isFinite(x + y + width + height)) return;\n    this._writePath(CanvasInstruction.Rect, true, 4, x, y, width, height);\n  }\n  //#endregion RECT\n\n  //#region RESETTRANSFORM\n  /**\n   * The CanvasRenderingContext2D.resetTransform() method of the Canvas 2D API resets the current\n   * transform to the identity matrix.\n   */\n  public resetTransform(): void {\n    this.setTransform(1.0, 0.0, 0.0, 1.0, 0.0, 0.0);\n  }\n  //#endregion RESETTRANSFORM\n\n  //#region ROTATE\n  /**\n   * The CanvasRenderingContext2D.rotate() method of the Canvas 2D API adds a rotation to the\n   * transformation matrix.\n   *\n   * @param {f64} angle - The rotation angle, clockwise in radians. You can use\n   * `degree * Math.PI / 180` if you want to calculate from a degree value.\n   */\n  public rotate(angle: f64): void {\n    if (!isFinite(angle)) return;\n    var index: i32 = this._stackOffset * 6;\n    var current: ArrayBuffer = this._transformStack;\n    var a: f64 = LOAD<f64>(current, index);\n    var b: f64 = LOAD<f64>(current, index + 1);\n    var c: f64 = LOAD<f64>(current, index + 2);\n    var d: f64 = LOAD<f64>(current, index + 3);\n    var cos: f64 = Math.cos(angle);\n    var sin: f64 = Math.sin(angle);\n    STORE<f64>(current, index, a * cos + c * sin);\n    STORE<f64>(current, index + 1, b * cos + d * sin);\n    STORE<f64>(current, index + 2, c * cos - a * sin);\n    STORE<f64>(current, index + 3, d * cos - b * sin);\n  }\n  //#endregion ROTATE\n\n  //#region SCALE\n  /**\n   * The CanvasRenderingContext2D.scale() method of the Canvas 2D API adds a scaling transformation\n   * to the canvas units horizontally and/or vertically. By default, one unit on the canvas is\n   * exactly one pixel. A scaling transformation modifies this behavior. For instance, a scaling\n   * factor of 0.5 results in a unit size of 0.5 pixels; shapes are thus drawn at half the normal\n   * size. Similarly, a scaling factor of 2.0 increases the unit size so that one unit becomes two\n   * pixels; shapes are thus drawn at twice the normal size.\n   *\n   * @param {f64} x - Scaling factor in the horizontal direction. A negative value flips pixels\n   * across the vertical axis. A value of 1 results in no horizontal scaling.\n   * @param {f64} y - Scaling factor in the vertical direction. A negative value flips pixels across\n   * the horizontal axis. A value of 1 results in no vertical scaling.\n   */\n  public scale(x: f64, y: f64): void {\n    if (!isFinite(x + y)) return;\n    var index: i32 = this._stackOffset * 6;\n    var current: ArrayBuffer = this._transformStack;\n    STORE<f64>(current, index, LOAD<f64>(current, index) * x);\n    STORE<f64>(current, index + 1, LOAD<f64>(current, index + 1) * x);\n    STORE<f64>(current, index + 2, LOAD<f64>(current, index + 2) * y);\n    STORE<f64>(current, index + 3, LOAD<f64>(current, index + 3) * y);\n  }\n  //#endregion SCALE\n\n  //#region SETTRANSFORM\n  /**\n   * The CanvasRenderingContext2D.setTransform() method of the Canvas 2D API resets (overrides) the\n   * current transformation to the identity matrix, and then invokes a transformation described by\n   * the arguments of this method. This lets you scale, rotate, translate (move), and skew the\n   * context.\n   *\n   * @param {f64} a - Horizontal scaling. A value of 1 results in no scaling.\n   * @param {f64} b - Vertical skewing.\n   * @param {f64} c - Horizontal skewing.\n   * @param {f64} d - Vertical scaling. A value of 1 results in no scaling.\n   * @param {f64} e - Horizontal translation (moving).\n   * @param {f64} f - Vertical translation (moving).\n   */\n  public setTransform(a: f64, b: f64, c: f64, d: f64, e: f64, f: f64): void {\n    if (!isFinite(a + b + c + d + e + f)) return ;\n    var index: i32 = this._stackOffset * 6;\n    var current: ArrayBuffer = this._transformStack;\n    STORE<f64>(current, index, a);\n    STORE<f64>(current, index + 1, b);\n    STORE<f64>(current, index + 2, c);\n    STORE<f64>(current, index + 3, d);\n    STORE<f64>(current, index + 4, e);\n    STORE<f64>(current, index + 5, f);\n  }\n  //#endregion SETTRANSFORM\n\n  //#region STROKE\n  /**\n   * The CanvasRenderingContext2D.stroke() method of the Canvas 2D API strokes (outlines) the\n   * current or given path with the current stroke style. Strokes are aligned to the center of a\n   * path; in other words, half of the stroke is drawn on the inner side, and half on the outer\n   * side. The stroke is drawn using the non-zero winding rule, which means that path intersections\n   * will still get filled.\n   */\n  public stroke(): void {\n    /**\n     * If there are no items on the path, there is no reason to fill. Index 1 means the path buffer\n     * is pointing to a single `beginPath()` operation and it does not matter if fill is called at\n     * this point.\n     */\n    if (this._pathOffset == 1) return;\n    /**\n     * If the lineWidth is zero, there is no line and it does not matter if ctx.stroke() is called.\n     */\n    if (LOAD<f64>(this._lineWidthStack, this._stackOffset) <= 0.0) return;\n    this._updateFilter();\n    this._updateGlobalAlpha();\n    this._updateGlobalCompositeOperation();\n    this._updateImageSmoothingEnabled();\n    this._updateImageSmoothingQuality();\n    this._updateLineCap();\n    this._updateLineDash();\n    this._updateLineDashOffset();\n    this._updateLineJoin();\n    this._updateLineWidth();\n    this._updateMiterLimit();\n    this._updatePath();\n    this._updateShadowBlur();\n    this._updateShadowColor();\n    this._updateShadowOffsetX();\n    this._updateShadowOffsetY();\n    this._updateStrokeStyle();\n    this._updateTransform();\n    super._writeZero(CanvasInstruction.Stroke);\n  }\n  //#endregion STROKE\n\n  //#region STROKERECT\n  /**\n   * The CanvasRenderingContext2D.strokeRect() method of the Canvas 2D API draws a rectangle that is\n   * stroked (outlined) according to the current strokeStyle and other context settings. This method\n   * draws directly to the canvas without modifying the current path, so any subsequent fill() or\n   * stroke() calls will have no effect on it.\n   *\n   * @param {f64} x - The x-axis coordinate of the rectangle's starting point.\n   * @param {f64} y - The y-axis coordinate of the rectangle's starting point.\n   * @param {f64} width - The rectangle's width. Positive values are to the right, and negative to\n   * the left.\n   * @param {f64} height - The rectangle's height. Positive values are down, and negative are up.\n   */\n  public strokeRect(x: f64, y: f64, width: f64, height: f64): void {\n    /**\n     * If the lineWidth is zero, there is no line and it does not matter if ctx.stroke() is called.\n     */\n    if (LOAD<f64>(this._lineWidthStack, this._stackOffset) <= 0.0) return;\n    this._updateFilter();\n    this._updateGlobalAlpha();\n    this._updateGlobalCompositeOperation();\n    this._updateImageSmoothingEnabled();\n    this._updateImageSmoothingQuality();\n    this._updateLineCap();\n    this._updateLineDash();\n    this._updateLineDashOffset();\n    this._updateLineJoin();\n    this._updateLineWidth();\n    this._updateMiterLimit();\n    this._updateShadowBlur();\n    this._updateShadowColor();\n    this._updateShadowOffsetX();\n    this._updateShadowOffsetY();\n    this._updateStrokeStyle();\n    this._updateTransform();\n    super._writeFour(CanvasInstruction.StrokeRect, x, y, width, height);\n  }\n  //#endregion STROKERECT\n\n  //#region STROKETEXT\n  /**\n   * The CanvasRenderingContext2D method strokeText(), part of the Canvas 2D API, strokes — that is,\n   * draws the outlines of — the characters of a text string at the specified coordinates. An\n   * optional parameter allows specifying a maximum width for the rendered text, which the user\n   * agent will achieve by condensing the text or by using a lower font size. This method draws\n   * directly to the canvas without modifying the current path, so any subsequent fill() or stroke()\n   * calls will have no effect on it. To use the maxWidth parameter, use the strokeTextWidth\n   * function.\n   *\n   * @param {string} text - A DOMString specifying the text string to render into the context. The\n   * text is rendered using the settings specified by font, textAlign, textBaseline, and direction.\n   * @param {f64} x - The x-axis coordinate of the point at which to begin drawing the text.\n   * @param {f64} y - The y-axis coordinate of the point at which to begin drawing the text.\n   */\n  public strokeText(text: string, x: f64, y: f64): void {\n    this._updateDirection();\n    this._updateFilter();\n    this._updateFont();\n    this._updateGlobalAlpha();\n    this._updateGlobalCompositeOperation();\n    this._updateImageSmoothingEnabled();\n    this._updateImageSmoothingQuality();\n    this._updateLineCap();\n    this._updateLineDash();\n    this._updateLineDashOffset();\n    this._updateLineJoin();\n    this._updateLineWidth();\n    this._updateMiterLimit();\n    this._updateShadowBlur();\n    this._updateShadowColor();\n    this._updateShadowOffsetX();\n    this._updateShadowOffsetY();\n    this._updateStrokeStyle();\n    this._updateTextAlign();\n    this._updateTextBaseline();\n    this._updateTransform();\n    super._writeThree(CanvasInstruction.StrokeText, <f64>changetype<usize>(text), x, y)\n  }\n\n  /**\n   * The CanvasRenderingContext2D method strokeTextWidth(), part of the Canvas 2D API, strokes —\n   * that is, draws the outlines of — the characters of a text string at the specified coordinates.\n   * An optional parameter allows specifying a maximum width for the rendered text, which the user\n   * agent will achieve by condensing the text or by using a lower font size. This method draws\n   * directly to the canvas without modifying the current path, so any subsequent fill() or stroke()\n   * calls will have no effect on it. To use the maxWidth parameter, use the strokeTextWidth\n   * function.\n   *\n   * @param {string} text - A DOMString specifying the text string to render into the context. The\n   * text is rendered using the settings specified by font, textAlign, textBaseline, and direction.\n   * @param {f64} x - The x-axis coordinate of the point at which to begin drawing the text.\n   * @param {f64} y - The y-axis coordinate of the point at which to begin drawing the text.\n   * @param {f64} maxWidth - The maximum width the text may be once rendered. If not specified,\n   * there is no limit to the width of the text. However, if this value is provided, the user agent\n   * will adjust the kerning, select a more horizontally condensed font (if one is available or can\n   * be generated without loss of quality), or scale down to a smaller font size in order to fit the\n   * text in the specified width.\n   */\n  public strokeTextWidth(text: string, x: f64, y: f64, maxWidth: f64): void {\n    this._updateDirection();\n    this._updateFilter();\n    this._updateFont();\n    this._updateGlobalAlpha();\n    this._updateGlobalCompositeOperation();\n    this._updateImageSmoothingEnabled();\n    this._updateImageSmoothingQuality();\n    this._updateLineCap();\n    this._updateLineDash();\n    this._updateLineDashOffset();\n    this._updateLineJoin();\n    this._updateLineWidth();\n    this._updateMiterLimit();\n    this._updateShadowBlur();\n    this._updateShadowColor();\n    this._updateShadowOffsetX();\n    this._updateShadowOffsetY();\n    this._updateStrokeStyle();\n    this._updateTextAlign();\n    this._updateTextBaseline();\n    this._updateTransform();\n    super._writeFour(CanvasInstruction.StrokeTextWidth, <f64>changetype<usize>(text), x, y, maxWidth);\n  }\n  //#endregion STROKETEXT\n\n  //#region TRANSFORM\n  /**\n   * The CanvasRenderingContext2D.transform() method of the Canvas 2D API multiplies the current\n   * transformation with the matrix described by the arguments of this method. This lets you scale,\n   * rotate, translate (move), and skew the context.\n   *\n   * @param {f64} a - Horizontal scaling. A value of 1 results in no scaling.\n   * @param {f64} b - Vertical skewing.\n   * @param {f64} c - Horizontal skewing.\n   * @param {f64} d - Vertical scaling. A value of 1 results in no scaling.\n   * @param {f64} e - Horizontal translation (moving).\n   * @param {f64} f - Vertical translation (moving).\n   */\n  public transform(a: f64, b: f64, c: f64, d: f64, e: f64, f: f64): void {\n    if (!isFinite(a + b + c + d + e + f)) return;\n    var current: ArrayBuffer = this._transformStack;\n    var index: i32 = this._stackOffset * 6;\n    var sa: f64 = LOAD<f64>(current, index);\n    var sb: f64 = LOAD<f64>(current, index + 1);\n    var sc: f64 = LOAD<f64>(current, index + 2);\n    var sd: f64 = LOAD<f64>(current, index + 3);\n    var se: f64 = LOAD<f64>(current, index + 4);\n    var sf: f64 = LOAD<f64>(current, index + 5);\n\n    STORE<f64>(current, index, sa * a + sc * b);\n    STORE<f64>(current, index + 1, sb * a + sd * b);\n    STORE<f64>(current, index + 2, sa * c + sc * d);\n    STORE<f64>(current, index + 3, sb * c + sd * d);\n    STORE<f64>(current, index + 4, sa * e + sc * f + se);\n    STORE<f64>(current, index + 5, sb * e + sd * f + sf);\n  }\n  //#endregion TRANSFORM\n\n  //#region TRANSLATE\n  /**\n   * The CanvasRenderingContext2D.translate() method of the Canvas 2D API adds a translation\n   * transformation to the current matrix.\n   * @param {f64} x - Distance to move in the horizontal direction. Positive values are to the\n   * right, and negative to the left.\n   * @param {f64} y - Distance to move in the vertical direction. Positive values are down, and\n   * negative are up.\n   */\n  public translate(x: f64, y: f64): void {\n    if (!isFinite(x + y)) return;\n\n    var current: ArrayBuffer = this._transformStack;\n    var index: i32 = this._stackOffset * 6;\n\n    // e = e + a * x + c * y;\n    STORE<f64>(\n      current,\n      index + 4,\n      LOAD<f64>(current, index + 4) + LOAD<f64>(current, index) * x + LOAD<f64>(current, index + 2) * y,\n    );\n\n    // f = f + b * x + d * y;\n    STORE<f64>(\n      current,\n      index + 5,\n      LOAD<f64>(current, index + 5) + LOAD<f64>(current, index + 1) * x + LOAD<f64>(current, index + 3) * y,\n    );\n  }\n  //#endregion TRANSLATE\n\n  public commit(): void {\n    super._writeZero(CanvasInstruction.Commit);\n    render(this.id, this._buffer.data);\n    super._resetBuffer();\n  }\n}\n",
    "import { MAX_SIZE_32 } from \"./allocator\";\nimport { String } from \"../string\";\n\n/** Size of a String header. */\n@inline export const HEADER_SIZE = (offsetof<String>() + 1) & ~1; // 2 byte aligned\n/** Maximum length of a String. */\n@inline export const MAX_LENGTH = (<i32>MAX_SIZE_32 - HEADER_SIZE) >>> 1;\n\n// Low-level utility\n\nfunction __gc(ref: usize): void {}\n\nexport function allocateUnsafe(length: i32): String {\n  assert(length > 0 && length <= MAX_LENGTH);\n  var buffer: usize;\n  if (isManaged<String>()) {\n    buffer = __gc_allocate(HEADER_SIZE + (<usize>length << 1), __gc);  // tslint:disable-line\n  } else {\n    buffer = memory.allocate(HEADER_SIZE + (<usize>length << 1));\n  }\n  store<i32>(buffer, length);\n  return changetype<String>(buffer);\n}\n\n@inline\nexport function freeUnsafe(buffer: String): void {\n  if (!isManaged<String>()) {\n    assert(buffer);\n    memory.free(changetype<usize>(buffer));\n  }\n}\n\nexport function copyUnsafe(dest: String, destOffset: usize, src: String, srcOffset: usize, len: usize): void {\n  memory.copy(\n    changetype<usize>(dest) + (destOffset << 1) + HEADER_SIZE,\n    changetype<usize>(src)  + (srcOffset  << 1) + HEADER_SIZE,\n    len << 1\n  );\n}\n\nexport function compareUnsafe(str1: String, offset1: usize, str2: String, offset2: usize, len: usize): i32 {\n  var cmp: i32 = 0;\n  var ptr1 = changetype<usize>(str1) + (offset1 << 1);\n  var ptr2 = changetype<usize>(str2) + (offset2 << 1);\n  while (len && !(cmp = <i32>load<u16>(ptr1, HEADER_SIZE) - <i32>load<u16>(ptr2, HEADER_SIZE))) {\n    --len, ptr1 += 2, ptr2 += 2;\n  }\n  return cmp;\n}\n\nexport function repeatUnsafe(dest: String, destOffset: usize, src: String, count: i32): void {\n  var length = src.length;\n  if (ASC_SHRINK_LEVEL > 1) {\n    let strLen = length << 1;\n    let to   = changetype<usize>(dest) + HEADER_SIZE + (destOffset << 1);\n    let from = changetype<usize>(src)  + HEADER_SIZE;\n    for (let i = 0, len = strLen * count; i < len; i += strLen) {\n      memory.copy(to + i, from, strLen);\n    }\n  } else {\n    switch (length) {\n      case 0: break;\n      case 1: {\n        let cc =  load<u16>(changetype<usize>(src), HEADER_SIZE);\n        let out = changetype<usize>(dest) + (destOffset << 1);\n        for (let i = 0; i < count; ++i) {\n          store<u16>(out + (i << 1), cc, HEADER_SIZE);\n        }\n        break;\n      }\n      case 2: {\n        let cc  = load<u32>(changetype<usize>(src), HEADER_SIZE);\n        let out = changetype<usize>(dest) + (destOffset << 1);\n        for (let i = 0; i < count; ++i) {\n          store<u32>(out + (i << 2), cc, HEADER_SIZE);\n        }\n        break;\n      }\n      case 3: {\n        let cc1 = load<u32>(changetype<usize>(src), HEADER_SIZE + 0);\n        let cc2 = load<u16>(changetype<usize>(src), HEADER_SIZE + 4);\n        let out = changetype<usize>(dest) + (destOffset << 1);\n        for (let i = 0; i < count; ++i) {\n          store<u32>(out + (i << 2), cc1, HEADER_SIZE + 0);\n          store<u16>(out + (i << 1), cc2, HEADER_SIZE + 4);\n        }\n        break;\n      }\n      case 4: {\n        let cc = load<u64>(changetype<usize>(src), HEADER_SIZE);\n        let out = changetype<usize>(dest) + (destOffset << 1);\n        for (let i = 0; i < count; ++i) {\n          store<u64>(out + (i << 3), cc, HEADER_SIZE);\n        }\n        break;\n      }\n      default: {\n        let strLen = length << 1;\n        let to   = changetype<usize>(dest) + HEADER_SIZE + (destOffset << 1);\n        let from = changetype<usize>(src)  + HEADER_SIZE;\n        for (let i = 0, len = strLen * count; i < len; i += strLen) {\n          memory.copy(to + i, from, strLen);\n        }\n        break;\n      }\n    }\n  }\n}\n\n// Helpers\n\n@inline export const enum CharCode {\n  PLUS = 0x2B,\n  MINUS = 0x2D,\n  DOT = 0x2E,\n  _0 = 0x30,\n  _1 = 0x31,\n  _2 = 0x32,\n  _3 = 0x33,\n  _4 = 0x34,\n  _5 = 0x35,\n  _6 = 0x36,\n  _7 = 0x37,\n  _8 = 0x38,\n  _9 = 0x39,\n  A = 0x41,\n  B = 0x42,\n  E = 0x45,\n  N = 0x4E,\n  O = 0x4F,\n  X = 0x58,\n  Z = 0x5a,\n  a = 0x61,\n  b = 0x62,\n  e = 0x65,\n  n = 0x6E,\n  o = 0x6F,\n  x = 0x78,\n  z = 0x7A\n}\n\nexport function isWhiteSpaceOrLineTerminator(c: u16): bool {\n  switch (c) {\n    case 9:    // <TAB>\n    case 10:   // <LF>\n    case 13:   // <CR>\n    case 11:   // <VT>\n    case 12:   // <FF>\n    case 32:   // <SP>\n    case 160:  // <NBSP>\n    case 8232: // <LS>\n    case 8233: // <PS>\n    case 65279: return true; // <ZWNBSP>\n    default: return false;\n  }\n}\n\n/** Parses a string to an integer (usually), using the specified radix. */\nexport function parse<T>(str: String, radix: i32 = 0): T {\n  var len: i32 = str.length;\n  if (!len) return <T>NaN;\n\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  var code = <i32>load<u16>(ptr, HEADER_SIZE);\n\n  // determine sign\n  var sign: T;\n  if (code == CharCode.MINUS) {\n    if (!--len) return <T>NaN;\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return <T>NaN;\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\n    sign = 1;\n  } else {\n    sign = 1;\n  }\n\n  // determine radix\n  if (!radix) {\n    if (code == CharCode._0 && len > 2) {\n      switch (<i32>load<u16>(ptr + 2, HEADER_SIZE)) {\n        case CharCode.B:\n        case CharCode.b: {\n          ptr += 4; len -= 2;\n          radix = 2;\n          break;\n        }\n        case CharCode.O:\n        case CharCode.o: {\n          ptr += 4; len -= 2;\n          radix = 8;\n          break;\n        }\n        case CharCode.X:\n        case CharCode.x: {\n          ptr += 4; len -= 2;\n          radix = 16;\n          break;\n        }\n        default: radix = 10;\n      }\n    } else radix = 10;\n  } else if (radix < 2 || radix > 36) {\n    return <T>NaN;\n  }\n\n  // calculate value\n  var num: T = 0;\n  while (len--) {\n    code = <i32>load<u16>(ptr, HEADER_SIZE);\n    if (code >= CharCode._0 && code <= CharCode._9) {\n      code -= CharCode._0;\n    } else if (code >= CharCode.A && code <= CharCode.Z) {\n      code -= CharCode.A - 10;\n    } else if (code >= CharCode.a && code <= CharCode.z) {\n      code -= CharCode.a - 10;\n    } else break;\n    if (code >= radix) break;\n    num = (num * radix) + code;\n    ptr += 2;\n  }\n  return sign * num;\n}\n",
    "import {\n  HEADER_SIZE as AB_HEADER_SIZE,\n  MAX_BLENGTH as AB_MAX_BLENGTH,\n  allocateUnsafe,\n  LOAD,\n  STORE\n} from \"./arraybuffer\";\n\nimport {\n  SORT as SORT_IMPL\n} from \"./sort\";\n\n/** Typed array base class. Not a global object. */\nexport abstract class TypedArray<T> {\n  [key: number]: T; // compatibility only\n\n  readonly buffer: ArrayBuffer;\n  readonly byteOffset: i32;\n  readonly byteLength: i32;\n\n  constructor(length: i32) {\n    const MAX_LENGTH = <u32>AB_MAX_BLENGTH / sizeof<T>();\n    if (<u32>length > MAX_LENGTH) throw new RangeError(\"Invalid typed array length\");\n    var byteLength = length << alignof<T>();\n    var buffer = allocateUnsafe(byteLength);\n    memory.fill(changetype<usize>(buffer) + AB_HEADER_SIZE, 0, <usize>byteLength);\n    this.buffer = buffer;\n    this.byteOffset = 0;\n    this.byteLength = byteLength;\n  }\n\n  @inline\n  get length(): i32 {\n    return this.byteLength >>> alignof<T>();\n  }\n\n  @operator(\"[]\")\n  protected __get(index: i32): T {\n    if (<u32>index >= <u32>(this.byteLength >>> alignof<T>())) throw new Error(\"Index out of bounds\");\n    return LOAD<T>(this.buffer, index, this.byteOffset);\n  }\n\n  @inline @operator(\"{}\")\n  protected __unchecked_get(index: i32): T {\n    return LOAD<T>(this.buffer, index, this.byteOffset);\n  }\n\n  @operator(\"[]=\")\n  protected __set(index: i32, value: native<T>): void {\n    if (<u32>index >= <u32>(this.byteLength >>> alignof<T>())) throw new Error(\"Index out of bounds\");\n    STORE<T,native<T>>(this.buffer, index, value, this.byteOffset);\n  }\n\n  @inline @operator(\"{}=\")\n  protected __unchecked_set(index: i32, value: native<T>): void {\n    STORE<T,native<T>>(this.buffer, index, value, this.byteOffset);\n  }\n\n  // copyWithin(target: i32, start: i32, end: i32 = this.length): this\n}\n\n@inline\nexport function FILL<TArray extends TypedArray<T>, T extends number>(\n  array: TArray,\n  value: native<T>,\n  start: i32,\n  end: i32\n): TArray {\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  var len = array.length;\n  start = start < 0 ? max(len + start, 0) : min(start, len);\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n  if (sizeof<T>() == 1) {\n    if (start < end) {\n      memory.fill(\n        changetype<usize>(buffer) + start + byteOffset + AB_HEADER_SIZE,\n        <u8>value,\n        <usize>(end - start)\n      );\n    }\n  } else {\n    for (; start < end; ++start) {\n      STORE<T,native<T>>(buffer, start, value, byteOffset);\n    }\n  }\n  return array;\n}\n\n@inline\nexport function SORT<TArray extends TypedArray<T>, T>(\n  array: TArray,\n  comparator: (a: T, b: T) => i32\n): TArray {\n  var byteOffset = array.byteOffset;\n  var length = array.length;\n  if (length <= 1) return array;\n  var buffer = array.buffer;\n  if (length == 2) {\n    let a = LOAD<T>(buffer, 1, byteOffset);\n    let b = LOAD<T>(buffer, 0, byteOffset);\n    if (comparator(a, b) < 0) {\n      STORE<T>(buffer, 1, b, byteOffset);\n      STORE<T>(buffer, 0, a, byteOffset);\n    }\n    return array;\n  }\n  SORT_IMPL<T>(buffer, byteOffset, length, comparator);\n  return array;\n}\n\n@inline\nexport function SUBARRAY<TArray extends TypedArray<T>, T>(\n  array: TArray,\n  begin: i32,\n  end: i32\n): TArray {\n  var length = <i32>array.length;\n  if (begin < 0) begin = max(length + begin, 0);\n  else begin = min(begin, length);\n  if (end < 0) end = max(length + end, begin);\n  else end = max(min(end, length), begin);\n  var slice = memory.allocate(offsetof<TArray>());\n  store<usize>(slice, array.buffer, offsetof<TArray>(\"buffer\"));\n  store<i32>(slice, <i32>array.byteOffset + (begin << alignof<T>()), offsetof<TArray>(\"byteOffset\"));\n  store<i32>(slice, (end - begin) << alignof<T>(), offsetof<TArray>(\"byteLength\"));\n  return changetype<TArray>(slice);\n}\n\n@inline\nexport function REDUCE<TArray extends TypedArray<T>, T, TRet>(\n  array: TArray,\n  callbackfn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  var length = array.length;\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  for (let i = 0; i < length; i++) {\n    initialValue = callbackfn(\n      initialValue,\n      LOAD<T>(buffer, i, byteOffset),\n      i,\n      array,\n    );\n  }\n  return initialValue;\n}\n\n@inline\nexport function REDUCE_RIGHT<TArray extends TypedArray<T>, T, TRet>(\n  array: TArray,\n  callbackfn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  for (let i = array.length - 1; i >= 0; i--) {\n    initialValue = callbackfn(\n      initialValue,\n      LOAD<T>(buffer, i, byteOffset),\n      i,\n      array,\n    );\n  }\n  return initialValue;\n}\n\n@inline\nexport function MAP<TArray extends TypedArray<T>, T>(\n  array: TArray,\n  callbackfn: (value: T, index: i32, self: TArray) => T,\n): TArray {\n  var length = array.length;\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  var result = instantiate<TArray>(length);\n  var resultBuffer = result.buffer;\n  for (let i = 0; i < length; i++) {\n    STORE<T, native<T>>(resultBuffer, i, <native<T>>callbackfn(LOAD<T>(buffer, i, byteOffset), i, array));\n  }\n\n  return result;\n}\n\n@inline\nexport function FIND_INDEX<TArray extends TypedArray<T>, T>(\n  array: TArray,\n  callbackfn: (value: T, index: i32, array: TArray) => bool,\n): i32 {\n  var length = array.length;\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  for (let i = 0; i < length; i++) {\n    if (callbackfn(LOAD<T>(buffer, i, byteOffset), i, array)) {\n      return i;\n    }\n  }\n  return -1;\n}\n\n@inline\nexport function SOME<TArray extends TypedArray<T>, T>(\n  array: TArray,\n  callbackfn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  var length = array.length;\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  for (let i = 0; i < length; i++) {\n    if (callbackfn(LOAD<T>(buffer, i, byteOffset), i, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n@inline\nexport function EVERY<TArray extends TypedArray<T>, T>(\n  array: TArray,\n  callbackfn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  var length = array.length;\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  for (let i = 0; i < length; i++) {\n    if (callbackfn(LOAD<T>(buffer, i, byteOffset), i, array)) {\n      continue;\n    }\n    return false;\n  }\n  return true;\n}\n\n@inline\nexport function FOREACH<TArray extends TypedArray<T>, T>(\n  array: TArray,\n  callbackfn: (value: T, index: i32, array: TArray) => void,\n): void {\n  var length = array.length;\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n  for (let i = 0; i < length; i++) {\n    callbackfn(LOAD<T>(buffer, i, byteOffset), i, array);\n  }\n}\n\n@inline\nexport function REVERSE<TArray extends TypedArray<T>, T>(array: TArray): TArray {\n  var buffer = array.buffer;\n  var byteOffset = array.byteOffset;\n\n  for (let front = 0, back = array.length - 1; front < back; ++front, --back) {\n    let temp = LOAD<T>(buffer, front, byteOffset);\n    STORE<T>(buffer, front, LOAD<T>(buffer, back, byteOffset), byteOffset);\n    STORE<T>(buffer, back, temp, byteOffset);\n  }\n  return array;\n}\n",
    "import { memcmp, memmove, memset } from \"./internal/memory\";\n\n@builtin export declare const HEAP_BASE: usize; // tslint:disable-line\n\n/* tslint:disable */\n\nexport namespace memory {\n\n  @builtin export declare function size(): i32;\n\n  @builtin export declare function grow(pages: i32): i32;\n\n  @builtin @inline\n  export function fill(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\n    memset(dest, c, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  @builtin @inline\n  export function copy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\n    memmove(dest, src, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  @inline export function compare(vl: usize, vr: usize, n: usize): i32 { // see: musl/src/string/memcmp.c\n    return memcmp(vl, vr, n);\n  }\n\n  // Passive segments\n\n  // export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\n  //   __memory_init(segmentIndex, srcOffset, dstOffset);\n  // }\n\n  // export function drop(segmentIndex: u32): void {\n  //   __memory_drop(segmentIndex);\n  // }\n\n  // Allocator\n\n  @inline export function allocate(size: usize): usize {\n    if (isDefined(__memory_allocate)) return __memory_allocate(size);\n    WARNING(\"Calling 'memory.allocate' requires a memory manager to be present.\");\n    return <usize>unreachable();\n  }\n\n  @inline export function free(ptr: usize): void {\n    if (isDefined(__memory_free)) { __memory_free(ptr); return; }\n    WARNING(\"Calling 'memory.free' requires a memory manager to be present.\");\n    unreachable();\n  }\n\n  @inline export function reset(): void {\n    if (isDefined(__memory_reset)) { __memory_reset(); return; }\n    unreachable();\n  }\n}\n",
    "/**\n * Two-Level Segregate Fit Memory Allocator.\n *\n * A general purpose dynamic memory allocator specifically designed to meet real-time requirements.\n * Always aligns to 8 bytes.\n *\n * @module std/assembly/allocator/tlsf\n *//***/\n\n// ╒══════════════ Block size interpretation (32-bit) ═════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┴─┴─┴─┴─╫─┴─┴─┤\n// │ |                    FL                       │ SB = SL + AL  │ ◄─ usize\n// └───────────────────────────────────────────────┴─────────╨─────┘\n// FL: first level, SL: second level, AL: alignment, SB: small block\n\nimport {\n  AL_BITS,\n  AL_SIZE,\n  AL_MASK\n} from \"../internal/allocator\";\n\nconst SL_BITS: u32 = 5;\nconst SL_SIZE: usize = 1 << <usize>SL_BITS;\n\nconst SB_BITS: usize = <usize>(SL_BITS + AL_BITS);\nconst SB_SIZE: usize = 1 << <usize>SB_BITS;\n\nconst FL_BITS: u32 = (sizeof<usize>() == sizeof<u32>()\n  ? 30 // ^= up to 1GB per block\n  : 32 // ^= up to 4GB per block\n) - SB_BITS;\n\n// ╒════════════════ Block structure layout (32-bit) ══════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┼─┤\n// │                          size                             │L│F│ ◄─┐ info\n// ╞═══════════════════════════════════════════════════════════╧═╧═╡   │      ┐\n// │                        if free: ◄ prev                        │ ◄─┤ usize\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                        if free: next ►                        │ ◄─┤\n// ├───────────────────────────────────────────────────────────────┤   │\n// │                ... unused free space >= 0 ...                 │   │    = 0\n// ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤   │\n// │                        if free: jump ▲                        │ ◄─┘\n// └───────────────────────────────────────────────────────────────┘ MIN SIZE ┘\n// F: FREE, L: LEFT_FREE\n\n/** Tag indicating that this block is free. */\nconst FREE: usize = 1 << 0;\n/** Tag indicating that this block's left block is free. */\nconst LEFT_FREE: usize = 1 << 1;\n/** Mask to obtain all tags. */\nconst TAGS: usize = FREE | LEFT_FREE;\n\n/** Block structure. */\n@unmanaged\nclass Block {\n\n  /** Info field holding this block's size and tags. */\n  info: usize;\n\n  /** End offset of the {@link Block#info} field. User data starts here. */\n  static readonly INFO: usize = (sizeof<usize>() + AL_MASK) & ~AL_MASK;\n\n  /** Previous free block, if any. Only valid if free. */\n  prev: Block | null;\n  /** Next free block, if any. Only valid if free. */\n  next: Block | null;\n\n  /** Minimum size of a block, excluding {@link Block#info}. */\n  static readonly MIN_SIZE: usize = (3 * sizeof<usize>() + AL_MASK) & ~AL_MASK;// prev + next + jump\n\n  /** Maximum size of a used block, excluding {@link Block#info}. */\n  static readonly MAX_SIZE: usize = 1 << (FL_BITS + SB_BITS);\n\n  /** Gets this block's left (free) block in memory. */\n  get left(): Block {\n    assert(this.info & LEFT_FREE); // must be free to contain a jump\n    return assert(\n      load<Block>(changetype<usize>(this) - sizeof<usize>())\n    ); // can't be null\n  }\n\n  /** Gets this block's right block in memory. */\n  get right(): Block {\n    assert(this.info & ~TAGS); // can't skip beyond the tail block\n    return assert(\n      changetype<Block>(\n        changetype<usize>(this) + Block.INFO + (this.info & ~TAGS)\n      )\n    ); // can't be null\n  }\n}\n\n// ╒════════════════ Root structure layout (32-bit) ═══════════════╕\n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤          ┐\n// │        0        |           flMap                            S│ ◄────┐\n// ╞═══════════════════════════════════════════════════════════════╡      │\n// │                           slMap[0] S                          │ ◄─┐  │\n// ├───────────────────────────────────────────────────────────────┤   │  │\n// │                           slMap[1]                            │ ◄─┤  │\n// ├───────────────────────────────────────────────────────────────┤  u32 │\n// │                              ...                              │ ◄─┤  │\n// ├───────────────────────────────────────────────────────────────┤   │  │\n// │                           slMap[22] P                         │ ◄─┘  │\n// ╞═══════════════════════════════════════════════════════════════╡    usize\n// │                            head[0]                            │ ◄────┤\n// ├───────────────────────────────────────────────────────────────┤      │\n// │                              ...                              │ ◄────┤\n// ├───────────────────────────────────────────────────────────────┤      │\n// │                           head[736]                           │ ◄────┤\n// ╞═══════════════════════════════════════════════════════════════╡      │\n// │                            tailRef                            │ ◄────┘\n// └───────────────────────────────────────────────────────────────┘   SIZE   ┘\n// S: Small blocks map, P: Possibly padded if 64-bit\n\nassert((1 << SL_BITS) <= 32); // second level must fit into 32 bits\n\n/** Root structure. */\n@unmanaged\nclass Root {\n\n  /** First level bitmap. */\n  flMap: usize = 0;\n\n  /** Start offset of second level maps. */\n  private static readonly SL_START: usize = sizeof<usize>();\n\n  // Using *one* SL map per *FL bit*\n\n  /** Gets the second level map for the specified first level. */\n  getSLMap(fl: usize): u32 {\n    assert(fl < FL_BITS); // fl out of range\n    return load<u32>(changetype<usize>(this) + fl * 4, Root.SL_START);\n  }\n\n  /** Sets the second level map for the specified first level. */\n  setSLMap(fl: usize, value: u32): void {\n    assert(fl < FL_BITS); // fl out of range\n    store<u32>(changetype<usize>(this) + fl * 4, value, Root.SL_START);\n  }\n\n  /** End offset of second level maps. */\n  private static readonly SL_END: usize = Root.SL_START + FL_BITS * 4;\n\n  // Using *number bits per SL* heads per *FL bit*\n\n  /** Start offset of FL/SL heads. */\n  private static readonly HL_START: usize = (Root.SL_END + AL_MASK) & ~AL_MASK;\n\n  /** Gets the head of the specified first and second level index. */\n  getHead(fl: usize, sl: u32): Block | null {\n    assert(fl < FL_BITS); // fl out of range\n    assert(sl < SL_SIZE); // sl out of range\n    return changetype<Block>(load<usize>(\n      changetype<usize>(this) + (fl * SL_SIZE + <usize>sl) * sizeof<usize>()\n    , Root.HL_START));\n  }\n\n  /** Sets the head of the specified first and second level index. */\n  setHead(fl: usize, sl: u32, value: Block | null): void {\n    assert(fl < FL_BITS); // fl out of range\n    assert(sl < SL_SIZE); // sl out of range\n    store<usize>(\n      changetype<usize>(this) + (fl * SL_SIZE + <usize>sl) * sizeof<usize>()\n    , changetype<usize>(value)\n    , Root.HL_START);\n  }\n\n  /** End offset of FL/SL heads. */\n  private static readonly HL_END: usize = (\n    Root.HL_START + FL_BITS * SL_SIZE * sizeof<usize>()\n  );\n\n  get tailRef(): usize { return load<usize>(0, Root.HL_END); }\n  set tailRef(value: usize) { store<usize>(0, value, Root.HL_END); }\n\n  /** Total size of the {@link Root} structure. */\n  static readonly SIZE: usize = Root.HL_END + sizeof<usize>();\n\n  /** Inserts a previously used block back into the free list. */\n  insert(block: Block): void {\n    // check as much as possible here to prevent invalid free blocks\n    assert(block); // cannot be null\n    var blockInfo = block.info;\n    assert(blockInfo & FREE); // must be free\n    var size: usize;\n    assert(\n      (size = block.info & ~TAGS) >= Block.MIN_SIZE && size < Block.MAX_SIZE\n    ); // must be valid, not necessary to compute yet if noAssert=true\n\n    var right: Block = assert(block.right); // can't be null\n    var rightInfo = right.info;\n\n    // merge with right block if also free\n    if (rightInfo & FREE) {\n      this.remove(right);\n      block.info = (blockInfo += Block.INFO + (rightInfo & ~TAGS));\n      right = block.right;\n      rightInfo = right.info;\n      // jump is set below\n    }\n\n    // merge with left block if also free\n    if (blockInfo & LEFT_FREE) {\n      let left: Block = assert(block.left); // can't be null\n      let leftInfo = left.info;\n      assert(leftInfo & FREE); // must be free according to tags\n      this.remove(left);\n      left.info = (leftInfo += Block.INFO + (blockInfo & ~TAGS));\n      block = left;\n      blockInfo = leftInfo;\n      // jump is set below\n    }\n\n    right.info = rightInfo | LEFT_FREE;\n    this.setJump(block, right);\n    // right is no longer used now, hence rightInfo is not synced\n\n    size = blockInfo & ~TAGS;\n    assert(size >= Block.MIN_SIZE && size < Block.MAX_SIZE); // must be valid\n\n    // mapping_insert\n    var fl: usize, sl: u32;\n    if (size < SB_SIZE) {\n      fl = 0;\n      sl = <u32>(size / AL_SIZE);\n    } else {\n      fl = fls<usize>(size);\n      sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n      fl -= SB_BITS - 1;\n    }\n\n    // perform insertion\n    var head = this.getHead(fl, sl);\n    block.prev = null;\n    block.next = head;\n    if (head) head.prev = block;\n    this.setHead(fl, sl, block);\n\n    // update first and second level maps\n    this.flMap |= (1 << fl);\n    this.setSLMap(fl, this.getSLMap(fl) | (1 << sl));\n  }\n\n  /**\n   * Removes a free block from FL/SL maps. Does not alter left/jump because it\n   * is likely that splitting is performed afterwards, invalidating any changes\n   * again.\n   */\n  private remove(block: Block): void {\n    var blockInfo = block.info;\n    assert(blockInfo & FREE); // must be free\n    var size = blockInfo & ~TAGS;\n    assert(size >= Block.MIN_SIZE && size < Block.MAX_SIZE); // must be valid\n\n    // mapping_insert\n    var fl: usize, sl: u32;\n    if (size < SB_SIZE) {\n      fl = 0;\n      sl = <u32>(size / AL_SIZE);\n    } else {\n      fl = fls<usize>(size);\n      sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n      fl -= SB_BITS - 1;\n    }\n\n    // link previous and next free block\n    var prev = block.prev;\n    var next = block.next;\n    if (prev) prev.next = next;\n    if (next) next.prev = prev;\n\n    // update head if we are removing it\n    if (block == this.getHead(fl, sl)) {\n      this.setHead(fl, sl, next);\n\n      // clear second level map if head is empty now\n      if (!next) {\n        let slMap = this.getSLMap(fl);\n        this.setSLMap(fl, slMap &= ~(1 << sl));\n\n        // clear first level map if second level is empty now\n        if (!slMap) this.flMap &= ~(1 << fl);\n      }\n    }\n  }\n\n  /** Searches for a free block of at least the specified size. */\n  search(size: usize): Block | null {\n    assert(size >= Block.MIN_SIZE && size < Block.MAX_SIZE);\n\n    // mapping_search\n    var fl: usize, sl: u32;\n    if (size < SB_SIZE) {\n      fl = 0;\n      sl = <u32>(size / AL_SIZE);\n    } else {\n      // (*) size += (1 << (fls<usize>(size) - SL_BITS)) - 1;\n      fl = fls<usize>(size);\n      sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n      fl -= SB_BITS - 1;\n      // (*) instead of rounding up, use next second level list for better fit\n      if (sl < SL_SIZE - 1) ++sl;\n      else ++fl, sl = 0;\n    }\n\n    // search second level\n    var slMap = this.getSLMap(fl) & (~0 << sl);\n    var head: Block | null;\n    if (!slMap) {\n      // search next larger first level\n      let flMap = this.flMap & (~0 << (fl + 1));\n      if (!flMap) {\n        head = null;\n      } else {\n        fl = ffs<usize>(flMap);\n        slMap = assert(this.getSLMap(fl)); // can't be zero if fl points here\n        head = this.getHead(fl, ffs<u32>(slMap));\n      }\n    } else {\n      head = this.getHead(fl, ffs<u32>(slMap));\n    }\n    return head;\n  }\n\n  /** Links a free left with its right block in memory. */\n  private setJump(left: Block, right: Block): void {\n    assert(left.info & FREE);       // must be free\n    assert(left.right == right);    // right block must match\n    assert(right.info & LEFT_FREE); // right block must be tagged as LEFT_FREE\n    store<Block>(\n      changetype<usize>(right) - sizeof<usize>()\n    , left); // last word in left block's (free) data region\n  }\n\n  /**\n   * Uses the specified free block, removing it from internal maps and\n   * splitting it if possible, and returns its data pointer.\n   */\n  use(block: Block, size: usize): usize {\n    var blockInfo = block.info;\n    assert(blockInfo & FREE); // must be free so we can use it\n    assert(size >= Block.MIN_SIZE && size < Block.MAX_SIZE); // must be valid\n    assert(!(size & AL_MASK)); // size must be aligned so the new block is\n\n    this.remove(block);\n\n    // split if the block can hold another MIN_SIZE block\n    var remaining = (blockInfo & ~TAGS) - size;\n    if (remaining >= Block.INFO + Block.MIN_SIZE) {\n      block.info = size | (blockInfo & LEFT_FREE); // also discards FREE\n\n      let spare = changetype<Block>(\n        changetype<usize>(block) + Block.INFO + size\n      );\n      spare.info = (remaining - Block.INFO) | FREE; // not LEFT_FREE\n      this.insert(spare); // also sets jump\n\n    // otherwise tag block as no longer FREE and right as no longer LEFT_FREE\n    } else {\n      block.info = blockInfo & ~FREE;\n      let right: Block = assert(block.right); // can't be null (tail)\n      right.info &= ~LEFT_FREE;\n    }\n\n    return changetype<usize>(block) + Block.INFO;\n  }\n\n  /** Adds more memory to the pool. */\n  addMemory(start: usize, end: usize): bool {\n    assert(start <= end);\n    assert(!(start & AL_MASK)); // must be aligned\n    assert(!(end & AL_MASK)); // must be aligned\n\n    var tailRef = this.tailRef;\n    var tailInfo: usize = 0;\n    if (tailRef) {\n      assert(start >= tailRef + sizeof<usize>()); // starts after tail\n\n      // merge with current tail if adjacent\n      if (start - Block.INFO == tailRef) {\n        start -= Block.INFO;\n        tailInfo = changetype<Block>(tailRef).info;\n      }\n\n    } else {\n      assert(start >= changetype<usize>(this) + Root.SIZE); // starts after root\n    }\n\n    // check if size is large enough for a free block and the tail block\n    var size = end - start;\n    if (size < Block.INFO + Block.MIN_SIZE + Block.INFO) {\n      return false;\n    }\n\n    // left size is total minus its own and the zero-length tail's header\n    var leftSize = size - 2 * Block.INFO;\n    var left = changetype<Block>(start);\n    left.info = leftSize | FREE | (tailInfo & LEFT_FREE);\n    left.prev = null;\n    left.next = null;\n\n    // tail is a zero-length used block\n    var tail = changetype<Block>(start + size - Block.INFO);\n    tail.info = 0 | LEFT_FREE;\n    this.tailRef = changetype<usize>(tail);\n\n    this.insert(left); // also merges with free left before tail / sets jump\n\n    return true;\n  }\n}\n\n/** Determines the first (LSB to MSB) set bit's index of a word. */\nfunction ffs<T>(word: T): T {\n  assert(word != 0); // word cannot be 0\n  return ctz<T>(word);  // differs from ffs only for 0\n}\n\n/** Determines the last (LSB to MSB) set bit's index of a word. */\nfunction fls<T>(word: T): T {\n  assert(word != 0); // word cannot be 0\n  const inv: T = (sizeof<T>() << 3) - 1;\n  return inv - clz<T>(word);\n}\n\n/** Reference to the initialized {@link Root} structure, once initialized. */\nvar ROOT: Root = changetype<Root>(0);\n\n// Memory allocator interface\n\n/** Allocates a chunk of memory. */\n@global export function __memory_allocate(size: usize): usize {\n\n  // initialize if necessary\n  var root = ROOT;\n  if (!root) {\n    let rootOffset = (HEAP_BASE + AL_MASK) & ~AL_MASK;\n    let pagesBefore = memory.size();\n    let pagesNeeded = <i32>((((rootOffset + Root.SIZE) + 0xffff) & ~0xffff) >>> 16);\n    if (pagesNeeded > pagesBefore && memory.grow(pagesNeeded - pagesBefore) < 0) unreachable();\n    ROOT = root = changetype<Root>(rootOffset);\n    root.tailRef = 0;\n    root.flMap = 0;\n    for (let fl: usize = 0; fl < FL_BITS; ++fl) {\n      root.setSLMap(fl, 0);\n      for (let sl: u32 = 0; sl < SL_SIZE; ++sl) {\n        root.setHead(fl, sl, null);\n      }\n    }\n    root.addMemory((rootOffset + Root.SIZE + AL_MASK) & ~AL_MASK, memory.size() << 16);\n  }\n\n  // search for a suitable block\n  if (size > Block.MAX_SIZE) unreachable();\n\n  // 32-bit MAX_SIZE is 1 << 30 and itself aligned, hence the following can't overflow MAX_SIZE\n  size = max<usize>((size + AL_MASK) & ~AL_MASK, Block.MIN_SIZE);\n\n  var block = root.search(size);\n  if (!block) {\n\n    // request more memory\n    let pagesBefore = memory.size();\n    let pagesNeeded = <i32>(((size + 0xffff) & ~0xffff) >>> 16);\n    let pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n    if (memory.grow(pagesWanted) < 0) {\n      if (memory.grow(pagesNeeded) < 0) {\n        unreachable(); // out of memory\n      }\n    }\n    let pagesAfter = memory.size();\n    root.addMemory(<usize>pagesBefore << 16, <usize>pagesAfter << 16);\n    block = assert(root.search(size)); // must be found now\n  }\n\n  assert((block.info & ~TAGS) >= size);\n  return root.use(<Block>block, size);\n}\n\n/** Frees the chunk of memory at the specified address. */\n@global export function __memory_free(data: usize): void {\n  if (data) {\n    let root = ROOT;\n    if (root) {\n      let block = changetype<Block>(data - Block.INFO);\n      let blockInfo = block.info;\n      assert(!(blockInfo & FREE)); // must be used\n      block.info = blockInfo | FREE;\n      root.insert(changetype<Block>(data - Block.INFO));\n    }\n  }\n}\n\n@global export function __memory_reset(): void {\n  unreachable();\n}\n",
    "// this function will go away once `memory.copy` becomes an intrinsic\nexport function memcpy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memcpy.c\n  var w: u32, x: u32;\n\n  // copy 1 byte each until src is aligned to 4 bytes\n  while (n && (src & 3)) {\n    store<u8>(dest++, load<u8>(src++));\n    n--;\n  }\n\n  // if dst is aligned to 4 bytes as well, copy 4 bytes each\n  if ((dest & 3) == 0) {\n    while (n >= 16) {\n      store<u32>(dest     , load<u32>(src     ));\n      store<u32>(dest +  4, load<u32>(src +  4));\n      store<u32>(dest +  8, load<u32>(src +  8));\n      store<u32>(dest + 12, load<u32>(src + 12));\n      src += 16; dest += 16; n -= 16;\n    }\n    if (n & 8) {\n      store<u32>(dest    , load<u32>(src    ));\n      store<u32>(dest + 4, load<u32>(src + 4));\n      dest += 8; src += 8;\n    }\n    if (n & 4) {\n      store<u32>(dest, load<u32>(src));\n      dest += 4; src += 4;\n    }\n    if (n & 2) { // drop to 2 bytes each\n      store<u16>(dest, load<u16>(src));\n      dest += 2; src += 2;\n    }\n    if (n & 1) { // drop to 1 byte\n      store<u8>(dest++, load<u8>(src++));\n    }\n    return;\n  }\n\n  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\n  // doing shifts if faster when copying enough bytes (here: 32 or more)\n  if (n >= 32) {\n    switch (dest & 3) {\n      // known to be != 0\n      case 1: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 3;\n        while (n >= 17) {\n          x = load<u32>(src + 1);\n          store<u32>(dest, w >> 24 | x << 8);\n          w = load<u32>(src + 5);\n          store<u32>(dest + 4, x >> 24 | w << 8);\n          x = load<u32>(src + 9);\n          store<u32>(dest + 8, w >> 24 | x << 8);\n          w = load<u32>(src + 13);\n          store<u32>(dest + 12, x >> 24 | w << 8);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 2: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 2;\n        while (n >= 18) {\n          x = load<u32>(src + 2);\n          store<u32>(dest, w >> 16 | x << 16);\n          w = load<u32>(src + 6);\n          store<u32>(dest + 4, x >> 16 | w << 16);\n          x = load<u32>(src + 10);\n          store<u32>(dest + 8, w >> 16 | x << 16);\n          w = load<u32>(src + 14);\n          store<u32>(dest + 12, x >> 16 | w << 16);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 3: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        n -= 1;\n        while (n >= 19) {\n          x = load<u32>(src + 3);\n          store<u32>(dest, w >> 8 | x << 24);\n          w = load<u32>(src + 7);\n          store<u32>(dest + 4, x >> 8 | w << 24);\n          x = load<u32>(src + 11);\n          store<u32>(dest + 8, w >> 8 | x << 24);\n          w = load<u32>(src + 15);\n          store<u32>(dest + 12, x >> 8 | w << 24);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n    }\n  }\n\n  // copy remaining bytes one by one\n  if (n & 16) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 8) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 4) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 2) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 1) {\n    store<u8>(dest++, load<u8>(src++));\n  }\n}\n\n// this function will go away once `memory.copy` becomes an intrinsic\nexport function memmove(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\n  if (dest === src) return;\n  if (src + n <= dest || dest + n <= src) {\n    memcpy(dest, src, n);\n    return;\n  }\n  if (dest < src) {\n    if ((src & 7) == (dest & 7)) {\n      while (dest & 7) {\n        if (!n) return;\n        --n;\n        store<u8>(dest++, load<u8>(src++));\n      }\n      while (n >= 8) {\n        store<u64>(dest, load<u64>(src));\n        n    -= 8;\n        dest += 8;\n        src  += 8;\n      }\n    }\n    while (n) {\n      store<u8>(dest++, load<u8>(src++));\n      --n;\n    }\n  } else {\n    if ((src & 7) == (dest & 7)) {\n      while ((dest + n) & 7) {\n        if (!n) return;\n        store<u8>(dest + --n, load<u8>(src + n));\n      }\n      while (n >= 8) {\n        n -= 8;\n        store<u64>(dest + n, load<u64>(src + n));\n      }\n    }\n    while (n) {\n      store<u8>(dest + --n, load<u8>(src + n));\n    }\n  }\n}\n\n// this function will go away once `memory.fill` becomes an intrinsic\nexport function memset(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\n\n  // fill head and tail with minimal branching\n  if (!n) return;\n  store<u8>(dest, c);\n  store<u8>(dest + n - 1, c);\n  if (n <= 2) return;\n\n  store<u8>(dest + 1, c);\n  store<u8>(dest + 2, c);\n  store<u8>(dest + n - 2, c);\n  store<u8>(dest + n - 3, c);\n  if (n <= 6) return;\n  store<u8>(dest + 3, c);\n  store<u8>(dest + n - 4, c);\n  if (n <= 8) return;\n\n  // advance pointer to align it at 4-byte boundary\n  var k: usize = -dest & 3;\n  dest += k;\n  n -= k;\n  n &= -4;\n\n  var c32: u32 = <u32>-1 / 255 * c;\n\n  // fill head/tail up to 28 bytes each in preparation\n  store<u32>(dest, c32);\n  store<u32>(dest + n - 4, c32);\n  if (n <= 8) return;\n  store<u32>(dest + 4, c32);\n  store<u32>(dest + 8, c32);\n  store<u32>(dest + n - 12, c32);\n  store<u32>(dest + n - 8, c32);\n  if (n <= 24) return;\n  store<u32>(dest + 12, c32);\n  store<u32>(dest + 16, c32);\n  store<u32>(dest + 20, c32);\n  store<u32>(dest + 24, c32);\n  store<u32>(dest + n - 28, c32);\n  store<u32>(dest + n - 24, c32);\n  store<u32>(dest + n - 20, c32);\n  store<u32>(dest + n - 16, c32);\n\n  // align to a multiple of 8\n  k = 24 + (dest & 4);\n  dest += k;\n  n -= k;\n\n  // copy 32 bytes each\n  var c64: u64 = <u64>c32 | (<u64>c32 << 32);\n  while (n >= 32) {\n    store<u64>(dest, c64);\n    store<u64>(dest + 8, c64);\n    store<u64>(dest + 16, c64);\n    store<u64>(dest + 24, c64);\n    n -= 32;\n    dest += 32;\n  }\n}\n\nexport function memcmp(vl: usize, vr: usize, n: usize): i32 { // see: musl/src/string/memcmp.c\n  if (vl == vr) return 0;\n  while (n != 0 && load<u8>(vl) == load<u8>(vr)) {\n    n--; vl++; vr++;\n  }\n  return n ? <i32>load<u8>(vl) - <i32>load<u8>(vr) : 0;\n}\n",
    "import {\n  HEADER_SIZE as HEADER_SIZE_AB\n} from \"./internal/arraybuffer\";\n\nimport {\n  HASH\n} from \"./internal/hash\";\n\n// A deterministic hash map based on CloseTable from https://github.com/jorendorff/dht\n\n@inline const INITIAL_CAPACITY = 4;\n@inline const FILL_FACTOR: f64 = 8 / 3;\n@inline const FREE_FACTOR: f64 = 3 / 4;\n\n/** Structure of a map entry. */\n@unmanaged class MapEntry<K,V> {\n  key: K;\n  value: V;\n  taggedNext: usize; // LSB=1 indicates EMPTY\n}\n\n/** Empty bit. */\n@inline const EMPTY: usize = 1 << 0;\n\n/** Size of a bucket. */\n@inline const BUCKET_SIZE = sizeof<usize>();\n\n/** Computes the alignment of an entry. */\n@inline function ENTRY_ALIGN<K,V>(): usize {\n  // can align to 4 instead of 8 if 32-bit and K/V is <= 32-bits\n  const maxkv = sizeof<K>() > sizeof<V>() ? sizeof<K>() : sizeof<V>();\n  const align = (maxkv > sizeof<usize>() ? maxkv : sizeof<usize>()) - 1;\n  return align;\n}\n\n/** Computes the aligned size of an entry. */\n@inline function ENTRY_SIZE<K,V>(): usize {\n  const align = ENTRY_ALIGN<K,V>();\n  const size = (offsetof<MapEntry<K,V>>() + align) & ~align;\n  return size;\n}\n\nexport class Map<K,V> {\n\n  // buckets holding references to the respective first entry within\n  private buckets: ArrayBuffer; // usize[bucketsMask + 1]\n  private bucketsMask: u32;\n\n  // entries in insertion order\n  private entries: ArrayBuffer; // MapEntry<K,V>[entriesCapacity]\n  private entriesCapacity: i32;\n  private entriesOffset: i32;\n  private entriesCount: i32;\n\n  get size(): i32 { return this.entriesCount; }\n\n  constructor() { this.clear(); }\n\n  clear(): void {\n    const bucketsSize = INITIAL_CAPACITY * <i32>BUCKET_SIZE;\n    this.buckets = new ArrayBuffer(bucketsSize);\n    this.bucketsMask = INITIAL_CAPACITY - 1;\n    const entriesSize = INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>();\n    this.entries = new ArrayBuffer(entriesSize, true);\n    this.entriesCapacity = INITIAL_CAPACITY;\n    this.entriesOffset = 0;\n    this.entriesCount = 0;\n  }\n\n  private find(key: K, hashCode: u32): MapEntry<K,V> | null {\n    var entry = load<MapEntry<K,V>>(\n      changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE,\n      HEADER_SIZE_AB\n    );\n    while (entry) {\n      if (!(entry.taggedNext & EMPTY) && entry.key == key) return entry;\n      entry = changetype<MapEntry<K,V>>(entry.taggedNext & ~EMPTY);\n    }\n    return null;\n  }\n\n  has(key: K): bool {\n    return this.find(key, HASH<K>(key)) !== null;\n  }\n\n  get(key: K): V {\n    var entry = this.find(key, HASH<K>(key));\n    return entry ? entry.value : <V>unreachable();\n  }\n\n  set(key: K, value: V): void {\n    var hashCode = HASH<K>(key);\n    var entry = this.find(key, hashCode);\n    if (entry) {\n      entry.value = value;\n    } else {\n      // check if rehashing is necessary\n      if (this.entriesOffset == this.entriesCapacity) {\n        this.rehash(\n          this.entriesCount < <i32>(this.entriesCapacity * FREE_FACTOR)\n            ?  this.bucketsMask           // just rehash if 1/4+ entries are empty\n            : (this.bucketsMask << 1) | 1 // grow capacity to next 2^N\n        );\n      }\n      // append new entry\n      let entries = this.entries;\n      entry = changetype<MapEntry<K,V>>(\n        changetype<usize>(entries) + HEADER_SIZE_AB + this.entriesOffset++ * ENTRY_SIZE<K,V>()\n      );\n      entry.key = key;\n      entry.value = value;\n      ++this.entriesCount;\n      // link with previous entry in bucket\n      let bucketPtrBase = changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE;\n      entry.taggedNext = load<usize>(bucketPtrBase, HEADER_SIZE_AB);\n      store<usize>(bucketPtrBase, changetype<usize>(entry), HEADER_SIZE_AB);\n      if (isManaged<K>()) __gc_link(changetype<usize>(this), changetype<usize>(key)); // tslint:disable-line\n      if (isManaged<V>()) __gc_link(changetype<usize>(this), changetype<usize>(value)); // tslint:disable-line\n    }\n  }\n\n  delete(key: K): bool {\n    var entry = this.find(key, HASH<K>(key));\n    if (!entry) return false;\n    entry.taggedNext |= EMPTY;\n    --this.entriesCount;\n    // check if rehashing is appropriate\n    var halfBucketsMask = this.bucketsMask >> 1;\n    if (\n      halfBucketsMask + 1 >= max<u32>(INITIAL_CAPACITY, this.entriesCount) &&\n      this.entriesCount < <i32>(this.entriesCapacity * FREE_FACTOR)\n    ) this.rehash(halfBucketsMask);\n    return true;\n  }\n\n  private rehash(newBucketsMask: u32): void {\n    var newBucketsCapacity = <i32>(newBucketsMask + 1);\n    var newBuckets = new ArrayBuffer(newBucketsCapacity * <i32>BUCKET_SIZE);\n    var newEntriesCapacity = <i32>(newBucketsCapacity * FILL_FACTOR);\n    var newEntries = new ArrayBuffer(newEntriesCapacity * <i32>ENTRY_SIZE<K,V>(), true);\n\n    // copy old entries to new entries\n    var oldPtr = changetype<usize>(this.entries) + HEADER_SIZE_AB;\n    var oldEnd = oldPtr + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();\n    var newPtr = changetype<usize>(newEntries) + HEADER_SIZE_AB;\n    while (oldPtr != oldEnd) {\n      let oldEntry = changetype<MapEntry<K,V>>(oldPtr);\n      if (!(oldEntry.taggedNext & EMPTY)) {\n        let newEntry = changetype<MapEntry<K,V>>(newPtr);\n        newEntry.key = oldEntry.key;\n        newEntry.value = oldEntry.value;\n        let newBucketIndex = HASH<K>(oldEntry.key) & newBucketsMask;\n        let newBucketPtrBase = changetype<usize>(newBuckets) + <usize>newBucketIndex * BUCKET_SIZE;\n        newEntry.taggedNext = load<usize>(newBucketPtrBase, HEADER_SIZE_AB);\n        store<usize>(newBucketPtrBase, newPtr, HEADER_SIZE_AB);\n        newPtr += ENTRY_SIZE<K,V>();\n      }\n      oldPtr += ENTRY_SIZE<K,V>();\n    }\n\n    this.buckets = newBuckets;\n    this.bucketsMask = newBucketsMask;\n    this.entries = newEntries;\n    this.entriesCapacity = newEntriesCapacity;\n    this.entriesOffset = this.entriesCount;\n  }\n\n  toString(): string {\n    return \"[object Map]\";\n  }\n\n  private __gc(): void {\n    __gc_mark(changetype<usize>(this.buckets)); // tslint:disable-line\n    var entries = this.entries;\n    __gc_mark(changetype<usize>(entries)); // tslint:disable-line\n    if (isManaged<K>() || isManaged<V>()) {\n      let offset: usize = 0;\n      let end: usize = this.entriesOffset * ENTRY_SIZE<K,V>();\n      while (offset < end) {\n        let entry = changetype<MapEntry<K,V>>(\n          changetype<usize>(entries) + HEADER_SIZE_AB + offset * ENTRY_SIZE<K,V>()\n        );\n        if (!(entry.taggedNext & EMPTY)) {\n          if (isManaged<K>()) __gc_mark(changetype<usize>(entry.key)); // tslint:disable-line\n          if (isManaged<V>()) __gc_mark(changetype<usize>(entry.value)); // tslint:disable-line\n        }\n        offset += ENTRY_SIZE<K,V>();\n      }\n    }\n  }\n}\n",
    "import {\n  HEADER_SIZE\n} from \"./string\";\n\n/** Computes the 32-bit hash of a value of any type. */\n@inline\nexport function HASH<T>(key: T): u32 {\n  // branch-level tree-shaking makes this a `(return (call ...))`\n  if (isString(key)) {\n    return hashStr(key);\n  } else if (isReference<T>()) {\n    if (sizeof<T>() == 4) return hash32(changetype<u32>(key));\n    if (sizeof<T>() == 8) return hash64(changetype<u64>(key));\n  } else if (isFloat<T>()) {\n    if (sizeof<T>() == 4) return hash32(reinterpret<u32>(key));\n    if (sizeof<T>() == 8) return hash64(reinterpret<u64>(key));\n  } else {\n    if (sizeof<T>() == 1) return hash8 (<u32>key);\n    if (sizeof<T>() == 2) return hash16(<u32>key);\n    if (sizeof<T>() == 4) return hash32(<u32>key);\n    if (sizeof<T>() == 8) return hash64(<u64>key);\n  }\n  unreachable();\n}\n\n// FNV-1a 32-bit as a starting point, see: http://isthe.com/chongo/tech/comp/fnv/\n\n@inline const FNV_OFFSET: u32 = 2166136261;\n@inline const FNV_PRIME: u32 = 16777619;\n\nfunction hash8(key: u32): u32 {\n  return (FNV_OFFSET ^ key) * FNV_PRIME;\n}\n\nfunction hash16(key: u32): u32 {\n  var v = FNV_OFFSET;\n  v = (v ^ ( key        & 0xff)) * FNV_PRIME;\n  v = (v ^ ( key >>  8        )) * FNV_PRIME;\n  return v;\n}\n\nfunction hash32(key: u32): u32 {\n  var v = FNV_OFFSET;\n  v = (v ^ ( key        & 0xff)) * FNV_PRIME;\n  v = (v ^ ((key >>  8) & 0xff)) * FNV_PRIME;\n  v = (v ^ ((key >> 16) & 0xff)) * FNV_PRIME;\n  v = (v ^ ( key >> 24        )) * FNV_PRIME;\n  return v;\n}\n\nfunction hash64(key: u64): u32 {\n  var l = <u32> key;\n  var h = <u32>(key >>> 32);\n  var v = FNV_OFFSET;\n  v = (v ^ ( l        & 0xff)) * FNV_PRIME;\n  v = (v ^ ((l >>  8) & 0xff)) * FNV_PRIME;\n  v = (v ^ ((l >> 16) & 0xff)) * FNV_PRIME;\n  v = (v ^ ( l >> 24        )) * FNV_PRIME;\n  v = (v ^ ( h        & 0xff)) * FNV_PRIME;\n  v = (v ^ ((h >>  8) & 0xff)) * FNV_PRIME;\n  v = (v ^ ((h >> 16) & 0xff)) * FNV_PRIME;\n  v = (v ^ ( h >> 24        )) * FNV_PRIME;\n  return v;\n}\n\nfunction hashStr(key: string): u32 {\n  var v = FNV_OFFSET;\n  for (let i: usize = 0, k: usize = key.length << 1; i < k; ++i) {\n    v = (v ^ <u32>load<u8>(changetype<usize>(key) + i, HEADER_SIZE)) * FNV_PRIME;\n  }\n  return v;\n}\n",
    "import {\n  HEADER_SIZE,\n  MAX_BLENGTH,\n  allocateUnsafe\n} from \"./internal/arraybuffer\";\n\nimport {\n  Uint8ClampedArray,\n  Uint8Array,\n  Int8Array,\n  Uint16Array,\n  Int16Array,\n  Uint32Array,\n  Int32Array,\n  Uint64Array,\n  Int64Array\n} from \"./typedarray\";\n\nimport {\n  DataView\n} from \"./dataview\";\n\n@sealed\nexport class ArrayBuffer {\n\n  readonly byteLength: i32; // capped to [0, MAX_LENGTH]\n\n  @inline static isView<T>(value: T): bool {\n    if (value === null) return false;\n    if (value instanceof Uint8ClampedArray) return true;\n    if (value instanceof Uint8Array) return true;\n    if (value instanceof Int8Array) return true;\n    if (value instanceof Uint16Array) return true;\n    if (value instanceof Int16Array) return true;\n    if (value instanceof Uint32Array) return true;\n    if (value instanceof Int32Array) return true;\n    if (value instanceof Uint64Array) return true;\n    if (value instanceof Int64Array) return true;\n    if (value instanceof DataView) return true;\n    return false;\n  }\n\n  // @unsafe\n  @inline get data(): usize { return changetype<usize>(this) + HEADER_SIZE; }\n\n  constructor(length: i32, unsafe: bool = false) {\n    if (<u32>length > <u32>MAX_BLENGTH) throw new RangeError(\"Invalid array buffer length\");\n    var buffer = allocateUnsafe(length);\n    if (!unsafe) memory.fill(changetype<usize>(buffer) + HEADER_SIZE, 0, <usize>length);\n    return buffer;\n  }\n\n  slice(begin: i32 = 0, end: i32 = MAX_BLENGTH): ArrayBuffer {\n    var len = this.byteLength;\n    begin = begin < 0 ? max(len + begin, 0) : min(begin, len);\n    end = end < 0 ? max(len + end, 0) : min(end, len);\n    len = max(end - begin, 0);\n    var buffer = allocateUnsafe(len);\n    memory.copy(\n      changetype<usize>(buffer) + HEADER_SIZE,\n      changetype<usize>(this) + HEADER_SIZE + begin,\n      len\n    );\n    return buffer;\n  }\n\n  toString(): string {\n    return \"[object ArrayBuffer]\";\n  }\n}\n",
    "import { CanvasRenderingContext2D } from \"../renderer/CanvasRenderingContext2D\";\n\nlet map = new Map<string, CanvasRenderingContext2D>();\n\n/**\n * This internal function is exported via the `./assembly/glue.ts` file. It receives an id from the\n * host, and a name. It's responsible for creating a new CanvasRenderingContext2D object, then\n * stores it on the map object by it's name. This allows developers to call `getContextById(name)`\n * to obtain the created reference to the canvas context.\n *\n * @param {string} name - The name of the CanvasRenderingContext2D object\n * @param {i32} id - The unique objectid created by the browser that identifies the context.\n */\nexport function __use_context(name: string, id: i32): void {\n  var result = new CanvasRenderingContext2D();\n  store<i32>(changetype<usize>(result) + offsetof<CanvasRenderingContext2D>(\"id\"), id);\n  map.set(name, result);\n}\n\n/**\n * This function is the only way to obtain a named canvas provided by the JavaScript host.\n *\n * @param {string} name - This is the name of the provided context.\n */\nexport function getContextById(name: string): CanvasRenderingContext2D {\n  if (!map.has(name)) throw new Error(\"Cannot find context with name: \" + name);\n  return map.get(name);\n}\n",
    "\nimport { STORE } from \"internal/arraybuffer\";\n\n/**\n * The Buffer class is an ArrayBuffer backed data writer that utilizes the internal STORE function\n * provided by AssemblyScript to write data as fast as possible to memory. The generic type\n * parameter represents an enum indicating the instruction type values coupled with the memory\n * writes. Each instruction write results in the following values written to the buffer:\n *\n * 1. [instruction] `T` - This value is the instruction type cast to a `f64`\n * 2. [nextIndex] `i32` - This value is the pointer to the next instruction index\n * 3. [...args] `f64[]` - These values are the argument values for the instruction\n */\nexport class Buffer<T extends i32> {\n  /**\n   * The buffer property is a reference to an allocated block of memory that contains all the\n   * currently written values to the buffer. The browser eventually should obtain a pointer to this\n   * block and read the values from it to perform actions.\n   */\n  protected _buffer: ArrayBuffer = new ArrayBuffer(0x10000 * sizeof<f64>(), true);\n\n  /**\n   * The offset property is a pointer to the next index that will receive a written value.\n   */\n  private _offset: i32 = 0;\n\n  /**\n   * Write a single instruction to the buffer without any parameters. This results in two values\n   * written to the buffer.\n   *\n   * @param {T} inst - The instruction type to be written to the buffer.\n   */\n  @inline\n  protected _writeZero(inst: T): void {\n    var buff: ArrayBuffer = this._buffer;\n    var index: i32 = this._offset;\n    var next: i32 = index + 2;\n    STORE<f64>(buff, index, <f64>inst);\n    STORE<f64>(buff, index + 1, <f64>next);\n    this._offset = next;\n  }\n\n  /**\n   * Write a single instruction to the buffer with a single parameter. This results in three values\n   * written to the buffer.\n   *\n   * @param {T} inst - The instruction type to be written to the buffer.\n   * @param {f64} a - The first parameter for the instruction to be written to the buffer.\n   */\n  @inline\n  protected _writeOne(inst: T, a: f64): void {\n    var buff: ArrayBuffer = this._buffer;\n    var index: i32 = this._offset;\n    var next: i32 = index + 3;\n    STORE<f64>(buff, index, <f64>inst);\n    STORE<f64>(buff, index + 1, <f64>next);\n    STORE<f64>(buff, index + 2, a);\n    this._offset = next;\n  }\n\n  /**\n   * Write a single instruction to the buffer with two parameters. This results in four values\n   * written to the buffer.\n   *\n   * @param {T} inst - The instruction type to be written to the buffer.\n   * @param {f64} a - The first parameter for the instruction to be written to the buffer.\n   * @param {f64} b - The second parameter for the instruction to be written to the buffer.\n   */\n  @inline\n  protected _writeTwo(inst: T, a: f64, b: f64): void {\n    var buff: ArrayBuffer = this._buffer;\n    var index: i32 = this._offset;\n    var next: i32 = index + 4;\n    STORE<f64>(buff, index, <f64>inst);\n    STORE<f64>(buff, index + 1, <f64>next);\n    STORE<f64>(buff, index + 2, a);\n    STORE<f64>(buff, index + 3, b);\n    this._offset = next;\n  }\n\n  /**\n   * Write a single instruction to the buffer with three parameters. This results in five values\n   * written to the buffer.\n   *\n   * @param {T} inst - The instruction type to be written to the buffer.\n   * @param {f64} a - The first parameter for the instruction to be written to the buffer.\n   * @param {f64} b - The second parameter for the instruction to be written to the buffer.\n   * @param {f64} c - The third parameter for the instruction to be written to the buffer.\n   */\n  @inline\n  protected _writeThree(inst: T, a: f64, b: f64, c: f64): void {\n    var buff: ArrayBuffer = this._buffer;\n    var index: i32 = this._offset;\n    var next: i32 = index + 5;\n    STORE<f64>(buff, index, <f64>inst);\n    STORE<f64>(buff, index + 1, <f64>next);\n    STORE<f64>(buff, index + 2, a);\n    STORE<f64>(buff, index + 3, b);\n    STORE<f64>(buff, index + 4, c);\n    this._offset = next;\n  }\n\n  /**\n   * Write a single instruction to the buffer with four parameters. This results in six values\n   * written to the buffer.\n   *\n   * @param {T} inst - The instruction type to be written to the buffer.\n   * @param {f64} a - The first parameter for the instruction to be written to the buffer.\n   * @param {f64} b - The second parameter for the instruction to be written to the buffer.\n   * @param {f64} c - The third parameter for the instruction to be written to the buffer.\n   * @param {f64} d - The fourth parameter for the instruction to be written to the buffer.\n   */\n  @inline\n  protected _writeFour(inst: T, a: f64, b: f64, c: f64, d: f64): void {\n    var buff: ArrayBuffer = this._buffer;\n    var index: i32 = this._offset;\n    var next: i32 = index + 6;\n    STORE<f64>(buff, index, <f64>inst);\n    STORE<f64>(buff, index + 1, <f64>next);\n    STORE<f64>(buff, index + 2, a);\n    STORE<f64>(buff, index + 3, b);\n    STORE<f64>(buff, index + 4, c);\n    STORE<f64>(buff, index + 5, d);\n    this._offset = next;\n  }\n\n  /**\n   * Write a single instruction to the buffer with five parameters. This results in seven values\n   * written to the buffer.\n   *\n   * @param {T} inst - The instruction type to be written to the buffer.\n   * @param {f64} a - The first parameter for the instruction to be written to the buffer.\n   * @param {f64} b - The second parameter for the instruction to be written to the buffer.\n   * @param {f64} c - The third parameter for the instruction to be written to the buffer.\n   * @param {f64} d - The fourth parameter for the instruction to be written to the buffer.\n   * @param {f64} d - The fifth parameter for the instruction to be written to the buffer.\n   */\n  @inline\n  protected _writeFive(inst: T, a: f64, b: f64, c: f64, d: f64, e: f64): void {\n    var buff: ArrayBuffer = this._buffer;\n    var index: i32 = this._offset;\n    var next: i32 = index + 7;\n    STORE<f64>(buff, index, <f64>inst);\n    STORE<f64>(buff, index + 1, <f64>next);\n    STORE<f64>(buff, index + 2, a);\n    STORE<f64>(buff, index + 3, b);\n    STORE<f64>(buff, index + 4, c);\n    STORE<f64>(buff, index + 5, d);\n    STORE<f64>(buff, index + 6, e);\n    this._offset = next;\n  }\n\n  /**\n   * Write a single instruction to the buffer with six parameters. This results in eight values\n   * written to the buffer.\n   *\n   * @param {T} inst - The instruction type to be written to the buffer.\n   * @param {f64} a - The first parameter for the instruction to be written to the buffer.\n   * @param {f64} b - The second parameter for the instruction to be written to the buffer.\n   * @param {f64} c - The third parameter for the instruction to be written to the buffer.\n   * @param {f64} d - The fourth parameter for the instruction to be written to the buffer.\n   * @param {f64} e - The fifth parameter for the instruction to be written to the buffer.\n   * @param {f64} f - The sixth parameter for the instruction to be written to the buffer.\n   */\n  @inline\n  protected _writeSix(inst: T, a: f64, b: f64, c: f64, d: f64, e: f64, f: f64): void {\n    var buff: ArrayBuffer = this._buffer;\n    var index: i32 = this._offset;\n    var next: i32 = index + 8;\n    STORE<f64>(buff, index, <f64>inst);\n    STORE<f64>(buff, index + 1, <f64>next);\n    STORE<f64>(buff, index + 2, a);\n    STORE<f64>(buff, index + 3, b);\n    STORE<f64>(buff, index + 4, c);\n    STORE<f64>(buff, index + 5, d);\n    STORE<f64>(buff, index + 6, e);\n    STORE<f64>(buff, index + 7, f);\n    this._offset = next;\n  }\n\n  /**\n   * Write a single instruction to the buffer with eight parameters. This results in ten values\n   * written to the buffer.\n   *\n   * @param {T} inst - The instruction type to be written to the buffer.\n   * @param {f64} a - The first parameter for the instruction to be written to the buffer.\n   * @param {f64} b - The second parameter for the instruction to be written to the buffer.\n   * @param {f64} c - The third parameter for the instruction to be written to the buffer.\n   * @param {f64} d - The fourth parameter for the instruction to be written to the buffer.\n   * @param {f64} e - The fifth parameter for the instruction to be written to the buffer.\n   * @param {f64} f - The sixth parameter for the instruction to be written to the buffer.\n   * @param {f64} g - The seventh parameter for the instruction to be written to the buffer.\n   * @param {f64} h - The eighth parameter for the instruction to be written to the buffer.\n   */\n  @inline\n  protected _writeEight(inst: T, a: f64, b: f64, c: f64, d: f64, e: f64, f: f64, g: f64, h: f64): void {\n    var buff: ArrayBuffer = this._buffer;\n    var index: i32 = this._offset;\n    var next: i32 = index + 10;\n    STORE<f64>(buff, index, <f64>inst);\n    STORE<f64>(buff, index + 1, <f64>next);\n    STORE<f64>(buff, index + 2, a);\n    STORE<f64>(buff, index + 3, b);\n    STORE<f64>(buff, index + 4, c);\n    STORE<f64>(buff, index + 5, d);\n    STORE<f64>(buff, index + 6, e);\n    STORE<f64>(buff, index + 7, f);\n    STORE<f64>(buff, index + 8, g);\n    STORE<f64>(buff, index + 9, h);\n    this._offset = next;\n  }\n\n  /**\n   * Write a single instruction to the buffer with nine parameters. This results in eleven values\n   * written to the buffer.\n   *\n   * @param {T} inst - The instruction type to be written to the buffer.\n   * @param {f64} a - The first parameter for the instruction to be written to the buffer.\n   * @param {f64} b - The second parameter for the instruction to be written to the buffer.\n   * @param {f64} c - The third parameter for the instruction to be written to the buffer.\n   * @param {f64} d - The fourth parameter for the instruction to be written to the buffer.\n   * @param {f64} e - The fifth parameter for the instruction to be written to the buffer.\n   * @param {f64} f - The sixth parameter for the instruction to be written to the buffer.\n   * @param {f64} g - The seventh parameter for the instruction to be written to the buffer.\n   * @param {f64} h - The eighth parameter for the instruction to be written to the buffer.\n   * @param {f64} i - The ninth parameter for the instruction to be written to the buffer.\n   */\n  @inline\n  protected _writeNine(inst: T, a: f64, b: f64, c: f64, d: f64, e: f64, f: f64, g: f64, h: f64, i: f64): void {\n    var buff: ArrayBuffer = this._buffer;\n    var index: i32 = this._offset;\n    var next: i32 = index + 11;\n    STORE<f64>(buff, index, <f64>inst);\n    STORE<f64>(buff, index + 1, <f64>next);\n    STORE<f64>(buff, index + 2, a);\n    STORE<f64>(buff, index + 3, b);\n    STORE<f64>(buff, index + 4, c);\n    STORE<f64>(buff, index + 5, d);\n    STORE<f64>(buff, index + 6, e);\n    STORE<f64>(buff, index + 7, f);\n    STORE<f64>(buff, index + 8, g);\n    STORE<f64>(buff, index + 9, h);\n    STORE<f64>(buff, index + 10, i);\n    this._offset = next;\n  }\n\n  /**\n   * Reset the buffer back to position 0.\n   */\n  @inline\n  protected _resetBuffer(): void {\n    this._offset = 0;\n  }\n}\n",
    "import {\n  CharCode,\n  allocateUnsafe as allocateUnsafeString,\n  freeUnsafe as freeUnsafeString,\n  HEADER_SIZE as STRING_HEADER_SIZE\n} from \"./string\";\n\nimport {\n  LOAD\n} from \"./arraybuffer\";\n\n@inline export const MAX_DOUBLE_LENGTH = 28;\n\n@lazy @inline const POWERS10: u32[] = [\n  1,\n  10,\n  100,\n  1000,\n  10000,\n  100000,\n  1000000,\n  10000000,\n  100000000,\n  1000000000\n];\n\n/*\n  Lookup table for pairwise char codes in range [0-99]\n\n  \"00\", \"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\",\n  \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\",\n  \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\",\n  \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\",\n  \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\",\n  \"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\", \"58\", \"59\",\n  \"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\",\n  \"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\",\n  \"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\", \"89\",\n  \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\"\n*/\n@lazy @inline const DIGITS: u32[] = [\n  0x00300030, 0x00310030, 0x00320030, 0x00330030, 0x00340030,\n  0x00350030, 0x00360030, 0x00370030, 0x00380030, 0x00390030,\n  0x00300031, 0x00310031, 0x00320031, 0x00330031, 0x00340031,\n  0x00350031, 0x00360031, 0x00370031, 0x00380031, 0x00390031,\n  0x00300032, 0x00310032, 0x00320032, 0x00330032, 0x00340032,\n  0x00350032, 0x00360032, 0x00370032, 0x00380032, 0x00390032,\n  0x00300033, 0x00310033, 0x00320033, 0x00330033, 0x00340033,\n  0x00350033, 0x00360033, 0x00370033, 0x00380033, 0x00390033,\n  0x00300034, 0x00310034, 0x00320034, 0x00330034, 0x00340034,\n  0x00350034, 0x00360034, 0x00370034, 0x00380034, 0x00390034,\n  0x00300035, 0x00310035, 0x00320035, 0x00330035, 0x00340035,\n  0x00350035, 0x00360035, 0x00370035, 0x00380035, 0x00390035,\n  0x00300036, 0x00310036, 0x00320036, 0x00330036, 0x00340036,\n  0x00350036, 0x00360036, 0x00370036, 0x00380036, 0x00390036,\n  0x00300037, 0x00310037, 0x00320037, 0x00330037, 0x00340037,\n  0x00350037, 0x00360037, 0x00370037, 0x00380037, 0x00390037,\n  0x00300038, 0x00310038, 0x00320038, 0x00330038, 0x00340038,\n  0x00350038, 0x00360038, 0x00370038, 0x00380038, 0x00390038,\n  0x00300039, 0x00310039, 0x00320039, 0x00330039, 0x00340039,\n  0x00350039, 0x00360039, 0x00370039, 0x00380039, 0x00390039\n];\n\n@lazy @inline const EXP_POWERS: i16[] = [\n  -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007,  -980,\n   -954,  -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,\n   -688,  -661,  -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,\n   -422,  -396,  -369,  -343,  -316,  -289,  -263,  -236,  -210,  -183,\n   -157,  -130,  -103,   -77,   -50,   -24,     3,    30,    56,    83,\n    109,   136,   162,   189,   216,   242,   269,   295,   322,   348,\n    375,   402,   428,   455,   481,   508,   534,   561,   588,   614,\n    641,   667,   694,   720,   747,   774,   800,   827,   853,   880,\n    907,   933,   960,   986,  1013,  1039,  1066\n];\n\n// 1e-348, 1e-340, ..., 1e340\n@lazy @inline const FRC_POWERS: u64[] = [\n  0xFA8FD5A0081C0288, 0xBAAEE17FA23EBF76, 0x8B16FB203055AC76, 0xCF42894A5DCE35EA,\n  0x9A6BB0AA55653B2D, 0xE61ACF033D1A45DF, 0xAB70FE17C79AC6CA, 0xFF77B1FCBEBCDC4F,\n  0xBE5691EF416BD60C, 0x8DD01FAD907FFC3C, 0xD3515C2831559A83, 0x9D71AC8FADA6C9B5,\n  0xEA9C227723EE8BCB, 0xAECC49914078536D, 0x823C12795DB6CE57, 0xC21094364DFB5637,\n  0x9096EA6F3848984F, 0xD77485CB25823AC7, 0xA086CFCD97BF97F4, 0xEF340A98172AACE5,\n  0xB23867FB2A35B28E, 0x84C8D4DFD2C63F3B, 0xC5DD44271AD3CDBA, 0x936B9FCEBB25C996,\n  0xDBAC6C247D62A584, 0xA3AB66580D5FDAF6, 0xF3E2F893DEC3F126, 0xB5B5ADA8AAFF80B8,\n  0x87625F056C7C4A8B, 0xC9BCFF6034C13053, 0x964E858C91BA2655, 0xDFF9772470297EBD,\n  0xA6DFBD9FB8E5B88F, 0xF8A95FCF88747D94, 0xB94470938FA89BCF, 0x8A08F0F8BF0F156B,\n  0xCDB02555653131B6, 0x993FE2C6D07B7FAC, 0xE45C10C42A2B3B06, 0xAA242499697392D3,\n  0xFD87B5F28300CA0E, 0xBCE5086492111AEB, 0x8CBCCC096F5088CC, 0xD1B71758E219652C,\n  0x9C40000000000000, 0xE8D4A51000000000, 0xAD78EBC5AC620000, 0x813F3978F8940984,\n  0xC097CE7BC90715B3, 0x8F7E32CE7BEA5C70, 0xD5D238A4ABE98068, 0x9F4F2726179A2245,\n  0xED63A231D4C4FB27, 0xB0DE65388CC8ADA8, 0x83C7088E1AAB65DB, 0xC45D1DF942711D9A,\n  0x924D692CA61BE758, 0xDA01EE641A708DEA, 0xA26DA3999AEF774A, 0xF209787BB47D6B85,\n  0xB454E4A179DD1877, 0x865B86925B9BC5C2, 0xC83553C5C8965D3D, 0x952AB45CFA97A0B3,\n  0xDE469FBD99A05FE3, 0xA59BC234DB398C25, 0xF6C69A72A3989F5C, 0xB7DCBF5354E9BECE,\n  0x88FCF317F22241E2, 0xCC20CE9BD35C78A5, 0x98165AF37B2153DF, 0xE2A0B5DC971F303A,\n  0xA8D9D1535CE3B396, 0xFB9B7CD9A4A7443C, 0xBB764C4CA7A44410, 0x8BAB8EEFB6409C1A,\n  0xD01FEF10A657842C, 0x9B10A4E5E9913129, 0xE7109BFBA19C0C9D, 0xAC2820D9623BF429,\n  0x80444B5E7AA7CF85, 0xBF21E44003ACDD2D, 0x8E679C2F5E44FF8F, 0xD433179D9C8CB841,\n  0x9E19DB92B4E31BA9, 0xEB96BF6EBADF77D9, 0xAF87023B9BF0EE6B\n];\n\n// Count number of decimals for u32 values\n// In our case input value always non-zero so we can simplify some parts\nexport function decimalCount32(value: u32): u32 {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    let l: u32 = 32 - clz<u32>(value); // log2\n    let t = l * 1233 >>> 12; // log10\n\n    let lutbuf = <ArrayBuffer>POWERS10.buffer_;\n    let power  = LOAD<u32>(lutbuf, t);\n    t -= <u32>(value < power);\n    return t + 1;\n  } else {\n    if (value < 100000) {\n      if (value < 100) {\n        return select<u32>(1, 2, value < 10);\n      } else {\n        let m = select<u32>(4, 5, value < 10000);\n        return select<u32>(3, m, value < 1000);\n      }\n    } else {\n      if (value < 10000000) {\n        return select<u32>(6, 7, value < 1000000);\n      } else {\n        let m = select<u32>(9, 10, value < 1000000000);\n        return select<u32>(8, m, value < 100000000);\n      }\n    }\n  }\n}\n\n// Count number of decimals for u64 values\n// In our case input value always greater than 2^32-1 so we can skip some parts\nexport function decimalCount64(value: u64): u32 {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    let l: u32 = 64 - <u32>clz<u64>(value); // log2\n    let t = l * 1233 >>> 12; // log10\n\n    let lutbuf = <ArrayBuffer>POWERS10.buffer_;\n    let power  = LOAD<u32,u64>(lutbuf, t - 10);\n    t -= <u32>(value < 10000000000 * power);\n    return t + 1;\n  } else {\n    if (value < 1000000000000000) {\n      if (value < 1000000000000) {\n        return select<u32>(11, 12, value < 100000000000);\n      } else {\n        let m = select<u32>(14, 15, value < 100000000000000);\n        return select<u32>(13, m, value < 10000000000000);\n      }\n    } else {\n      if (value < 100000000000000000) {\n        return select<u32>(16, 17, value < 10000000000000000);\n      } else {\n        let m = select<u32>(19, 20, value < 10000000000000000000);\n        return select<u32>(18, m, value < 1000000000000000000);\n      }\n    }\n  }\n}\n\nfunction utoa32_lut(buffer: usize, num: u32, offset: usize): void {\n  var lutbuf = <ArrayBuffer>DIGITS.buffer_;\n\n  while (num >= 10000) {\n    // in most VMs i32/u32 div and modulo by constant can be shared and simplificate\n    let t = num / 10000;\n    let r = num % 10000;\n    num = t;\n\n    let d1 = r / 100;\n    let d2 = r % 100;\n\n    let digits1 = LOAD<u32,u64>(lutbuf, d1);\n    let digits2 = LOAD<u32,u64>(lutbuf, d2);\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32), STRING_HEADER_SIZE);\n  }\n\n  if (num >= 100) {\n    let t  = num / 100;\n    let d1 = num % 100;\n    num = t;\n    offset -= 2;\n    let digits = LOAD<u32>(lutbuf, d1);\n    store<u32>(buffer + (offset << 1), digits, STRING_HEADER_SIZE);\n  }\n\n  if (num >= 10) {\n    offset -= 2;\n    let digits = LOAD<u32>(lutbuf, num);\n    store<u32>(buffer + (offset << 1), digits, STRING_HEADER_SIZE);\n  } else {\n    offset -= 1;\n    let digit = CharCode._0 + num;\n    store<u16>(buffer + (offset << 1), digit, STRING_HEADER_SIZE);\n  }\n}\n\nfunction utoa64_lut(buffer: usize, num: u64, offset: usize): void {\n  var lutbuf = <ArrayBuffer>DIGITS.buffer_;\n\n  while (num >= 100000000) {\n    let t = num / 100000000;\n    let r = <usize>(num - t * 100000000);\n    num = t;\n\n    let b = r / 10000;\n    let c = r % 10000;\n\n    let b1 = b / 100;\n    let b2 = b % 100;\n    let c1 = c / 100;\n    let c2 = c % 100;\n\n    let digits1 = LOAD<u32,u64>(lutbuf, c1);\n    let digits2 = LOAD<u32,u64>(lutbuf, c2);\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32), STRING_HEADER_SIZE);\n\n    digits1 = LOAD<u32,u64>(lutbuf, b1);\n    digits2 = LOAD<u32,u64>(lutbuf, b2);\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32), STRING_HEADER_SIZE);\n  }\n\n  utoa32_lut(buffer, <u32>num, offset);\n}\n\nfunction utoa_simple<T>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let t = num / 10;\n    let r = <u32>(num % 10);\n    num = t;\n    offset -= 1;\n    store<u16>(buffer + (offset << 1), CharCode._0 + r, STRING_HEADER_SIZE);\n  } while (num);\n}\n\n@inline\nexport function utoa32_core(buffer: usize, num: u32, offset: u32): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_simple(buffer, num, offset);\n  } else {\n    utoa32_lut(buffer, num, offset);\n  }\n}\n\n@inline\nexport function utoa64_core(buffer: usize, num: u64, offset: u32): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_simple(buffer, num, offset);\n  } else {\n    utoa64_lut(buffer, num, offset);\n  }\n}\n\nexport function utoa32(value: u32): String {\n  if (!value) return \"0\";\n\n  var decimals = decimalCount32(value);\n  var buffer   = allocateUnsafeString(decimals);\n\n  utoa32_core(changetype<usize>(buffer), value, decimals);\n  return buffer;\n}\n\nexport function itoa32(value: i32): String {\n  if (!value) return \"0\";\n\n  var sign = value < 0;\n  if (sign) value = -value;\n\n  var decimals = decimalCount32(value) + <u32>sign;\n  var buffer   = allocateUnsafeString(decimals);\n\n  utoa32_core(changetype<usize>(buffer), value, decimals);\n  if (sign) store<u16>(changetype<usize>(buffer), CharCode.MINUS, STRING_HEADER_SIZE);\n\n  return buffer;\n}\n\nexport function utoa64(value: u64): String {\n  if (!value) return \"0\";\n\n  var buffer: String;\n  if (value <= u32.MAX_VALUE) {\n    let val32    = <u32>value;\n    let decimals = decimalCount32(val32);\n    buffer = allocateUnsafeString(decimals);\n    utoa32_core(changetype<usize>(buffer), val32, decimals);\n  } else {\n    let decimals = decimalCount64(value);\n    buffer = allocateUnsafeString(decimals);\n    utoa64_core(changetype<usize>(buffer), value, decimals);\n  }\n  return buffer;\n}\n\nexport function itoa64(value: i64): String {\n  if (!value) return \"0\";\n\n  var sign = value < 0;\n  if (sign) value = -value;\n\n  var buffer: String;\n  if (<u64>value <= <u64>u32.MAX_VALUE) {\n    let val32    = <u32>value;\n    let decimals = decimalCount32(val32) + <u32>sign;\n    buffer = allocateUnsafeString(decimals);\n    utoa32_core(changetype<usize>(buffer), val32, decimals);\n  } else {\n    let decimals = decimalCount64(value) + <u32>sign;\n    buffer = allocateUnsafeString(decimals);\n    utoa64_core(changetype<usize>(buffer), value, decimals);\n  }\n  if (sign) store<u16>(changetype<usize>(buffer), CharCode.MINUS, STRING_HEADER_SIZE);\n\n  return buffer;\n}\n\nexport function itoa<T>(value: T): String {\n  if (!isInteger<T>()) {\n    assert(false); // unexpecteble non-integer generic type\n  } else {\n    if (isSigned<T>()) {\n      if (sizeof<T>() <= 4) {\n        return itoa32(<i32>value);\n      } else {\n        return itoa64(<i64>value);\n      }\n    } else {\n      if (sizeof<T>() <= 4) {\n        return utoa32(<u32>value);\n      } else {\n        return utoa64(<u64>value);\n      }\n    }\n  }\n}\n\n@lazy var _K: i32 = 0;\n// @lazy var _frc: u64 = 0;\n@lazy var _exp: i32 = 0;\n@lazy var _frc_minus: u64 = 0;\n@lazy var _frc_plus:  u64 = 0;\n@lazy var _frc_pow: u64 = 0;\n@lazy var _exp_pow: i32 = 0;\n\n@inline\nfunction umul64f(u: u64, v: u64): u64 {\n  var u0 = u & 0xFFFFFFFF;\n  var v0 = v & 0xFFFFFFFF;\n\n  var u1 = u >> 32;\n  var v1 = v >> 32;\n\n  var l = u0 * v0;\n  var t = u1 * v0 + (l >> 32);\n  var w = u0 * v1 + (t & 0xFFFFFFFF);\n\n  w += 0x7FFFFFFF; // rounding\n\n  t >>= 32;\n  w >>= 32;\n\n  return u1 * v1 + t + w;\n}\n\n@inline\nfunction umul64e(e1: i32, e2: i32): i32 {\n  return e1 + e2 + 64; // where 64 is significand size\n}\n\n@inline\nfunction normalizedBoundaries(f: u64, e: i32): void {\n  var frc = (f << 1) + 1;\n  var exp = e - 1;\n  var off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  var m = 1 + <i32>(f == 0x0010000000000000);\n\n  _frc_plus  = frc;\n  _frc_minus = ((f << m) - 1) << e - m - exp;\n  _exp = exp;\n}\n\n@inline\nfunction grisuRound(buffer: usize, len: i32, delta: u64, rest: u64, ten_kappa: u64, wp_w: u64): void {\n  var lastp = buffer + ((len - 1) << 1);\n  var digit = load<u16>(lastp, STRING_HEADER_SIZE);\n  while (\n    rest < wp_w &&\n    delta - rest >= ten_kappa && (\n      rest + ten_kappa < wp_w ||\n      wp_w - rest > rest + ten_kappa - wp_w\n    )\n  ) {\n    --digit;\n    rest += ten_kappa;\n  }\n  store<u16>(lastp, digit, STRING_HEADER_SIZE);\n}\n\n@inline\nfunction getCachedPower(minExp: i32): void {\n  const c = reinterpret<f64>(0x3FD34413509F79FE); // 1 / lg(10) = 0.30102999566398114\n  var dk = (-61 - minExp) * c + 347;\t            // dk must be positive, so can do ceiling in positive\n  var k = <i32>dk;\n      k += <i32>(k != dk); // conversion with ceil\n\n  var index = (k >> 3) + 1;\n  _K = 348 - (index << 3);\t// decimal exponent no need lookup table\n  var frcPowers = <ArrayBuffer>FRC_POWERS.buffer_;\n  var expPowers = <ArrayBuffer>EXP_POWERS.buffer_;\n  _frc_pow = LOAD<u64>(frcPowers, index);\n  _exp_pow = LOAD<i16,i32>(expPowers, index);\n}\n\n@inline\nfunction grisu2(value: f64, buffer: usize, sign: i32): i32 {\n\n  // frexp routine\n  var uv  = reinterpret<u64>(value);\n  var exp = <i32>((uv & 0x7FF0000000000000) >>> 52);\n  var sid = uv & 0x000FFFFFFFFFFFFF;\n  var frc = (<u64>(exp != 0) << 52) + sid;\n      exp = select<i32>(exp, 1, exp != 0) - (0x3FF + 52);\n\n  normalizedBoundaries(frc, exp);\n  getCachedPower(_exp);\n\n  // normalize\n  var off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  var frc_pow = _frc_pow;\n  var exp_pow = _exp_pow;\n\n  var w_frc = umul64f(frc, frc_pow);\n  var w_exp = umul64e(exp, exp_pow);\n\n  var wp_frc = umul64f(_frc_plus, frc_pow) - 1;\n  var wp_exp = umul64e(_exp,      exp_pow);\n\n  var wm_frc = umul64f(_frc_minus, frc_pow) + 1;\n  var delta  = wp_frc - wm_frc;\n\n  return genDigits(buffer, w_frc, w_exp, wp_frc, wp_exp, delta, sign);\n}\n\nfunction genDigits(buffer: usize, w_frc: u64, w_exp: i32, mp_frc: u64, mp_exp: i32, delta: u64, sign: i32): i32 {\n  var one_exp = -mp_exp;\n  var one_frc = (<u64>1) << one_exp;\n  var mask    = one_frc - 1;\n\n  var wp_w_frc = mp_frc - w_frc;\n  var wp_w_exp = mp_exp;\n\n  var p1 = <u32>(mp_frc >> one_exp);\n  var p2 = mp_frc & mask;\n\n  var kappa = <i32>decimalCount32(p1);\n  var len = sign;\n\n  var powers10 = <ArrayBuffer>POWERS10.buffer_;\n\n  while (kappa > 0) {\n    let d: u32;\n    switch (kappa) {\n      case 10: { d = p1 / 1000000000; p1 %= 1000000000; break; }\n      case  9: { d = p1 /  100000000; p1 %=  100000000; break; }\n      case  8: { d = p1 /   10000000; p1 %=   10000000; break; }\n      case  7: { d = p1 /    1000000; p1 %=    1000000; break; }\n      case  6: { d = p1 /     100000; p1 %=     100000; break; }\n      case  5: { d = p1 /      10000; p1 %=      10000; break; }\n      case  4: { d = p1 /       1000; p1 %=       1000; break; }\n      case  3: { d = p1 /        100; p1 %=        100; break; }\n      case  2: { d = p1 /         10; p1 %=         10; break; }\n      case  1: { d = p1;              p1 =           0; break; }\n      default: { d = 0; break; }\n    }\n\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d, STRING_HEADER_SIZE);\n\n    --kappa;\n    let tmp = ((<u64>p1) << one_exp) + p2;\n    if (tmp <= delta) {\n      _K += kappa;\n      grisuRound(buffer, len, delta, tmp, LOAD<u32,u64>(powers10, kappa) << one_exp, wp_w_frc);\n      return len;\n    }\n  }\n\n  while (1) {\n    p2    *= 10;\n    delta *= 10;\n\n    let d = p2 >> one_exp;\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d, STRING_HEADER_SIZE);\n\n    p2 &= mask;\n    --kappa;\n    if (p2 < delta) {\n      _K += kappa;\n      wp_w_frc *= LOAD<u32,u64>(powers10, -kappa);\n      grisuRound(buffer, len, delta, p2, one_frc, wp_w_frc);\n      return len;\n    }\n  }\n\n  return len;\n}\n\n@inline\nfunction genExponent(buffer: usize, k: i32): i32 {\n  var sign = k < 0;\n  if (sign) k = -k;\n  var decimals = decimalCount32(k) + 1;\n  utoa32_core(buffer, k, decimals);\n  store<u16>(buffer, <u16>select<u32>(CharCode.MINUS, CharCode.PLUS, sign), STRING_HEADER_SIZE);\n  return decimals;\n}\n\nfunction prettify(buffer: usize, length: i32, k: i32): i32 {\n  if (!k) {\n    store<u32>(buffer + (length << 1), CharCode.DOT | (CharCode._0 << 16), STRING_HEADER_SIZE);\n    return length + 2;\n  }\n\n  var kk = length + k;\n  if (length <= kk && kk <= 21) {\n    // 1234e7 -> 12340000000\n    for (let i = length; i < kk; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0, STRING_HEADER_SIZE);\n    }\n    store<u32>(buffer + (kk << 1), CharCode.DOT | (CharCode._0 << 16), STRING_HEADER_SIZE);\n    return kk + 2;\n  } else if (kk > 0 && kk <= 21) {\n    // 1234e-2 -> 12.34\n    let ptr = buffer + (kk << 1);\n    memory.copy(\n      ptr + STRING_HEADER_SIZE + 2,\n      ptr + STRING_HEADER_SIZE,\n      -k << 1\n    );\n    store<u16>(buffer + (kk << 1), CharCode.DOT, STRING_HEADER_SIZE);\n    return length + 1;\n  } else if (-6 < kk && kk <= 0) {\n    // 1234e-6 -> 0.001234\n    let offset = 2 - kk;\n    memory.copy(\n      buffer + STRING_HEADER_SIZE + (offset << 1),\n      buffer + STRING_HEADER_SIZE,\n      length << 1\n    );\n    store<u32>(buffer, CharCode._0 | (CharCode.DOT << 16), STRING_HEADER_SIZE);\n    for (let i = 2; i < offset; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0, STRING_HEADER_SIZE);\n    }\n    return length + offset;\n  } else if (length == 1) {\n    // 1e30\n    store<u16>(buffer, CharCode.e, STRING_HEADER_SIZE + 2);\n    length = genExponent(buffer + 4, kk - 1);\n    return length + 2;\n  } else {\n    let len = length << 1;\n    memory.copy(\n      buffer + STRING_HEADER_SIZE + 4,\n      buffer + STRING_HEADER_SIZE + 2,\n      len - 2\n    );\n    store<u16>(buffer,       CharCode.DOT, STRING_HEADER_SIZE + 2);\n    store<u16>(buffer + len, CharCode.e,   STRING_HEADER_SIZE + 2);\n    length += genExponent(buffer + len + 4, kk - 1);\n    return length + 2;\n  }\n}\n\nexport function dtoa_core(buffer: usize, value: f64): i32 {\n  var sign = <i32>(value < 0);\n  if (sign) {\n    value = -value;\n    store<u16>(buffer, CharCode.MINUS, STRING_HEADER_SIZE);\n  }\n  // assert(value > 0 && value <= 1.7976931348623157e308);\n  var len = grisu2(value, buffer, sign);\n      len = prettify(buffer + (sign << 1), len - sign, _K);\n  return len + sign;\n}\n\nexport function dtoa(value: f64): String {\n  if (value == 0) return \"0.0\";\n  if (!isFinite(value)) {\n    if (isNaN(value)) return \"NaN\";\n    return select<String>(\"-Infinity\", \"Infinity\", value < 0);\n  }\n  var buffer = allocateUnsafeString(MAX_DOUBLE_LENGTH);\n  var length = dtoa_core(changetype<usize>(buffer), value);\n  var result = buffer.substring(0, length);\n  freeUnsafeString(buffer);\n  return result;\n}\n\nexport function itoa_stream<T>(buffer: usize, offset: usize, value: T): u32 {\n  buffer += (offset << 1);\n  if (!value) {\n    store<u16>(buffer, CharCode._0, STRING_HEADER_SIZE);\n    return 1;\n  }\n  var decimals: u32 = 0;\n  if (isSigned<T>()) {\n    let sign = value < 0;\n    if (sign) value = -value;\n    if (sizeof<T>() <= 4) {\n      decimals = decimalCount32(value) + <u32>sign;\n      utoa32_core(buffer, value, decimals);\n    } else {\n      if (<u64>value <= <u64>u32.MAX_VALUE) {\n        let val32 = <u32>value;\n        decimals = decimalCount32(val32) + <u32>sign;\n        utoa32_core(buffer, val32, decimals);\n      } else {\n        decimals = decimalCount64(value) + <u32>sign;\n        utoa64_core(buffer, value, decimals);\n      }\n    }\n    if (sign) store<u16>(buffer, CharCode.MINUS, STRING_HEADER_SIZE);\n  } else {\n    if (sizeof<T>() <= 4) {\n      decimals = decimalCount32(value);\n      utoa32_core(buffer, value, decimals);\n    } else {\n      if (<u64>value <= <u64>u32.MAX_VALUE) {\n        let val32 = <u32>value;\n        decimals = decimalCount32(val32);\n        utoa32_core(buffer, val32, decimals);\n      } else {\n        decimals = decimalCount64(value);\n        utoa64_core(buffer, value, decimals);\n      }\n    }\n  }\n  return decimals;\n}\n\nexport function dtoa_stream(buffer: usize, offset: usize, value: f64): u32 {\n  buffer += (offset << 1);\n  if (value == 0.0) {\n    store<u16>(buffer, CharCode._0,  STRING_HEADER_SIZE + 0);\n    store<u16>(buffer, CharCode.DOT, STRING_HEADER_SIZE + 2);\n    store<u16>(buffer, CharCode._0,  STRING_HEADER_SIZE + 4);\n    return 3;\n  }\n  if (!isFinite(value)) {\n    if (isNaN(value)) {\n      store<u16>(buffer, CharCode.N, STRING_HEADER_SIZE + 0);\n      store<u16>(buffer, CharCode.a, STRING_HEADER_SIZE + 2);\n      store<u16>(buffer, CharCode.N, STRING_HEADER_SIZE + 4);\n      return 3;\n    } else {\n      let sign = <i32>(value < 0);\n      let len  = 8 + sign;\n      let source = changetype<usize>(select<String>(\"-Infinity\", \"Infinity\", sign));\n      memory.copy(buffer + STRING_HEADER_SIZE, source + STRING_HEADER_SIZE, len << 1);\n      return len;\n    }\n  }\n  return dtoa_core(buffer, value);\n}\n",
    "/* tslint:disable */\n\n@builtin @inline export const NaN: f64 = 0 / 0;\n@builtin @inline export const Infinity: f64 = 1 / 0;\n\n@builtin export declare function isInteger<T>(value?: T): bool;\n@builtin export declare function isFloat<T>(value?: T): bool;\n@builtin export declare function isSigned<T>(value?: T): bool;\n@builtin export declare function isReference<T>(value?: T): bool;\n@builtin export declare function isString<T>(value?: T): bool;\n@builtin export declare function isArray<T>(value?: T): bool;\n@builtin export declare function isArrayLike<T>(value?: T): bool;\n@builtin export declare function isFunction<T>(value?: T): bool;\n@builtin export declare function isNullable<T>(value?: T): bool;\n@builtin export declare function isDefined(expression: void): bool;\n@builtin export declare function isConstant(expression: void): bool;\n@builtin export declare function isManaged<T>(value?: T): bool;\n@inline export function isNaN<T>(value: T): bool { return value != value; }\n@inline export function isFinite<T>(value: T): bool { return value - value == 0; }\n\n@builtin export declare function clz<T>(value: T): T;\n@builtin export declare function ctz<T>(value: T): T;\n@builtin export declare function popcnt<T>(value: T): T;\n@builtin export declare function rotl<T>(value: T, shift: T): T;\n@builtin export declare function rotr<T>(value: T, shift: T): T;\n@builtin export declare function abs<T>(value: T): T;\n@builtin export declare function max<T>(left: T, right: T): T;\n@builtin export declare function min<T>(left: T, right: T): T;\n@builtin export declare function ceil<T>(value: T): T;\n@builtin export declare function floor<T>(value: T): T;\n@builtin export declare function copysign<T>(left: T, right: T): T;\n@builtin export declare function nearest<T>(value: T): T;\n@builtin export declare function reinterpret<T>(value: void): T;\n@builtin export declare function sqrt<T>(value: T): T;\n@builtin export declare function trunc<T>(value: T): T;\n@builtin export declare function load<T>(offset: usize, immOffset?: usize, immAlign?: usize): T;\n@builtin export declare function store<T>(offset: usize, value: void, immOffset?: usize, immAlign?: usize): void;\n@builtin export declare function sizeof<T>(): usize; // | u32 / u64\n@builtin export declare function alignof<T>(): usize; // | u32 / u64\n@builtin export declare function offsetof<T>(fieldName?: string): usize; // | u32 / u64\n@builtin export declare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\n@builtin export declare function unreachable(): void;\n@builtin export declare function changetype<T>(value: void): T;\n@builtin export declare function assert<T>(isTrueish: T, message?: string): T;\n@builtin export declare function unchecked<T>(expr: T): T;\n@builtin export declare function call_indirect<T>(target: void, ...args: void[]): T;\n@builtin export declare function instantiate<T>(...args: void[]): T;\n\nexport namespace atomic {\n  @builtin export declare function load<T>(offset: usize, immOffset?: usize): T;\n  @builtin export declare function store<T>(offset: usize, value: T, immOffset?: usize): void;\n  @builtin export declare function add<T>(ptr: usize, value: T, immOffset?: usize): T;\n  @builtin export declare function sub<T>(ptr: usize, value: T, immOffset?: usize): T;\n  @builtin export declare function and<T>(ptr: usize, value: T, immOffset?: usize): T;\n  @builtin export declare function or<T>(ptr: usize, value: T, immOffset?: usize): T;\n  @builtin export declare function xor<T>(ptr: usize, value: T, immOffset?: usize): T;\n  @builtin export declare function xchg<T>(ptr: usize, value: T, immOffset?: usize): T;\n  @builtin export declare function cmpxchg<T>(ptr: usize, expected: T, replacement: T, immOffset?: usize): T;\n  @builtin export declare function wait<T>(ptr: usize, expected: T, timeout: i64): AtomicWaitResult;\n  @builtin export declare function notify(ptr: usize, count: i32): i32;\n}\n\n@lazy export const enum AtomicWaitResult {\n  OK = 0,\n  NOT_EQUAL = 1,\n  TIMED_OUT = 2\n}\n\n@builtin export declare function i8(value: void): i8;\nexport namespace i8 {\n  @lazy export const MIN_VALUE: i8 = -128;\n  @lazy export const MAX_VALUE: i8 =  127;\n}\n\n@builtin export declare function i16(value: void): i16;\nexport namespace i16 {\n  @lazy export const MIN_VALUE: i16 = -32768;\n  @lazy export const MAX_VALUE: i16 =  32767;\n}\n\n@builtin export declare function i32(value: void): i32;\nexport namespace i32 {\n  @lazy export const MIN_VALUE: i32 = -2147483648;\n  @lazy export const MAX_VALUE: i32 =  2147483647;\n  @builtin export declare function clz(value: i32): i32;\n  @builtin export declare function ctz(value: i32): i32;\n  @builtin export declare function popcnt(value: i32): i32;\n  @builtin export declare function rotl(value: i32, shift: i32): i32;\n  @builtin export declare function rotr(value: i32, shift: i32): i32;\n  @builtin export declare function reinterpret_f32(value: f32): i32;\n  @builtin export declare function load8_s(offset: usize, immOffset?: usize, immAlign?: usize): i32;\n  @builtin export declare function load8_u(offset: usize, immOffset?: usize, immAlign?: usize): i32;\n  @builtin export declare function load16_s(offset: usize, immOffset?: usize, immAlign?: usize): i32;\n  @builtin export declare function load16_u(offset: usize, immOffset?: usize, immAlign?: usize): i32;\n  @builtin export declare function load(offset: usize, immOffset?: usize, immAlign?: usize): i32;\n  @builtin export declare function store8(offset: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n  @builtin export declare function store16(offset: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n  @builtin export declare function store(offset: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n  \n  export namespace atomic {\n    @builtin export declare function load8_u(offset: usize, immOffset?: usize): i32;\n    @builtin export declare function load16_u(offset: usize, immOffset?: usize): i32;\n    @builtin export declare function load(offset: usize, immOffset?: usize): i32;\n    @builtin export declare function store8(offset: usize, value: i32, immOffset?: usize): void;\n    @builtin export declare function store16(offset: usize, value: i32, immOffset?: usize): void;\n    @builtin export declare function store(offset: usize, value: i32, immOffset?: usize): void;\n    @builtin export declare function wait(ptr: usize, expected: i32, timeout: i64): AtomicWaitResult;\n\n    export namespace rmw8 {\n      @builtin export declare function add_u(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function sub_u(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function and_u(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function or_u(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function xor_u(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function xchg_u(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function cmpxchg_u(offset: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n    export namespace rmw16 {\n      @builtin export declare function add_u(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function sub_u(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function and_u(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function or_u(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function xor_u(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function xchg_u(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function cmpxchg_u(offset: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n    export namespace rmw {\n      @builtin export declare function add(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function sub(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function and(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function or(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function xor(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function xchg(offset: usize, value: i32, immOffset?: usize): i32;\n      @builtin export declare function cmpxchg(offset: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n  }\n}\n\n@builtin export declare function i64(value: void): i64;\nexport namespace i64 {\n  @lazy export const MIN_VALUE: i64 = -9223372036854775808;\n  @lazy export const MAX_VALUE: i64 =  9223372036854775807;\n  @builtin export declare function clz(value: i64): i64;\n  @builtin export declare function ctz(value: i64): i64;\n  @builtin export declare function load8_s(offset: usize, immOffset?: usize, immAlign?: usize): i64;\n  @builtin export declare function load8_u(offset: usize, immOffset?: usize, immAlign?: usize): i64;\n  @builtin export declare function load16_s(offset: usize, immOffset?: usize, immAlign?: usize): i64;\n  @builtin export declare function load16_u(offset: usize, immOffset?: usize, immAlign?: usize): i64;\n  @builtin export declare function load32_s(offset: usize, immOffset?: usize, immAlign?: usize): i64;\n  @builtin export declare function load32_u(offset: usize, immOffset?: usize, immAlign?: usize): i64;\n  @builtin export declare function load(offset: usize, immOffset?: usize): i64;\n  @builtin export declare function popcnt(value: i64): i64;\n  @builtin export declare function rotl(value: i64, shift: i64): i64;\n  @builtin export declare function rotr(value: i64, shift: i64): i64;\n  @builtin export declare function reinterpret_f64(value: f64): i64;\n  @builtin export declare function store8(offset: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n  @builtin export declare function store16(offset: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n  @builtin export declare function store32(offset: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n  @builtin export declare function store(offset: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  export namespace atomic {\n    @builtin export declare function load8_u(offset: usize, immOffset?: usize): i64;\n    @builtin export declare function load16_u(offset: usize, immOffset?: usize): i64;\n    @builtin export declare function load32_u(offset: usize, immOffset?: usize): i64;\n    @builtin export declare function load(offset: usize, immOffset?: usize): i64;\n    @builtin export declare function store8(offset: usize, value: i64, immOffset?: usize): void;\n    @builtin export declare function store16(offset: usize, value: i64, immOffset?: usize): void;\n    @builtin export declare function store32(offset: usize, value: i64, immOffset?: usize): void;\n    @builtin export declare function store(offset: usize, value: i64, immOffset?: usize): void;\n    @builtin export declare function wait(ptr: usize, expected: i64, timeout: i64): AtomicWaitResult;\n\n    export namespace rmw8 {\n      @builtin export declare function add_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function sub_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function and_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function or_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function xor_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function xchg_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function cmpxchg_u(offset: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n    export namespace rmw16 {\n      @builtin export declare function add_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function sub_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function and_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function or_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function xor_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function xchg_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function cmpxchg_u(offset: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n    export namespace rmw32 {\n      @builtin export declare function add_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function sub_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function and_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function or_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function xor_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function xchg_u(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function cmpxchg_u(offset: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n    export namespace rmw {\n      @builtin export declare function add(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function sub(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function and(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function or(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function xor(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function xchg(offset: usize, value: i64, immOffset?: usize): i64;\n      @builtin export declare function cmpxchg(offset: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n  }\n}\n\n@builtin export declare function isize(value: void): isize;\nexport namespace isize {\n  @lazy export const MIN_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? -2147483648\n    : <isize>-9223372036854775808;\n  @lazy export const MAX_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? 2147483647\n    : <isize>9223372036854775807;\n}\n\n@builtin export declare function u8(value: void): u8;\nexport namespace u8 {\n  @lazy export const MIN_VALUE: u8 = 0;\n  @lazy export const MAX_VALUE: u8 = 255;\n}\n\n@builtin export declare function u16(value: void): u16;\nexport namespace u16 {\n  @lazy export const MIN_VALUE: u16 = 0;\n  @lazy export const MAX_VALUE: u16 = 65535;\n}\n\n@builtin export declare function u32(value: void): u32;\nexport namespace u32 {\n  @lazy export const MIN_VALUE: u32 = 0;\n  @lazy export const MAX_VALUE: u32 = 4294967295;\n}\n\n@builtin export declare function u64(value: void): u64;\nexport namespace u64 {\n  @lazy export const MIN_VALUE: u64 = 0;\n  @lazy export const MAX_VALUE: u64 = 18446744073709551615;\n}\n\n@builtin export declare function usize(value: void): usize;\nexport namespace usize {\n  @lazy export const MIN_VALUE: usize = 0;\n  @lazy export const MAX_VALUE: usize = sizeof<u32>() == sizeof<usize>()\n    ? 4294967295\n    : <usize>18446744073709551615;\n}\n\n@builtin export declare function bool(value: void): bool;\nexport namespace bool {\n  @lazy export const MIN_VALUE: bool = false;\n  @lazy export const MAX_VALUE: bool = true;\n}\n\n@builtin export declare function f32(value: void): f32;\nexport namespace f32 {\n  @lazy export const EPSILON = reinterpret<f32>(0x34000000); // 0x1p-23f\n  @lazy export const MIN_VALUE = reinterpret<f32>(0x00000001); // 0x0.000001p+0f\n  @lazy export const MAX_VALUE = reinterpret<f32>(0x7F7FFFFF); // 0x1.fffffep+127f\n  @lazy export const MIN_NORMAL_VALUE = reinterpret<f32>(0x00800000); // 0x1p-126f\n  @lazy export const MIN_SAFE_INTEGER: f32 = -16777215;\n  @lazy export const MAX_SAFE_INTEGER: f32 =  16777215;\n  @builtin export declare function abs(value: f32): f32;\n  @builtin export declare function ceil(value: f32): f32;\n  @builtin export declare function copysign(x: f32, y: f32): f32;\n  @builtin export declare function floor(value: f32): f32;\n  @builtin export declare function load(offset: usize, immOffset?: usize, immAlign?: usize): f32;\n  @builtin export declare function max(left: f32, right: f32): f32;\n  @builtin export declare function min(left: f32, right: f32): f32;\n  @builtin export declare function nearest(value: f32): f32;\n  @builtin export declare function reinterpret_i32(value: i32): f32;\n  @builtin export declare function sqrt(value: f32): f32;\n  @builtin export declare function store(offset: usize, value: f32, immOffset?: usize, immAlign?: usize): void;\n  @builtin export declare function trunc(value: f32): f32;\n}\n\n@builtin export declare function f64(value: void): f64;\nexport namespace f64 {\n  @lazy export const EPSILON = reinterpret<f64>(0x3CB0000000000000); // 0x1p-52\n  @lazy export const MIN_VALUE = reinterpret<f64>(0x0000000000000001); // 0x0.0000000000001p+0\n  @lazy export const MAX_VALUE = reinterpret<f64>(0x7FEFFFFFFFFFFFFF); // 0x1.fffffffffffffp+1023\n  @lazy export const MIN_NORMAL_VALUE = reinterpret<f64>(0x0010000000000000); // 0x1p-1022\n  @lazy export const MIN_SAFE_INTEGER: f64 = -9007199254740991;\n  @lazy export const MAX_SAFE_INTEGER: f64 =  9007199254740991;\n  @builtin export declare function abs(value: f64): f64;\n  @builtin export declare function ceil(value: f64): f64;\n  @builtin export declare function copysign(x: f64, y: f64): f64;\n  @builtin export declare function floor(value: f64): f64;\n  @builtin export declare function load(offset: usize, immOffset?: usize, immAlign?: usize): f64;\n  @builtin export declare function max(left: f64, right: f64): f64;\n  @builtin export declare function min(left: f64, right: f64): f64;\n  @builtin export declare function nearest(value: f64): f64;\n  @builtin export declare function reinterpret_i64(value: i64): f64;\n  @builtin export declare function sqrt(value: f64): f64;\n  @builtin export declare function store(offset: usize, value: f64, immOffset?: usize, immAlign?: usize): void;\n  @builtin export declare function trunc(value: f64): f64;\n}\n\n@builtin export declare function v128(a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8, i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8): v128;\nexport namespace v128 {\n  @builtin export declare function splat<T>(x: T): v128;\n  @builtin export declare function extract_lane<T>(x: v128, idx: u8): T;\n  @builtin export declare function replace_lane<T>(x: v128, idx: u8, value: T): v128;\n  @builtin export declare function shuffle<T>(a: v128, b: v128, ...lanes: u8[]): v128;\n  @builtin export declare function load(offset: usize, immOffset?: usize, immAlign?: usize): v128;\n  @builtin export declare function store(offset: usize, value: v128, immOffset?: usize, immAlign?: usize): void;\n  @builtin export declare function add<T>(a: v128, b: v128): v128;\n  @builtin export declare function sub<T>(a: v128, b: v128): v128;\n  @builtin export declare function mul<T>(a: v128, b: v128): v128; // except i64\n  @builtin export declare function div<T>(a: v128, b: v128): v128; // f32, f64 only\n  @builtin export declare function neg<T>(a: v128): v128;\n  @builtin export declare function add_saturate<T>(a: v128, b: v128): v128;\n  @builtin export declare function sub_saturate<T>(a: v128, b: v128): v128;\n  @builtin export declare function shl<T>(a: v128, b: i32): v128;\n  @builtin export declare function shr<T>(a: v128, b: i32): v128;\n  @builtin export declare function and(a: v128, b: v128): v128;\n  @builtin export declare function or(a: v128, b: v128): v128;\n  @builtin export declare function xor(a: v128, b: v128): v128;\n  @builtin export declare function not(a: v128): v128;\n  @builtin export declare function bitselect(v1: v128, v2: v128, c: v128): v128;\n  @builtin export declare function any_true<T>(a: v128): bool;\n  @builtin export declare function all_true<T>(a: v128): bool;\n  @builtin export declare function min<T>(a: v128, b: v128): v128; // f32, f64 only\n  @builtin export declare function max<T>(a: v128, b: v128): v128; // f32, f64 only\n  @builtin export declare function abs<T>(a: v128): v128; // f32, f64 only\n  @builtin export declare function sqrt<T>(a: v128): v128; // f32, f64 only\n  @builtin export declare function eq<T>(a: v128, b: v128): v128;\n  @builtin export declare function ne<T>(a: v128, b: v128): v128;\n  @builtin export declare function lt<T>(a: v128, b: v128): v128;\n  @builtin export declare function le<T>(a: v128, b: v128): v128;\n  @builtin export declare function gt<T>(a: v128, b: v128): v128;\n  @builtin export declare function ge<T>(a: v128, b: v128): v128;\n  @builtin export declare function convert<T>(a: v128): v128;\n  @builtin export declare function trunc<T>(a: v128): v128;\n}\n\n@builtin export declare function i8x16(a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8, i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8): v128;\nexport namespace i8x16 {\n  @builtin export declare function splat(x: i8): v128;\n  @builtin export declare function extract_lane_s(x: v128, idx: u8): i8;\n  @builtin export declare function extract_lane_u(x: v128, idx: u8): u8;\n  @builtin export declare function replace_lane(x: v128, idx: u8, value: i8): v128;\n  @builtin export declare function add(a: v128, b: v128): v128;\n  @builtin export declare function sub(a: v128, b: v128): v128;\n  @builtin export declare function mul(a: v128, b: v128): v128;\n  @builtin export declare function neg(a: v128): v128;\n  @builtin export declare function add_saturate_s(a: v128, b: v128): v128;\n  @builtin export declare function add_saturate_u(a: v128, b: v128): v128;\n  @builtin export declare function sub_saturate_s(a: v128, b: v128): v128;\n  @builtin export declare function sub_saturate_u(a: v128, b: v128): v128;\n  @builtin export declare function shl(a: v128, b: i32): v128;\n  @builtin export declare function shr_s(a: v128, b: i32): v128;\n  @builtin export declare function shr_u(a: v128, b: i32): v128;\n  @builtin export declare function any_true(a: v128): bool;\n  @builtin export declare function all_true(a: v128): bool;\n  @builtin export declare function eq(a: v128, b: v128): v128;\n  @builtin export declare function ne(a: v128, b: v128): v128;\n  @builtin export declare function lt_s(a: v128, b: v128): v128;\n  @builtin export declare function lt_u(a: v128, b: v128): v128;\n  @builtin export declare function le_s(a: v128, b: v128): v128;\n  @builtin export declare function le_u(a: v128, b: v128): v128;\n  @builtin export declare function gt_s(a: v128, b: v128): v128;\n  @builtin export declare function gt_u(a: v128, b: v128): v128;\n  @builtin export declare function ge_s(a: v128, b: v128): v128;\n  @builtin export declare function ge_u(a: v128, b: v128): v128;\n}\n\n@builtin export declare function i16x8(a: i16, b: i16, c: i16, d: i16, e: i16, f: i16, g: i16, h: i16): v128;\nexport namespace i16x8 {\n  @builtin export declare function splat(x: i16): v128;\n  @builtin export declare function extract_lane_s(x: v128, idx: u8): i16;\n  @builtin export declare function extract_lane_u(x: v128, idx: u8): u16;\n  @builtin export declare function replace_lane(x: v128, idx: u8, value: i16): v128;\n  @builtin export declare function add(a: v128, b: v128): v128;\n  @builtin export declare function sub(a: v128, b: v128): v128;\n  @builtin export declare function mul(a: v128, b: v128): v128;\n  @builtin export declare function neg(a: v128): v128;\n  @builtin export declare function add_saturate_s(a: v128, b: v128): v128;\n  @builtin export declare function add_saturate_u(a: v128, b: v128): v128;\n  @builtin export declare function sub_saturate_s(a: v128, b: v128): v128;\n  @builtin export declare function sub_saturate_u(a: v128, b: v128): v128;\n  @builtin export declare function shl(a: v128, b: i32): v128;\n  @builtin export declare function shr_s(a: v128, b: i32): v128;\n  @builtin export declare function shr_u(a: v128, b: i32): v128;\n  @builtin export declare function any_true(a: v128): bool;\n  @builtin export declare function all_true(a: v128): bool;\n  @builtin export declare function eq(a: v128, b: v128): v128;\n  @builtin export declare function ne(a: v128, b: v128): v128;\n  @builtin export declare function lt_s(a: v128, b: v128): v128;\n  @builtin export declare function lt_u(a: v128, b: v128): v128;\n  @builtin export declare function le_s(a: v128, b: v128): v128;\n  @builtin export declare function le_u(a: v128, b: v128): v128;\n  @builtin export declare function gt_s(a: v128, b: v128): v128;\n  @builtin export declare function gt_u(a: v128, b: v128): v128;\n  @builtin export declare function ge_s(a: v128, b: v128): v128;\n  @builtin export declare function ge_u(a: v128, b: v128): v128;\n}\n\n@builtin export declare function i32x4(a: i32, b: i32, c: i32, d: i32): v128;\nexport namespace i32x4 {\n  @builtin export declare function splat(x: i32): v128;\n  @builtin export declare function extract_lane(x: v128, idx: u8): i32;\n  @builtin export declare function replace_lane(x: v128, idx: u8, value: i32): v128;\n  @builtin export declare function add(a: v128, b: v128): v128;\n  @builtin export declare function sub(a: v128, b: v128): v128;\n  @builtin export declare function mul(a: v128, b: v128): v128;\n  @builtin export declare function neg(a: v128): v128;\n  @builtin export declare function shl(a: v128, b: i32): v128;\n  @builtin export declare function shr_s(a: v128, b: i32): v128;\n  @builtin export declare function shr_u(a: v128, b: i32): v128;\n  @builtin export declare function any_true(a: v128): bool;\n  @builtin export declare function all_true(a: v128): bool;\n  @builtin export declare function eq(a: v128, b: v128): v128;\n  @builtin export declare function ne(a: v128, b: v128): v128;\n  @builtin export declare function lt_s(a: v128, b: v128): v128;\n  @builtin export declare function lt_u(a: v128, b: v128): v128;\n  @builtin export declare function le_s(a: v128, b: v128): v128;\n  @builtin export declare function le_u(a: v128, b: v128): v128;\n  @builtin export declare function gt_s(a: v128, b: v128): v128;\n  @builtin export declare function gt_u(a: v128, b: v128): v128;\n  @builtin export declare function ge_s(a: v128, b: v128): v128;\n  @builtin export declare function ge_u(a: v128, b: v128): v128;\n  @builtin export declare function trunc_s_f32x4_sat(a: v128): v128;\n  @builtin export declare function trunc_u_f32x4_sat(a: v128): v128;\n}\n\n@builtin export declare function i64x2(a: i64, b: i64): v128;\nexport namespace i64x2 {\n  @builtin export declare function splat(x: i64): v128;\n  @builtin export declare function extract_lane(x: v128, idx: u8): i64;\n  @builtin export declare function replace_lane(x: v128, idx: u8, value: i64): v128;\n  @builtin export declare function add(a: v128, b: v128): v128;\n  @builtin export declare function sub(a: v128, b: v128): v128;\n  @builtin export declare function mul(a: v128, b: v128): v128;\n  @builtin export declare function neg(a: v128): v128;\n  @builtin export declare function shl(a: v128, b: i32): v128;\n  @builtin export declare function shr_s(a: v128, b: i32): v128;\n  @builtin export declare function shr_u(a: v128, b: i32): v128;\n  @builtin export declare function any_true(a: v128): bool;\n  @builtin export declare function all_true(a: v128): bool;\n  @builtin export declare function trunc_s_f64x2_sat(a: v128): v128;\n  @builtin export declare function trunc_u_f64x2_sat(a: v128): v128;\n}\n\n@builtin export declare function f32x4(a: f32, b: f32, c: f32, d: f32): v128;\nexport namespace f32x4 {\n  @builtin export declare function splat(x: f32): v128;\n  @builtin export declare function extract_lane(x: v128, idx: u8): f32;\n  @builtin export declare function replace_lane(x: v128, idx: u8, value: f32): v128;\n  @builtin export declare function add(a: v128, b: v128): v128;\n  @builtin export declare function sub(a: v128, b: v128): v128;\n  @builtin export declare function mul(a: v128, b: v128): v128;\n  @builtin export declare function div(a: v128, b: v128): v128;\n  @builtin export declare function neg(a: v128): v128;\n  @builtin export declare function min(a: v128, b: v128): v128;\n  @builtin export declare function max(a: v128, b: v128): v128;\n  @builtin export declare function abs(a: v128): v128;\n  @builtin export declare function sqrt(a: v128): v128;\n  @builtin export declare function eq(a: v128, b: v128): v128;\n  @builtin export declare function ne(a: v128, b: v128): v128;\n  @builtin export declare function lt(a: v128, b: v128): v128;\n  @builtin export declare function le(a: v128, b: v128): v128;\n  @builtin export declare function gt(a: v128, b: v128): v128;\n  @builtin export declare function ge(a: v128, b: v128): v128;\n  @builtin export declare function convert_s_i32x4(a: v128): v128;\n  @builtin export declare function convert_u_i32x4(a: v128): v128;\n}\n\n@builtin export declare function f64x2(a: f64, b: f64): v128;\nexport namespace f64x2 {\n  @builtin export declare function splat(x: f64): v128;\n  @builtin export declare function extract_lane(x: v128, idx: u8): f64;\n  @builtin export declare function replace_lane(x: v128, idx: u8, value: f64): v128;\n  @builtin export declare function add(a: v128, b: v128): v128;\n  @builtin export declare function sub(a: v128, b: v128): v128;\n  @builtin export declare function mul(a: v128, b: v128): v128;\n  @builtin export declare function div(a: v128, b: v128): v128;\n  @builtin export declare function neg(a: v128): v128;\n  @builtin export declare function min(a: v128, b: v128): v128;\n  @builtin export declare function max(a: v128, b: v128): v128;\n  @builtin export declare function abs(a: v128): v128;\n  @builtin export declare function sqrt(a: v128): v128;\n  @builtin export declare function eq(a: v128, b: v128): v128;\n  @builtin export declare function ne(a: v128, b: v128): v128;\n  @builtin export declare function lt(a: v128, b: v128): v128;\n  @builtin export declare function le(a: v128, b: v128): v128;\n  @builtin export declare function gt(a: v128, b: v128): v128;\n  @builtin export declare function ge(a: v128, b: v128): v128;\n  @builtin export declare function convert_s_i64x2(a: v128): v128;\n  @builtin export declare function convert_u_i64x2(a: v128): v128;\n}\n\nexport namespace v8x16 {\n  @builtin export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8, l8: u8, l9: u8, l10: u8, l11: u8, l12: u8, l13: u8, l14: u8, l15: u8): v128;\n}\n\n@builtin export declare function start(): void;\n",
    "import {\n  MAX_BLENGTH,\n  HEADER_SIZE,\n  allocateUnsafe,\n  reallocateUnsafe,\n  LOAD,\n  STORE\n} from \"./internal/arraybuffer\";\n\nimport {\n  allocateUnsafe as allocateUnsafeString,\n  freeUnsafe as freeUnsafeString,\n  copyUnsafe as copyUnsafeString\n} from \"./internal/string\";\n\nimport {\n  COMPARATOR,\n  SORT\n} from \"./internal/sort\";\n\nimport {\n  itoa,\n  dtoa,\n  itoa_stream,\n  dtoa_stream,\n  MAX_DOUBLE_LENGTH\n} from \"./internal/number\";\n\nimport {\n  isArray as builtin_isArray\n} from \"./builtins\";\n\nexport class Array<T> {\n  [key: number]: T; // compatibility only\n\n  /* @internal */ buffer_: ArrayBuffer;\n  /* @internal */ length_: i32;\n\n  @inline static isArray<U>(value: U): bool {\n    return builtin_isArray(value) && value !== null;\n  }\n\n  constructor(length: i32 = 0) {\n    const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\n    if (<u32>length > <u32>MAX_LENGTH) throw new RangeError(\"Invalid array length\");\n    var byteLength = length << alignof<T>();\n    var buffer = allocateUnsafe(byteLength);\n    this.buffer_ = buffer;\n    this.length_ = length;\n    memory.fill(\n      changetype<usize>(buffer) + HEADER_SIZE,\n      0,\n      <usize>byteLength\n    );\n  }\n\n  @inline\n  get length(): i32 {\n    return this.length_;\n  }\n\n  set length(length: i32) {\n    var buffer = this.buffer_;\n    var capacity = buffer.byteLength >>> alignof<T>();\n    if (<u32>length > <u32>capacity) {\n      const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\n      if (<u32>length > <u32>MAX_LENGTH) throw new RangeError(\"Invalid array length\");\n      buffer = reallocateUnsafe(buffer, length << alignof<T>());\n      this.buffer_ = buffer;\n    }\n    this.length_ = length;\n  }\n\n  every(callbackfn: (element: T, index: i32, array: Array<T>) => bool): bool {\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      if (!callbackfn(LOAD<T>(this.buffer_, index), index, this)) return false;\n    }\n    return true;\n  }\n\n  findIndex(predicate: (element: T, index: i32, array: Array<T>) => bool): i32 {\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      if (predicate(LOAD<T>(this.buffer_, index), index, this)) return index;\n    }\n    return -1;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): T {\n    var buffer = this.buffer_;\n    return <u32>index < <u32>(buffer.byteLength >>> alignof<T>())\n      ? LOAD<T>(buffer, index)\n      : <T>unreachable();\n  }\n\n  @operator(\"{}\")\n  private __unchecked_get(index: i32): T {\n    return LOAD<T>(this.buffer_, index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: T): void {\n    var buffer = this.buffer_;\n    var capacity = buffer.byteLength >>> alignof<T>();\n    if (<u32>index >= <u32>capacity) {\n      const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\n      if (<u32>index >= <u32>MAX_LENGTH) throw new Error(\"Invalid array length\");\n      buffer = reallocateUnsafe(buffer, (index + 1) << alignof<T>());\n      this.buffer_ = buffer;\n      this.length_ = index + 1;\n    }\n    STORE<T>(buffer, index, value);\n    if (isManaged<T>()) __gc_link(changetype<usize>(this), changetype<usize>(value)); // tslint:disable-line\n  }\n\n  @operator(\"{}=\")\n  private __unchecked_set(index: i32, value: T): void {\n    STORE<T>(this.buffer_, index, value);\n    if (isManaged<T>()) __gc_link(changetype<usize>(this), changetype<usize>(value)); // tslint:disable-line\n  }\n\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): this {\n    var buffer = this.buffer_;\n    var len    = this.length_;\n\n    start = start < 0 ? max(len + start, 0) : min(start, len);\n    end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n\n    if (sizeof<T>() == 1) {\n      if (start < end) {\n        memory.fill(\n          changetype<usize>(buffer) + start + HEADER_SIZE,\n          <u8>value,\n          <usize>(end - start)\n        );\n      }\n    } else {\n      for (; start < end; ++start) {\n        STORE<T>(buffer, start, value);\n      }\n    }\n    return this;\n  }\n\n  @inline\n  includes(searchElement: T, fromIndex: i32 = 0): bool {\n    return this.indexOf(searchElement, fromIndex) >= 0;\n  }\n\n  indexOf(searchElement: T, fromIndex: i32 = 0): i32 {\n    var length = this.length_;\n    if (length == 0 || fromIndex >= length) return -1;\n    if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n    var buffer = this.buffer_;\n    while (fromIndex < length) {\n      if (LOAD<T>(buffer, fromIndex) == searchElement) return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(searchElement: T, fromIndex: i32 = this.length_): i32 {\n    var length = this.length_;\n    if (length == 0) return -1;\n    if (fromIndex < 0) fromIndex = length + fromIndex; // no need to clamp\n    else if (fromIndex >= length) fromIndex = length - 1;\n    var buffer = this.buffer_;\n    while (fromIndex >= 0) {                           // ^\n      if (LOAD<T>(buffer, fromIndex) == searchElement) return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  push(element: T): i32 {\n    var length = this.length_;\n    var buffer = this.buffer_;\n    var capacity = buffer.byteLength >>> alignof<T>();\n    var newLength = length + 1; // safe only if length is checked\n    if (<u32>length >= <u32>capacity) {\n      const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\n      if (<u32>length >= <u32>MAX_LENGTH) throw new Error(\"Invalid array length\");\n      buffer = reallocateUnsafe(buffer, newLength << alignof<T>());\n      this.buffer_ = buffer;\n    }\n    this.length_ = newLength;\n    STORE<T>(buffer, length, element);\n    if (isManaged<T>()) __gc_link(changetype<usize>(this), changetype<usize>(element)); // tslint:disable-line\n    return newLength;\n  }\n\n  concat(items: Array<T>): Array<T> {\n    var thisLen = this.length_;\n    var otherLen = select(0, items.length_, items === null);\n    var outLen = thisLen + otherLen;\n    var out = new Array<T>(outLen);\n\n    if (thisLen) {\n      memory.copy(\n        changetype<usize>(out.buffer_)  + HEADER_SIZE,\n        changetype<usize>(this.buffer_) + HEADER_SIZE,\n        <usize>thisLen << alignof<T>()\n      );\n    }\n    if (otherLen) {\n      memory.copy(\n        changetype<usize>(out.buffer_)   + HEADER_SIZE + (<usize>thisLen << alignof<T>()),\n        changetype<usize>(items.buffer_) + HEADER_SIZE,\n        <usize>otherLen << alignof<T>()\n      );\n    }\n    return out;\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): this {\n    var buffer = this.buffer_;\n    var len = this.length_;\n\n        end   = min<i32>(end, len);\n    var to    = target < 0 ? max(len + target, 0) : min(target, len);\n    var from  = start < 0 ? max(len + start, 0) : min(start, len);\n    var last  = end < 0 ? max(len + end, 0) : min(end, len);\n    var count = min(last - from, len - to);\n\n    if (from < to && to < (from + count)) {\n      from += count - 1;\n      to   += count - 1;\n      while (count) {\n        STORE<T>(buffer, to, LOAD<T>(buffer, from));\n        --from, --to, --count;\n      }\n    } else {\n      memory.copy(\n        changetype<usize>(buffer) + HEADER_SIZE + (<usize>to << alignof<T>()),\n        changetype<usize>(buffer) + HEADER_SIZE + (<usize>from << alignof<T>()),\n        <usize>count << alignof<T>()\n      );\n    }\n    return this;\n  }\n\n  pop(): T {\n    var length = this.length_;\n    if (length < 1) throw new RangeError(\"Array is empty\");\n    var element = LOAD<T>(this.buffer_, --length);\n    this.length_ = length;\n    return element;\n  }\n\n  forEach(callbackfn: (value: T, index: i32, array: Array<T>) => void): void {\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      callbackfn(LOAD<T>(this.buffer_, index), index, this);\n    }\n  }\n\n  map<U>(callbackfn: (value: T, index: i32, array: Array<T>) => U): Array<U> {\n    var length = this.length_;\n    var result = new Array<U>(length);\n    var buffer = result.buffer_;\n    for (let index = 0; index < min(length, this.length_); ++index) {\n      STORE<U>(buffer, index, callbackfn(LOAD<T>(this.buffer_, index), index, this));\n    }\n    return result;\n  }\n\n  filter(callbackfn: (value: T, index: i32, array: Array<T>) => bool): Array<T> {\n    var result = new Array<T>();\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      let value = LOAD<T>(this.buffer_, index);\n      if (callbackfn(value, index, this)) result.push(value);\n    }\n    return result;\n  }\n\n  reduce<U>(\n    callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    var accum = initialValue;\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      accum = callbackfn(accum, LOAD<T>(this.buffer_, index), index, this);\n    }\n    return accum;\n  }\n\n  reduceRight<U>(\n    callbackfn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    var accum = initialValue;\n    for (let index = this.length_ - 1; index >= 0; --index) {\n      accum = callbackfn(accum, LOAD<T>(this.buffer_, index), index, this);\n    }\n    return accum;\n  }\n\n  shift(): T {\n    var length = this.length_;\n    if (length < 1) throw new RangeError(\"Array is empty\");\n    var buffer = this.buffer_;\n    var element = LOAD<T>(buffer, 0);\n    var lastIndex = length - 1;\n    memory.copy(\n      changetype<usize>(buffer) + HEADER_SIZE,\n      changetype<usize>(buffer) + HEADER_SIZE + sizeof<T>(),\n      <usize>lastIndex << alignof<T>()\n    );\n    STORE<T>(buffer, lastIndex, <T>null);\n    this.length_ = lastIndex;\n    return element;\n  }\n\n  some(callbackfn: (element: T, index: i32, array: Array<T>) => bool): bool {\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      if (callbackfn(LOAD<T>(this.buffer_, index), index, this)) return true;\n    }\n    return false;\n  }\n\n  unshift(element: T): i32 {\n    var buffer = this.buffer_;\n    var capacity = buffer.byteLength >>> alignof<T>();\n    var length = this.length_;\n    var newLength = length + 1; // safe only if length is checked\n    if (<u32>length >= <u32>capacity) {\n      const MAX_LENGTH = MAX_BLENGTH >>> alignof<T>();\n      if (<u32>length >= <u32>MAX_LENGTH) throw new Error(\"Invalid array length\");\n      buffer = reallocateUnsafe(buffer, newLength << alignof<T>());\n      capacity = buffer.byteLength >>> alignof<T>();\n      this.buffer_ = buffer;\n    }\n    memory.copy(\n      changetype<usize>(buffer) + HEADER_SIZE + sizeof<T>(),\n      changetype<usize>(buffer) + HEADER_SIZE,\n      <usize>(capacity - 1) << alignof<T>()\n    );\n    STORE<T>(buffer, 0, element);\n    this.length_ = newLength;\n    if (isManaged<T>()) __gc_link(changetype<usize>(this), changetype<usize>(element)); // tslint:disable-line\n    return newLength;\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    var len = this.length_;\n    begin = begin < 0 ? max(begin + len, 0) : min(begin, len);\n    end = end < 0 ? max(end + len, 0) : min(end, len);\n    len = max(end - begin, 0);\n    var sliced = new Array<T>(len);\n    if (len) {\n      memory.copy(\n        changetype<usize>(sliced.buffer_) + HEADER_SIZE,\n        changetype<usize>(this.buffer_) + HEADER_SIZE + (<usize>begin << alignof<T>()),\n        <usize>len << alignof<T>()\n      );\n    }\n    return sliced;\n  }\n\n  splice(start: i32, deleteCount: i32 = i32.MAX_VALUE): Array<T> {\n    var length  = this.length_;\n    start       = start < 0 ? max<i32>(length + start, 0) : min<i32>(start, length);\n    deleteCount = max<i32>(min<i32>(deleteCount, length - start), 0);\n    var buffer  = this.buffer_;\n    var spliced = new Array<T>(deleteCount);\n    var source  = changetype<usize>(buffer) + HEADER_SIZE + (<usize>start << alignof<T>());\n    memory.copy(\n      changetype<usize>(spliced.buffer_) + HEADER_SIZE,\n      source,\n      <usize>deleteCount << alignof<T>()\n    );\n    var offset = start + deleteCount;\n    if (length != offset) {\n      memory.copy(\n        source,\n        changetype<usize>(buffer) + HEADER_SIZE + (<usize>offset << alignof<T>()),\n        <usize>(length - offset) << alignof<T>()\n      );\n    }\n    this.length_ = length - deleteCount;\n    return spliced;\n  }\n\n  reverse(): Array<T> {\n    var buffer = this.buffer_;\n    for (let front = 0, back = this.length_ - 1; front < back; ++front, --back) {\n      let temp = LOAD<T>(buffer, front);\n      STORE<T>(buffer, front, LOAD<T>(buffer, back));\n      STORE<T>(buffer, back, temp);\n    }\n    return this;\n  }\n\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): this {\n    // TODO remove this when flow will allow trackcing null\n    assert(comparator); // The comparison function must be a function\n\n    var length = this.length_;\n    if (length <= 1) return this;\n    var buffer = this.buffer_;\n    if (length == 2) {\n      let a = LOAD<T>(buffer, 1); // a = arr[1]\n      let b = LOAD<T>(buffer, 0); // b = arr[0]\n      if (comparator(a, b) < 0) {\n        STORE<T>(buffer, 1, b);   // arr[1] = b;\n        STORE<T>(buffer, 0, a);   // arr[0] = a;\n      }\n      return this;\n    }\n    SORT<T>(buffer, 0, length, comparator);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    var lastIndex = this.length_ - 1;\n    if (lastIndex < 0) return \"\";\n    var result = \"\";\n    var value: T;\n    var buffer = this.buffer_;\n    var sepLen = separator.length;\n    var hasSeparator = sepLen != 0;\n    if (value instanceof bool) {\n      if (!lastIndex) return select<string>(\"true\", \"false\", LOAD<T,bool>(buffer, 0));\n\n      let valueLen = 5; // max possible length of element len(\"false\")\n      let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n      let result = allocateUnsafeString(estLen);\n      let offset = 0;\n      for (let i = 0; i < lastIndex; ++i) {\n        value = LOAD<T,bool>(buffer, i);\n        valueLen = 4 + <i32>(!value);\n        copyUnsafeString(result, offset, select<string>(\"true\", \"false\", value), 0, valueLen);\n        offset += valueLen;\n        if (hasSeparator) {\n          copyUnsafeString(result, offset, changetype<String>(separator), 0, sepLen);\n          offset += sepLen;\n        }\n      }\n      value = LOAD<T,bool>(buffer, lastIndex);\n      valueLen = 4 + <i32>(!value);\n      copyUnsafeString(result, offset, select<string>(\"true\", \"false\", value), 0, valueLen);\n      offset += valueLen;\n\n      let out = result;\n      if (estLen > offset) {\n        out = result.substring(0, offset);\n        freeUnsafeString(result);\n      }\n      return out;\n    } else if (isInteger<T>()) {\n      if (!lastIndex) return changetype<string>(itoa<T>(LOAD<T>(buffer, 0)));\n\n      const valueLen = (sizeof<T>() <= 4 ? 10 : 20) + <i32>isSigned<T>();\n      let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n      let result = allocateUnsafeString(estLen);\n      let offset = 0;\n      for (let i = 0; i < lastIndex; ++i) {\n        value = LOAD<T>(buffer, i);\n        offset += itoa_stream<T>(changetype<usize>(result), offset, value);\n        if (hasSeparator) {\n          copyUnsafeString(result, offset, separator, 0, sepLen);\n          offset += sepLen;\n        }\n      }\n      value = LOAD<T>(buffer, lastIndex);\n      offset += itoa_stream<T>(changetype<usize>(result), offset, value);\n      let out = result;\n      if (estLen > offset) {\n        out = result.substring(0, offset);\n        freeUnsafeString(result);\n      }\n      return out;\n    } else if (isFloat<T>()) {\n      if (!lastIndex) return changetype<string>(dtoa(LOAD<T,f64>(buffer, 0)));\n\n      const valueLen = MAX_DOUBLE_LENGTH;\n      let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n      let result = allocateUnsafeString(estLen);\n      let offset = 0;\n      for (let i = 0; i < lastIndex; ++i) {\n        value = LOAD<T,f64>(buffer, i);\n        offset += dtoa_stream(changetype<usize>(result), offset, value);\n        if (hasSeparator) {\n          copyUnsafeString(result, offset, separator, 0, sepLen);\n          offset += sepLen;\n        }\n      }\n      value = LOAD<T,f64>(buffer, lastIndex);\n      offset += dtoa_stream(changetype<usize>(result), offset, value);\n      let out = result;\n      if (estLen > offset) {\n        out = result.substring(0, offset);\n        freeUnsafeString(result);\n      }\n      return out;\n    } else if (isString<T>()) {\n      if (!lastIndex) return LOAD<string>(buffer, 0);\n\n      let estLen = 0;\n      for (let i = 0, len = lastIndex + 1; i < len; ++i) {\n        estLen += LOAD<string>(buffer, i).length;\n      }\n      let offset = 0;\n      let result = allocateUnsafeString(estLen + sepLen * lastIndex);\n      for (let i = 0; i < lastIndex; ++i) {\n        value = LOAD<string>(buffer, i);\n        if (value) {\n          let valueLen = value.length;                          // tslint:disable-line:no-unsafe-any\n          copyUnsafeString(result, offset, value, 0, valueLen); // tslint:disable-line:no-unsafe-any\n          offset += valueLen;                                   // tslint:disable-line:no-unsafe-any\n        }\n        if (hasSeparator) {\n          copyUnsafeString(result, offset, separator, 0, sepLen);\n          offset += sepLen;\n        }\n      }\n      value = LOAD<string>(buffer, lastIndex);\n      if (value) {\n        let valueLen = value.length;                          // tslint:disable-line:no-unsafe-any\n        copyUnsafeString(result, offset, value, 0, valueLen); // tslint:disable-line:no-unsafe-any\n      }\n      return result;\n    } else if (isArray<T>()) {\n      if (!lastIndex) {\n        value = LOAD<T>(buffer, 0);\n        return value ? value.join(separator) : \"\"; // tslint:disable-line:no-unsafe-any\n      }\n      for (let i = 0; i < lastIndex; ++i) {\n        value = LOAD<T>(buffer, i);\n        if (value) result += value.join(separator); // tslint:disable-line:no-unsafe-any\n        if (hasSeparator) result += separator;\n      }\n      value = LOAD<T>(buffer, lastIndex);\n      if (value) result += value.join(separator); // tslint:disable-line:no-unsafe-any\n      return result;\n    } else if (isReference<T>()) { // References\n      if (!lastIndex) return \"[object Object]\";\n      const valueLen = 15; // max possible length of element len(\"[object Object]\")\n      let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n      let result = allocateUnsafeString(estLen);\n      let offset = 0;\n      for (let i = 0; i < lastIndex; ++i) {\n        value = LOAD<T>(buffer, i);\n        if (value) {\n          copyUnsafeString(result, offset, changetype<String>(\"[object Object]\"), 0, valueLen);\n          offset += valueLen;\n        }\n        if (hasSeparator) {\n          copyUnsafeString(result, offset, changetype<String>(separator), 0, sepLen);\n          offset += sepLen;\n        }\n      }\n      if (LOAD<T>(buffer, lastIndex)) {\n        copyUnsafeString(result, offset, changetype<String>(\"[object Object]\"), 0, valueLen);\n        offset += valueLen;\n      }\n      let out = result;\n      if (estLen > offset) {\n        out = result.substring(0, offset);\n        freeUnsafeString(result);\n      }\n      return out;\n    } else {\n      assert(false); // Unsupported generic typename\n    }\n  }\n\n  @inline\n  toString(): string {\n    return this.join();\n  }\n\n  private __gc(): void {\n    var buffer = this.buffer_;\n    __gc_mark(changetype<usize>(buffer)); // tslint:disable-line\n    if (isManaged<T>()) {\n      let offset: usize = 0;\n      let end = <usize>this.length_ << alignof<usize>();\n      while (offset < end) {\n        __gc_mark(load<usize>(changetype<usize>(buffer) + offset, HEADER_SIZE)); // tslint:disable-line\n        offset += sizeof<usize>();\n      }\n    }\n  }\n}\n",
    "import { CanvasInstruction } from \"../../src/shared/CanvasInstruction\";\n\nexport class Path2DElement {\n  instruction: CanvasInstruction = CanvasInstruction.Commit;\n  transformA: f64 = 1.0;\n  transformB: f64 = 0.0;\n  transformC: f64 = 0.0;\n  transformD: f64 = 1.0;\n  transformE: f64 = 0.0;\n  transformF: f64 = 0.0;\n  count: i32 = 0;\n  updateTransform: bool = false;\n  a: f64 = 0;\n  b: f64 = 0;\n  c: f64 = 0;\n  d: f64 = 0;\n  e: f64 = 0;\n  f: f64 = 0;\n  g: f64 = 0;\n  h: f64 = 0;\n}",
    "import {\n  HEADER_SIZE,\n  MAX_LENGTH,\n  allocateUnsafe,\n  compareUnsafe,\n  repeatUnsafe,\n  copyUnsafe,\n  isWhiteSpaceOrLineTerminator,\n  CharCode,\n  parse\n} from \"./internal/string\";\n\nimport {\n  STORE\n} from \"./internal/arraybuffer\";\n\n@sealed\nexport class String {\n\n  readonly length: i32; // capped to [0, MAX_LENGTH]\n\n  // TODO Add and handle second argument\n  static fromCharCode(code: i32): String {\n    var out = allocateUnsafe(1);\n    store<u16>(\n      changetype<usize>(out),\n      <u16>code,\n      HEADER_SIZE\n    );\n    return out;\n  }\n\n  static fromCodePoint(code: i32): String {\n    assert(<u32>code <= 0x10FFFF);\n    var sur = code > 0xFFFF;\n    var out = allocateUnsafe(<i32>sur + 1);\n    if (!sur) {\n      store<u16>(\n        changetype<usize>(out),\n        <u16>code,\n        HEADER_SIZE\n      );\n    } else {\n      code -= 0x10000;\n      let hi: u32 = (code >>> 10) + 0xD800;\n      let lo: u32 = (code & 0x3FF) + 0xDC00;\n      store<u32>(\n        changetype<usize>(out),\n        (hi << 16) | lo,\n        HEADER_SIZE\n      );\n    }\n    return out;\n  }\n\n  @operator(\"[]\")\n  charAt(pos: i32): String {\n    assert(this !== null);\n\n    if (<u32>pos >= <u32>this.length) return changetype<String>(\"\");\n\n    var out = allocateUnsafe(1);\n    store<u16>(\n      changetype<usize>(out),\n      load<u16>(\n        changetype<usize>(this) + (<usize>pos << 1),\n        HEADER_SIZE\n      ),\n      HEADER_SIZE\n    );\n    return out;\n  }\n\n  charCodeAt(pos: i32): i32 {\n    assert(this !== null);\n    if (<u32>pos >= <u32>this.length) return -1; // (NaN)\n\n    return load<u16>(\n      changetype<usize>(this) + (<usize>pos << 1),\n      HEADER_SIZE\n    );\n  }\n\n  codePointAt(pos: i32): i32 {\n    assert(this !== null);\n    if (<u32>pos >= <u32>this.length) return -1; // (undefined)\n\n    var first = <i32>load<u16>(\n      changetype<usize>(this) + (<usize>pos << 1),\n      HEADER_SIZE\n    );\n    if (first < 0xD800 || first > 0xDBFF || pos + 1 == this.length) {\n      return first;\n    }\n    var second = <i32>load<u16>(\n      changetype<usize>(this) + ((<usize>pos + 1) << 1),\n      HEADER_SIZE\n    );\n    if (second < 0xDC00 || second > 0xDFFF) return first;\n    return ((first - 0xD800) << 10) + (second - 0xDC00) + 0x10000;\n  }\n\n  @operator(\"+\")\n  private static __concat(left: String, right: String): String {\n    if (!changetype<usize>(left)) left = changetype<String>(\"null\");\n    return left.concat(right);\n  }\n\n  concat(other: String): String {\n    assert(this !== null);\n    if (other === null) other = changetype<String>(\"null\");\n\n    var thisLen: isize  = this.length;\n    var otherLen: isize = other.length;\n    var outLen: usize   = thisLen + otherLen;\n    if (outLen == 0) return changetype<String>(\"\");\n    var out = allocateUnsafe(outLen);\n    copyUnsafe(out, 0, this, 0, thisLen);\n    copyUnsafe(out, thisLen, other, 0, otherLen);\n    return out;\n  }\n\n  endsWith(searchString: String, endPosition: i32 = MAX_LENGTH): bool {\n    assert(this !== null);\n    if (searchString === null) return false;\n    var end = min(max(endPosition, 0), this.length);\n    var searchLength: isize = searchString.length;\n    var start: isize = end - searchLength;\n    if (start < 0) return false;\n    return !compareUnsafe(this, start, searchString, 0, searchLength);\n  }\n\n  @operator(\"==\")\n  private static __eq(left: String, right: String): bool {\n    if (left === right) return true;\n    if (left === null || right === null) return false;\n\n    var leftLength = left.length;\n    if (leftLength != right.length) return false;\n\n    return !compareUnsafe(left, 0, right, 0, leftLength);\n  }\n\n  @operator.prefix(\"!\")\n  private static __not(str: String): bool {\n    return str === null || !str.length;\n  }\n\n  @operator(\"!=\")\n  private static __ne(left: String, right: String): bool {\n    return !this.__eq(left, right);\n  }\n\n  @operator(\">\")\n  private static __gt(left: String, right: String): bool {\n    if (left === right || left === null || right === null) return false;\n\n    var leftLength  = left.length;\n    var rightLength = right.length;\n\n    if (!leftLength)  return false;\n    if (!rightLength) return true;\n\n    var length = <usize>min<i32>(leftLength, rightLength);\n    return compareUnsafe(left, 0, right, 0, length) > 0;\n  }\n\n  @operator(\">=\")\n  private static __gte(left: String, right: String): bool {\n    return !this.__lt(left, right);\n  }\n\n  @operator(\"<\")\n  private static __lt(left: String, right: String): bool {\n    if (left === right || left === null || right === null) return false;\n\n    var leftLength  = left.length;\n    var rightLength = right.length;\n\n    if (!rightLength) return false;\n    if (!leftLength)  return true;\n\n    var length = <usize>min<i32>(leftLength, rightLength);\n    return compareUnsafe(left, 0, right, 0, length) < 0;\n  }\n\n  @operator(\"<=\")\n  private static __lte(left: String, right: String): bool {\n    return !this.__gt(left, right);\n  }\n\n  @inline\n  includes(searchString: String, position: i32 = 0): bool {\n    return this.indexOf(searchString, position) != -1;\n  }\n\n  indexOf(searchString: String, fromIndex: i32 = 0): i32 {\n    assert(this !== null);\n    if (searchString === null) searchString = changetype<String>(\"null\");\n\n    var searchLen: isize = searchString.length;\n    if (!searchLen) return 0;\n    var len: isize = this.length;\n    if (!len) return -1;\n    var start = min<isize>(max<isize>(fromIndex, 0), len);\n    len -= searchLen;\n    for (let k: isize = start; k <= len; ++k) {\n      if (!compareUnsafe(this, k, searchString, 0, searchLen)) return <i32>k;\n    }\n    return -1;\n  }\n\n  lastIndexOf(searchString: String, fromIndex: i32 = i32.MAX_VALUE): i32 {\n    assert(this !== null);\n    if (searchString === null) searchString = changetype<String>(\"null\");\n\n    var len: isize = this.length;\n    var searchLen: isize = searchString.length;\n    if (!searchLen) return len;\n    if (!len) return -1;\n    var start = min<isize>(max(fromIndex, 0), len - searchLen);\n    for (let k = start; k >= 0; --k) {\n      if (!compareUnsafe(this, k, searchString, 0, searchLen)) return <i32>k;\n    }\n    return -1;\n  }\n\n  startsWith(searchString: String, position: i32 = 0): bool {\n    assert(this !== null);\n    if (searchString === null) searchString = changetype<String>(\"null\");\n\n    var pos: isize = position;\n    var len: isize = this.length;\n    var start = min(max(pos, 0), len);\n    var searchLength: isize = searchString.length;\n    if (searchLength + start > len) return false;\n    return !compareUnsafe(this, start, searchString, 0, searchLength);\n  }\n\n  substr(start: i32, length: i32 = i32.MAX_VALUE): String {\n    assert(this !== null);\n    var intStart: isize = start;\n    var end: isize = length;\n    var size: isize = this.length;\n    if (intStart < 0) intStart = max(size + intStart, 0);\n    var resultLength = min(max(end, 0), size - intStart);\n    if (resultLength <= 0) return changetype<String>(\"\");\n    var out = allocateUnsafe(resultLength);\n    copyUnsafe(out, 0, this, intStart, resultLength);\n    return out;\n  }\n\n  substring(start: i32, end: i32 = i32.MAX_VALUE): String {\n    assert(this !== null);\n    var len = this.length;\n    var finalStart = min(max(start, 0), len);\n    var finalEnd = min(max(end, 0), len);\n    var from = min<i32>(finalStart, finalEnd);\n    var to = max<i32>(finalStart, finalEnd);\n    len = to - from;\n    if (!len) return changetype<String>(\"\");\n    if (!from && to == this.length) return this;\n    var out = allocateUnsafe(len);\n    copyUnsafe(out, 0, this, from, len);\n    return out;\n  }\n\n  trim(): String {\n    assert(this !== null);\n    var length: usize = this.length;\n\n    while (\n      length &&\n      isWhiteSpaceOrLineTerminator(\n        load<u16>(changetype<usize>(this) + (length << 1), HEADER_SIZE)\n      )\n    ) {\n      --length;\n    }\n    var start: usize = 0;\n    while (\n      start < length &&\n      isWhiteSpaceOrLineTerminator(\n        load<u16>(changetype<usize>(this) + (start << 1), HEADER_SIZE)\n      )\n    ) {\n      ++start, --length;\n    }\n    if (!length) return changetype<String>(\"\");\n    if (!start && length == this.length) return this;\n    var out = allocateUnsafe(length);\n    copyUnsafe(out, 0, this, start, length);\n    return out;\n  }\n\n  @inline\n  trimLeft(): String {\n    return this.trimStart();\n  }\n\n  @inline\n  trimRight(): String {\n    return this.trimEnd();\n  }\n\n  trimStart(): String {\n    assert(this !== null);\n    var start: isize = 0;\n    var len: isize = this.length;\n    while (\n      start < len &&\n      isWhiteSpaceOrLineTerminator(\n        load<u16>(changetype<usize>(this) + (start << 1), HEADER_SIZE)\n      )\n    ) {\n      ++start;\n    }\n    if (!start) return this;\n    var outLen = len - start;\n    if (!outLen) return changetype<String>(\"\");\n    var out = allocateUnsafe(outLen);\n    copyUnsafe(out, 0, this, start, outLen);\n    return out;\n  }\n\n  trimEnd(): String {\n    assert(this !== null);\n    var len: isize = this.length;\n    while (\n      len > 0 &&\n      isWhiteSpaceOrLineTerminator(\n        load<u16>(changetype<usize>(this) + (len << 1), HEADER_SIZE)\n      )\n    ) {\n      --len;\n    }\n    if (len <= 0) return changetype<String>(\"\");\n    if (<i32>len == this.length) return this;\n    var out = allocateUnsafe(len);\n    copyUnsafe(out, 0, this, 0, len);\n    return out;\n  }\n\n  padStart(targetLength: i32, padString: String = changetype<String>(\" \")): String {\n    assert(this !== null);\n    var length = this.length;\n    var padLen = padString.length;\n    if (targetLength < length || !padLen) return this;\n    var len = targetLength - length;\n    var out = allocateUnsafe(targetLength);\n    if (len > padLen) {\n      let count = (len - 1) / padLen;\n      let base = count * padLen;\n      let rest = len - base;\n      repeatUnsafe(out, 0, padString, count);\n      if (rest) copyUnsafe(out, base, padString, 0, rest);\n    } else {\n      copyUnsafe(out, 0, padString, 0, len);\n    }\n    if (length) copyUnsafe(out, len, this, 0, length);\n    return out;\n  }\n\n  padEnd(targetLength: i32, padString: String = changetype<String>(\" \")): String {\n    assert(this !== null);\n    var length = this.length;\n    var padLen = padString.length;\n    if (targetLength < length || !padLen) return this;\n    var len = targetLength - length;\n    var out = allocateUnsafe(targetLength);\n    if (length) copyUnsafe(out, 0, this, 0, length);\n    if (len > padLen) {\n      let count = (len - 1) / padLen;\n      let base = count * padLen;\n      let rest = len - base;\n      repeatUnsafe(out, length, padString, count);\n      if (rest) copyUnsafe(out, base + length, padString, 0, rest);\n    } else {\n      copyUnsafe(out, length, padString, 0, len);\n    }\n    return out;\n  }\n\n  repeat(count: i32 = 0): String {\n    assert(this !== null);\n    var length = this.length;\n\n    // Most browsers can't handle strings 1 << 28 chars or longer\n    if (count < 0 || length * count > (1 << 28)) {\n      throw new RangeError(\"Invalid count value\");\n    }\n\n    if (count == 0 || !length) return changetype<String>(\"\");\n    if (count == 1) return this;\n\n    var result = allocateUnsafe(length * count);\n    repeatUnsafe(result, 0, this, count);\n    return result;\n  }\n\n  slice(beginIndex: i32, endIndex: i32 = i32.MAX_VALUE): String {\n    var len   = this.length;\n    var begin = beginIndex < 0 ? max(beginIndex + len, 0) : min(beginIndex, len);\n    var end   = endIndex   < 0 ? max(endIndex   + len, 0) : min(endIndex,   len);\n    len = end - begin;\n    if (len <= 0) return changetype<String>(\"\");\n    var out = allocateUnsafe(len);\n    copyUnsafe(out, 0, this, begin, len);\n    return out;\n  }\n\n  split(separator: String = null, limit: i32 = i32.MAX_VALUE): String[] {\n    assert(this !== null);\n    if (!limit) return new Array<String>();\n    if (separator === null) return <String[]>[this];\n    var length: isize = this.length;\n    var sepLen: isize = separator.length;\n    if (limit < 0) limit = i32.MAX_VALUE;\n    if (!sepLen) {\n      if (!length) return new Array<String>();\n      // split by chars\n      length = min<isize>(length, <isize>limit);\n      let result = new Array<String>(length);\n      let buffer = <ArrayBuffer>result.buffer_;\n      for (let i: isize = 0; i < length; ++i) {\n        let char = allocateUnsafe(1);\n        store<u16>(\n          changetype<usize>(char),\n          load<u16>(\n            changetype<usize>(this) + (<usize>i << 1),\n            HEADER_SIZE\n          ),\n          HEADER_SIZE\n        );\n        STORE<String>(buffer, i, char);\n      }\n      return result;\n    } else if (!length) {\n      let result = new Array<String>(1);\n      unchecked(result[0] = changetype<String>(\"\"));\n      return result;\n    }\n    var result = new Array<String>();\n    var end = 0, start = 0, i = 0;\n    while ((end = this.indexOf(separator, start)) != -1) {\n      let len = end - start;\n      if (len > 0) {\n        let out = allocateUnsafe(len);\n        copyUnsafe(out, 0, this, start, len);\n        result.push(out);\n      } else {\n        result.push(changetype<String>(\"\"));\n      }\n      if (++i == limit) return result;\n      start = end + sepLen;\n    }\n    if (!start) {\n      let result = new Array<String>(1);\n      unchecked(result[0] = this);\n      return result;\n    }\n    var len = length - start;\n    if (len > 0) {\n      let out = allocateUnsafe(len);\n      copyUnsafe(out, 0, this, start, len);\n      result.push(out);\n    } else {\n      result.push(changetype<String>(\"\"));\n    }\n    return result;\n  }\n\n  toString(): String {\n    return this;\n  }\n\n  get lengthUTF8(): i32 {\n    var len = 1; // null terminated\n    var pos: usize = 0;\n    var end = <usize>this.length;\n    while (pos < end) {\n      let c = <u32>load<u16>(changetype<usize>(this) + (pos << 1), HEADER_SIZE);\n      if (c < 128) {\n        len += 1; ++pos;\n      } else if (c < 2048) {\n        len += 2; ++pos;\n      } else {\n        if (\n          (c & 0xFC00) == 0xD800 && pos + 1 < end &&\n          (<u32>load<u16>(changetype<usize>(this) + ((pos + 1) << 1), HEADER_SIZE) & 0xFC00) == 0xDC00\n        ) {\n          len += 4; pos += 2;\n        } else {\n          len += 3; ++pos;\n        }\n      }\n    }\n    return len;\n  }\n\n  static fromUTF8(ptr: usize, len: usize): String {\n    if (len < 1) return changetype<String>(\"\");\n    var ptrPos = <usize>0;\n    var buf = memory.allocate(<usize>len << 1);\n    var bufPos = <usize>0;\n    while (ptrPos < len) {\n      let cp = <u32>load<u8>(ptr + ptrPos++);\n      if (cp < 128) {\n        store<u16>(buf + bufPos, cp);\n        bufPos += 2;\n      } else if (cp > 191 && cp < 224) {\n        assert(ptrPos + 1 <= len);\n        store<u16>(buf + bufPos, (cp & 31) << 6 | load<u8>(ptr + ptrPos++) & 63);\n        bufPos += 2;\n      } else if (cp > 239 && cp < 365) {\n        assert(ptrPos + 3 <= len);\n        cp = (\n          (cp                       &  7) << 18 |\n          (load<u8>(ptr + ptrPos++) & 63) << 12 |\n          (load<u8>(ptr + ptrPos++) & 63) <<  6 |\n           load<u8>(ptr + ptrPos++) & 63\n        ) - 0x10000;\n        store<u16>(buf + bufPos, 0xD800 + (cp >> 10));\n        bufPos += 2;\n        store<u16>(buf + bufPos, 0xDC00 + (cp & 1023));\n        bufPos += 2;\n      } else {\n        assert(ptrPos + 2 <= len);\n        store<u16>(buf + bufPos,\n          (cp                       & 15) << 12 |\n          (load<u8>(ptr + ptrPos++) & 63) <<  6 |\n           load<u8>(ptr + ptrPos++) & 63\n        );\n        bufPos += 2;\n      }\n    }\n    assert(ptrPos == len);\n    var str = allocateUnsafe(<u32>(bufPos >> 1));\n    memory.copy(changetype<usize>(str) + HEADER_SIZE, buf, bufPos);\n    memory.free(buf);\n    return str;\n  }\n\n  toUTF8(): usize {\n    var buf = memory.allocate(<usize>this.lengthUTF8);\n    var pos: usize = 0;\n    var end = <usize>this.length;\n    var off: usize = 0;\n    while (pos < end) {\n      let c1 = <u32>load<u16>(changetype<usize>(this) + (pos << 1), HEADER_SIZE);\n      if (c1 < 128) {\n        store<u8>(buf + off, c1);\n        ++off; ++pos;\n      } else if (c1 < 2048) {\n        let ptr = buf + off;\n        store<u8>(ptr, c1 >> 6 | 192);\n        store<u8>(ptr, c1 & 63 | 128, 1);\n        off += 2; ++pos;\n      } else {\n        let ptr = buf + off;\n        if ((c1 & 0xFC00) == 0xD800 && pos + 1 < end) {\n          let c2 = <u32>load<u16>(changetype<usize>(this) + ((pos + 1) << 1), HEADER_SIZE);\n          if ((c2 & 0xFC00) == 0xDC00) {\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\n            store<u8>(ptr, c1 >> 18      | 240);\n            store<u8>(ptr, c1 >> 12 & 63 | 128, 1);\n            store<u8>(ptr, c1 >>  6 & 63 | 128, 2);\n            store<u8>(ptr, c1       & 63 | 128, 3);\n            off += 4; pos += 2;\n            continue;\n          }\n        }\n        store<u8>(ptr, c1 >> 12     | 224);\n        store<u8>(ptr, c1 >> 6 & 63 | 128, 1);\n        store<u8>(ptr, c1      & 63 | 128, 2);\n        off += 3; ++pos;\n      }\n    }\n    store<u8>(buf + off, 0);\n    return buf;\n  }\n}\n\nexport type string = String;\n\nexport function parseInt(str: String, radix: i32 = 0): f64 {\n  return parse<f64>(str, radix);\n}\n\nexport function parseI32(str: String, radix: i32 = 0): i32 {\n  return parse<i32>(str, radix);\n}\n\nexport function parseI64(str: String, radix: i32 = 0): i64 {\n  return parse<i64>(str, radix);\n}\n\n// FIXME: naive implementation\nexport function parseFloat(str: String): f64 {\n  var len: i32 = str.length;\n  if (!len) return NaN;\n\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  var code = <i32>load<u16>(ptr, HEADER_SIZE);\n\n  // determine sign\n  var sign: f64;\n  if (code == CharCode.MINUS) {\n    if (!--len) return NaN;\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return NaN;\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\n    sign = 1;\n  } else {\n    sign = 1;\n  }\n\n  // calculate value\n  var num: f64 = 0;\n  while (len--) {\n    code = <i32>load<u16>(ptr, HEADER_SIZE);\n    if (code == CharCode.DOT) {\n      ptr += 2;\n      let fac: f64 = 0.1; // precision :(\n      while (len--) {\n        code = <i32>load<u16>(ptr, HEADER_SIZE);\n        if (code == CharCode.E || code == CharCode.e) {\n          assert(false); // TODO\n        }\n        code -= CharCode._0;\n        if (<u32>code > 9) break;\n        num += <f64>code * fac;\n        fac *= 0.1;\n        ptr += 2;\n      }\n      break;\n    }\n    code -= CharCode._0;\n    if (<u32>code >= 10) break;\n    num = (num * 10) + code;\n    ptr += 2;\n  }\n  return sign * num;\n}\n",
    "// @ts-ignore\n@external(\"__canvas_sys\", \"loadImage\")\ndeclare function loadImage(img: Image, src: string): i32;\n\n// @ts-ignore\n@external(\"__canvas_sys\", \"disposeImage\")\ndeclare function disposeImage(id: i32): void;\n\nexport class Image {\n  private _id: i32 = -1;\n  private _width: i32 = 0;\n  private _height: i32 = 0;\n  private _loaded: bool = false;\n  private _src: string = \"\";\n\n  @inline\n  public get width(): number {\n    return this._width;\n  }\n\n  @inline\n  public get height(): number {\n    return this._height;\n  }\n\n  @inline\n  public get loaded(): bool {\n    return this._loaded;\n  }\n\n  @inline\n  public get src(): string {\n    return this._src;\n  }\n\n  public set src(value: string) {\n    this._src = value;\n    this._id = loadImage(this, value);\n  }\n\n  public dispose(): void {\n    disposeImage(this._id);\n  }\n}\n\nexport function __image_loaded(img: Image, width: i32, height: i32): void {\n  store<i32>(changetype<usize>(img) + offsetof<Image>(\"_width\"), width);\n  store<i32>(changetype<usize>(img) + offsetof<Image>(\"_height\"), height);\n  store<bool>(changetype<usize>(img) + offsetof<Image>(\"_loaded\"), true);\n}\n\n/**\n * Gets the image's external id.\n *\n * @param image - The target image.\n */\n// @ts-ignore: @inline is valid on regular functions\n@inline\nexport function getImageID(image: Image): i32 {\n  return load<i32>(changetype<usize>(image) + offsetof<Image>(\"_id\"));\n}\n",
    "import {console} from \"./console\";\n\nexport enum PlayerRole {\n    None = 0,\n    First = 1,\n    Second = 2\n}\n\n\nexport declare namespace listener {\n\n    // @ts-ignore\n    @external(\"listener\", \"onUpdate\")\n    function onUpdate(player: PlayerRole, state: Int8Array): void;\n\n    // @ts-ignore\n    @external(\"listener\", \"onGameOver\")\n    function onGameOver(winner: PlayerRole): void;\n\n}\n\nexport abstract class GameEngine {\n\n    init(): void {\n    }\n\n    /**\n     *\n     * @param player\n     * @param state new increment state.\n     * @return is update success.\n     */\n    update(player: PlayerRole, state: Int8Array): boolean {\n        // console.log(\"GameEngine update\");\n        return false\n    }\n\n    loadState(fullState: Int8Array): void {\n    }\n\n    getState(): Int8Array {\n        return new Int8Array(0)\n    }\n\n    isGameOver(): boolean {\n        return false\n    }\n\n    getWinner(): PlayerRole {\n        return PlayerRole.None\n    }\n\n}\n",
    "import {PlayerRole} from \"../game/GameEngine\";\n\nexport enum Chess {\n    None = 0,\n    White = 1,\n    Black = 2\n}\n\nexport namespace constants {\n\n    export const boardDimension: i32 = 15;\n    export const boardSize: i32 = 15 * 15;\n\n    export function chessOfPlayer(player: PlayerRole): Chess {\n        if (player == PlayerRole.First) {\n            return Chess.White\n        } else if (player == PlayerRole.Second) {\n            return Chess.Black\n        } else {\n            return Chess.None\n        }\n    }\n\n    // @ts-ignore\n    @inline\n    export function chessOfRival(player: PlayerRole): Chess {\n        return chessOfPlayer(rivalPlayer(player));\n    }\n\n    export function rival(chess: Chess): Chess {\n        if (chess == Chess.Black) {\n            return Chess.White\n        } else if (chess == Chess.White) {\n            return Chess.Black\n        } else {\n            return Chess.None\n        }\n    }\n\n    // @ts-ignore\n    @inline\n    export function rivalPlayer(player: PlayerRole): PlayerRole {\n        if (player == PlayerRole.Second) {\n            return PlayerRole.First\n        } else {\n            return PlayerRole.Second\n        }\n    }\n\n    export function validRowAndCol(row: i32, col: i32): boolean {\n        let dim = constants.boardDimension\n        return (\n            row >= 0 && row < dim &&\n            col >= 0 && col < dim\n        )\n    }\n\n}\n",
    "import {PlayerRole} from \"../game/GameEngine\";\nimport {engine, GameGUI} from \"../game/GameGUI\";\n// import {console} from \"../game/console\";\nimport {Chess, constants} from \"./constants\";\nimport {Position} from \"./GomokuEngine\";\n\nconst Black = \"#111\"\nconst White = \"#EEE\"\nlet EmptyState = new Int8Array(0)\n\n// @ts-ignore\n@inline\nfunction chessOfColor(chess: Chess): string {\n    if (chess == Chess.Black) {\n        return Black\n    } else if (chess == Chess.White) {\n        return White\n    } else {\n        return \"none\"\n    }\n}\n\nclass Config {\n    chessBoardColor: string = \"yellow\"\n    gridSize: u32 = 30\n    canvasWidth: u32 = 450//this.gridSize * 15\n    canvasHeight: u32 = 450//this.gridSize * 15\n    gridColor: string = '#000'\n    chessSize: u32 = 12\n    pointColor: string = \"#f00\" //TODO\n    dimension: u32 = constants.boardDimension\n}\n\nclass GomokuGUI extends GameGUI {\n\n    cfg: Config = new Config();\n\n    update(player: PlayerRole, state: Int8Array): boolean {\n        if (engine.update(player, state)) {\n            this.updateGUI(player, state);\n            return true\n        }\n        return false\n    }\n\n    updateGUI(player: PlayerRole, state: Int8Array): void {\n        this.drawChess(state[0], state[1], constants.chessOfPlayer(player))\n    }\n\n    loadState(fullState: Int8Array): void {\n        engine.loadState(fullState);\n        this.draw();\n        for (let i = 0, len = fullState.length; i < len; i++) {\n            let value = fullState[i];\n            if (value != Chess.None) {\n                let position = Position.fromIndex(i);\n                this.drawChess(position.row, position.col, value);\n            }\n        }\n    }\n\n    draw(): void {\n        let i: u32;\n        let ctx = this.ctx;\n        let gridSize = this.cfg.gridSize;\n        let dimension = this.cfg.dimension;\n        let halfSize = gridSize / 2;\n        let center = gridSize * dimension - halfSize;\n\n        ctx.save();\n        ctx.beginPath();\n        ctx.fillStyle = this.cfg.chessBoardColor;\n        ctx.fillRect(0, 0, this.cfg.canvasWidth, this.cfg.canvasHeight);\n\n        for (i = 0; i < dimension; i++) {\n            let end = halfSize + gridSize * i;\n            ctx.moveTo(halfSize, end);\n            ctx.lineTo(center, end);\n        }\n        for (i = 0; i < dimension; i++) {\n            let start = halfSize + gridSize * i;\n            ctx.moveTo(start, halfSize);\n            ctx.lineTo(start, center);\n        }\n        ctx.lineWidth = 2;\n        ctx.strokeStyle = this.cfg.gridColor;\n        ctx.stroke();\n        ctx.restore();\n        ctx.commit();\n        engine.getState();\n    }\n\n    onClick(x: i32, y: i32): Int8Array {\n        let row = i8(x / this.cfg.gridSize);\n        let col = i8(y / this.cfg.gridSize);\n        let state = new Int8Array(2);\n        state[0] = row;\n        state[1] = col;\n        // console.logAction(\"onClick\", this.player, state);\n        if (engine.update(this.player, state)) {\n            this.drawChess(row, col, constants.chessOfPlayer(this.player))\n            return state\n        }\n        return EmptyState\n    }\n\n    drawChess(row: i32, col: i32, chess: Chess): void {\n        if (chess == Chess.None) {\n            return\n        }\n        let color = chessOfColor(chess)\n        // console.log(\"drawChess:\" + color)\n        let ctx = this.ctx;\n        let gridSize = this.cfg.gridSize;\n        ctx.save();\n        ctx.beginPath();\n        ctx.arc(gridSize * row + gridSize / 2, gridSize * col + gridSize / 2, this.cfg.chessSize, 0, Math.PI * 2, true);\n        ctx.fillStyle = color;\n        ctx.fill();\n        ctx.restore();\n        ctx.commit();\n    }\n}\n\nexport {GomokuGUI}\n",
    "import {GamePlayer} from \"../../game/GamePlayer\";\nimport {PlayerRole} from \"../../game/GameEngine\";\nimport {Chess, constants} from \"../constants\";\nimport {Chessboard, Position} from \"../GomokuEngine\";\n// import {console} from \"../../game/console\";\n\n\n/**\n * 棋型收益估分(不可变)\n */\nclass AIScore {\n    /**立即获胜 */\n    static readonly WillWin: i32 = 1000\n    /**无法获胜(一定无法达成5连) */\n    static readonly WillFail: i32 = 0\n    static readonly Min: i32 = 0\n    static readonly Dangerous: i32 = 60\n    static readonly ooooo: i32 = 1000\n    static readonly oooo: i32 = 100\n    static readonly ooo: i32 = 40\n    static readonly Ioooo: i32 = 40\n    static readonly Iooo: i32 = 5\n    static readonly oo: i32 = 5\n    static readonly Ioo: i32 = 1\n    static readonly o: i32 = 0\n    static readonly Io: i32 = 0\n\n    static readonly ooo_oo: i32 = AIScore.ooo - 1\n    static readonly Iooo_oo: i32 = AIScore.Ioooo - 1\n    static readonly oo_oo: i32 = AIScore.ooo_oo\n    static readonly Ioo_oo: i32 = AIScore.Iooo_oo\n    static readonly o_oo: i32 = AIScore.ooo_oo\n    static readonly Io_oo: i32 = AIScore.Io + AIScore.oo\n    static readonly o_o: i32 = AIScore.o + AIScore.o\n    static readonly Io_o: i32 = AIScore.Io + AIScore.o\n}\n\n\n/**\n * 棋型威胁估分(不可变)\n */\nclass AIRivalScore {\n    static readonly ooooo: i32 = 50\n    static readonly oooo: i32 = 50\n    static readonly ooo: i32 = 10\n    static readonly Ioooo: i32 = 10\n    static readonly Iooo: i32 = 3\n    static readonly oo: i32 = 3\n    static readonly Ioo: i32 = 1\n    static readonly o: i32 = 0\n}\n\n// @ts-ignore\n@inline\nfunction makeMatrix(r: i32, c: i32, value: i32): Int8Array {\n    let array = new Int8Array(r * c);\n    array.fill(value);\n    return array;\n}\n\n// @ts-ignore\n@inline\nfunction idxByRowCol(row: i32, col: i32): i32 {\n    return constants.boardDimension * row + col;\n}\n\nexport class BigbenAI extends GamePlayer {\n\n    private readonly chessboard: Chessboard;\n    private readonly myChess: Chess;\n    private readonly rivalChess: Chess;\n\n    constructor(role: PlayerRole, newStateCallback: (state: Int8Array) => void) {\n        super(role, newStateCallback);\n        this.chessboard = new Chessboard();\n        this.myChess = constants.chessOfPlayer(role);\n        this.rivalChess = constants.chessOfRival(role);\n        // console.log(\"BigbenAI myChess:\" + this.myChess.toString() + \", rivalChess:\" + this.rivalChess.toString())\n\n    }\n\n    first(): void {\n        let row = 7;\n        let col = 7;\n        this.chessboard.putChess(row, col, this.myChess);\n        let state = new Int8Array(2);\n        state[0] = row;\n        state[1] = col;\n        this.newStateCallback(state);\n    }\n\n    startGame(): void {\n        if (this.chessboard.isEmpty()) {\n            if (this.role == PlayerRole.First) {\n                this.first()\n            }\n        } else {\n            let nextPlayer = this.chessboard.nextPlayer();\n            if (nextPlayer == this.role) {\n                this.nextAction();\n            }\n        }\n    }\n\n    loadState(fullState: Int8Array): void {\n        this.chessboard.load(fullState);\n    }\n\n    update(state: Int8Array): boolean {\n        this.chessboard.putChess(state[0], state[1], this.rivalChess);\n        //TODO async\n        this.nextAction();\n        return true\n    }\n\n    nextAction(): void {\n        if (this.chessboard.isFull()) {\n            return\n        }\n        let position = this.nextPosition();\n        this.chessboard.put(position.row, position.col, this.myChess);\n        let newState = position.toState();\n        // console.logAction(\"BigbenAI\", this.role, newState);\n        this.newStateCallback(newState);\n    }\n\n    nextPosition(): Position {\n        let newPosition: Position;\n        //先防\n        //计算敌方下一步最高收益的落子\n        let rivalScores = makeMatrix(constants.boardDimension, constants.boardDimension, -1)\n        for (let i = 0; i < constants.boardDimension; i++)\n            for (let j = 0; j < constants.boardDimension; j++)\n                if (this.chessboard.get(i, j) == Chess.None) {\n                    this.chessboard.put(i, j, this.rivalChess) //尝试落子\n                    rivalScores[idxByRowCol(i, j)] = this.computeScore(i, j, this.rivalChess) //计算敌方收益\n                    this.chessboard.clear(i, j)//收回尝试\n                }\n        let rI = 0, rJ = 0\n        for (let i = 0; i < constants.boardDimension; i++)\n            for (let j = 0; j < constants.boardDimension; j++)\n                if (rivalScores[idxByRowCol(i, j)] > rivalScores[idxByRowCol(rI, rJ)]) {\n                    rI = i\n                    rJ = j\n                }\n\n        // 后攻\n        // 遍历每一个位置, 评估分数\n        let scores = makeMatrix(constants.boardDimension, constants.boardDimension, -1)\n        for (let i = 0; i < constants.boardDimension; i++)\n            for (let j = 0; j < constants.boardDimension; j++)\n                if (this.chessboard.get(i, j) == 0) {\n                    this.chessboard.put(i, j, this.myChess)  //尝试落子\n                    scores[idxByRowCol(i, j)] = this.computeScore(i, j, this.myChess) //计算己方收益\n                    this.chessboard.clear(i, j) //收回尝试\n                }\n        // 选出进攻分数最高的位置\n        let I = 0, J = 0\n        for (let i = 0; i < constants.boardDimension; i++)\n            for (let j = 0; j < constants.boardDimension; j++)\n                if (scores[idxByRowCol(i, j)] > scores[idxByRowCol(I, J)]) {\n                    I = i\n                    J = j\n                }\n\n        if (scores[idxByRowCol(I, J)] == 100) {\n            //直接获胜\n            newPosition = new Position(I, J)\n            // console.logi(\"Attack: (\" + newPosition.toString() + \") s:\", scores[idxByRowCol(I, J)]);\n        } else if (rivalScores[idxByRowCol(rI, rJ)] >= 20) {\n            //若出现危险棋局, 选择防守策略\n            newPosition = new Position(rI, rJ)\n            // console.logi(\"Defend: (\" + newPosition.toString() + \") s:\", scores[idxByRowCol(I, J)]);\n        } else {\n            //进攻\n            newPosition = new Position(I, J)\n            // console.logi(\"Attack: (\" + newPosition.toString() + \") s:\", scores[idxByRowCol(I, J)]);\n        }\n        return newPosition\n    }\n\n    findNearPosition(position: Position): Position | null {\n        let newPosition: Position | null = null;\n        for (let row: i8 = position.row - 1; row <= position.row + 1; row++) {\n            for (let col: i8 = position.col - 1; col <= position.col + 1; col++) {\n                if (!constants.validRowAndCol(row, col)) {\n                    continue\n                }\n                if (!this.chessboard.hasChess(row, col)) {\n                    newPosition = new Position(row, col);\n                    let oppositeRow: i32 = position.row > row ? position.row + (position.row - row) : position.row - (row - position.row);\n                    let oppositeCol: i32 = position.col > col ? position.col + (position.col - col) : position.col - (col - position.col);\n                    if (this.chessboard.getChess(oppositeRow, oppositeCol) == this.rivalChess) {\n                        // console.log(\"return best position:\" + oppositeRow.toString() + \":\" + oppositeCol.toString());\n                        return newPosition\n                    }\n                }\n            }\n        }\n        return newPosition\n    }\n\n    @inline\n    static getIndexByState(state: Int8Array): i32 {\n        return idxByRowCol(state[0], state[1]);\n    }\n\n    /**\n     * 根据棋型给出分数\n     *\n     * 一个棋型由其中连子的个数和前后是否堵截来确定\n     */\n    private scoreOfStyle(line: i32, block1: boolean, block2: boolean): i32 {\n        if (line == 5) return AIScore.ooooo\n        if (block1 && block2) return 0\n        switch (line) {\n            case 4:\n                return (block1 || block2) ? AIScore.Ioooo : AIScore.oooo\n            case 3:\n                return (block1 || block2) ? AIScore.Iooo : AIScore.ooo\n            case 2:\n                return (block1 || block2) ? AIScore.Ioo : AIScore.oo\n            default:\n                return 0\n        }\n    }\n\n    /**\n     * 根据棋敌方型给出威胁分数\n     *\n     * 一个棋型由其中连子的个数和前后是否堵截来确定\n     */\n    private scoreOfRivalStyle(line: i32, block1: boolean, block2: boolean): i32 {\n        if (line == 5) return AIRivalScore.ooooo\n        if (block1 && block2) return 0\n        switch (line) {\n            case 4:\n                return (block1 || block2) ? AIRivalScore.Ioooo : AIRivalScore.oooo\n            case 3:\n                return (block1 || block2) ? AIRivalScore.Iooo : AIRivalScore.ooo\n            case 2:\n                return (block1 || block2) ? AIRivalScore.Ioo : AIRivalScore.oo\n            default:\n                return 0\n        }\n    }\n\n    /**\n     * 假设在(row, col)处落子, 计算落子后获得的分数 scores[row][col]\n     */\n    private computeScore(row: i32, col: i32, playerChess: Chess): i32 {\n        let score = 0\n        //上、下 (r先减后加, c不变)\n        let r1 = row, c = col\n        let chessboard = this.chessboard;\n        while (r1 > 0 && chessboard.get(r1 - 1, c) == playerChess) r1--\n        let upIsBlocked = (r1 == 0) || chessboard.get(r1 - 1, c) == constants.rival(playerChess)\n        let r2 = row\n        while (r2 < 14 && chessboard.get(r2 + 1, c) == playerChess) r2++\n        let downIsBlocked = (r2 == 14) || chessboard.get(r2 + 1, c) == constants.rival(playerChess)\n        let line = (r1 == r2) ? 1 : (r2 - r1 + 1)\n        // 判断棋型\n        score += (playerChess == this.myChess) ?\n            this.scoreOfStyle(line, upIsBlocked, downIsBlocked) :\n            this.scoreOfRivalStyle(line, upIsBlocked, downIsBlocked)\n\n        //左、右 (r不变, c先减后加)\n        let r = row, c1 = col\n        while (c1 > 0 && chessboard.get(r, c1 - 1) == playerChess) c1--\n        let leftIsBlocked = (c1 == 0) || chessboard.get(r, c1 - 1) == constants.rival(playerChess)\n        let c2 = col\n        while (c2 < 14 && chessboard.get(r, c2 + 1) == playerChess) c2++\n        let rightIsBlocked = (c2 == 14) || chessboard.get(r, c2 + 1) == constants.rival(playerChess)\n        line = (c1 == c2) ? 1 : (c2 - c1 + 1)\n        // 判断棋型\n        score += (playerChess == this.myChess) ?\n            this.scoreOfStyle(line, leftIsBlocked, rightIsBlocked) :\n            this.scoreOfRivalStyle(line, leftIsBlocked, rightIsBlocked)\n\n        //主对角线方向 (rc先减后加)\n        r1 = row, c1 = col\n        while (r1 > 0 && c1 > 0 && chessboard.get(r1 - 1, c1 - 1) == playerChess) {\n            r1--;\n            c1--\n        }\n        let leftUpIsBlocked = (r1 == 0 || c1 == 0) || chessboard.get(r1 - 1, c1 - 1) == constants.rival(playerChess)\n        r2 = row\n        c2 = col\n        while (r2 < 14 && c2 < 14 && chessboard.get(r2 + 1, c2 + 1) == playerChess) {\n            r2++;\n            c2++\n        }\n        let rightDownIsBlocked = (r2 == 14 || c2 == 14) || chessboard.get(r2 + 1, c2 + 1) == constants.rival(playerChess)\n        line = (r1 == r2) ? 1 : (r2 - r1 + 1)\n        // 判断棋型\n        score += (playerChess == 1) ?\n            this.scoreOfStyle(line, leftUpIsBlocked, rightDownIsBlocked) :\n            this.scoreOfRivalStyle(line, leftUpIsBlocked, rightDownIsBlocked)\n\n        //副对角线方向 (r先加后减, c先减后加)\n        r1 = row, c1 = col\n        while (r1 < 14 && c1 > 0 && chessboard.get(r1 + 1, c1 - 1) == playerChess) {\n            r1++;\n            c1--\n        }\n        let leftDownIsBlocked = (r1 == 14 || c1 == 0) || chessboard.get(r1 + 1, c1 - 1) == constants.rival(playerChess)\n        r2 = row\n        c2 = col\n        while (r2 > 0 && c2 < 14 && chessboard.get(r2 - 1, c2 + 1) == playerChess) {\n            r2--;\n            c2++\n        }\n        let rightUpIsBlocked = (r2 == 0 || c2 == 14) || chessboard.get(r2 - 1, c2 + 1) == constants.rival(playerChess)\n        line = (c1 == c2) ? 1 : (c2 - c1 + 1)\n        // 判断棋型\n        score += (playerChess == 1) ?\n            this.scoreOfStyle(line, leftDownIsBlocked, rightUpIsBlocked) :\n            this.scoreOfRivalStyle(line, leftDownIsBlocked, rightUpIsBlocked)\n\n        return score\n    }\n}\n",
    "import \"allocator/tlsf\";\n\nimport {getContextById} from \"../node_modules/as2d/assembly/index\";\nimport {GomokuGUI} from \"./gomoku/GomokuGUI\";\nimport {PlayerRole} from \"./game/GameEngine\";\nimport {BigbenAI} from \"./gomoku/ai/BigbenAI\";\nimport {constants} from \"./gomoku/constants\";\n// import {console} from \"./game/console\";\n\nlet game = new GomokuGUI();\n\nlet aiPlayer: BigbenAI;\nlet myRole: PlayerRole;\nlet rivalRole: PlayerRole;\nlet playWithAI = false;\nlet gameBegin = false;\n\nexport function isGameOver(): boolean {\n    return game.isGameOver()\n}\n\nexport function getState(): Int8Array {\n    return game.getState()\n}\n\nexport function init(_myRole: PlayerRole, _playWithAI: boolean): void {\n    playWithAI = _playWithAI;\n    myRole = _myRole;\n    rivalRole = constants.rivalPlayer(myRole)\n    let ctx = getContextById(\"main\");\n    game.init(ctx, myRole);\n    if (playWithAI) {\n        aiPlayer = new BigbenAI(rivalRole, newState => {\n            rivalUpdate(newState)\n        });\n    }\n}\n\nexport function startGame(): void {\n    gameBegin = true;\n    aiPlayer.startGame();\n}\n\nexport function draw(): void {\n    game.draw();\n}\n\nexport function onClick(x: i32, y: i32): Int8Array {\n    if (!gameBegin) {\n        // console.error(\"Game not begin.\");\n        return new Int8Array(0);\n    }\n    let state = game.onClick(x, y);\n    if (state.length == 2 && playWithAI) {\n        aiPlayer.update(state);\n    }\n    return state;\n}\n\nexport function rivalUpdate(newState: Int8Array): void {\n    if (gameBegin) {\n        game.update(rivalRole, newState)\n    } else {\n        // console.log(\"Game not begin, but receive rivalUpdate.\")\n    }\n}\n\nexport function loadState(fullState: Int8Array): void {\n    game.loadState(fullState);\n    if (playWithAI) {\n        aiPlayer.loadState(fullState);\n    }\n}\n",
    "import {CanvasRenderingContext2D} from \"../../node_modules/as2d/assembly/index\";\nimport {PlayerRole} from \"./GameEngine\";\nimport {console} from \"./console\";\n\nexport declare namespace engine {\n\n    // @ts-ignore\n    @external(\"engine\", \"update\")\n    function update(player: PlayerRole, state: Int8Array): boolean;\n\n    // @ts-ignore\n    @external(\"engine\", \"loadState\")\n    function loadState(fullState: Int8Array): void;\n\n    // @ts-ignore\n    @external(\"engine\", \"getState\")\n    function getState(): Int8Array;\n\n    // @ts-ignore\n    @external(\"engine\", \"isGameOver\")\n    function isGameOver(): boolean;\n\n    // @ts-ignore\n    @external(\"engine\", \"getWinner\")\n    function getWinner(): PlayerRole;\n\n}\n\nexport abstract class GameGUI {\n\n    player: PlayerRole;\n    ctx: CanvasRenderingContext2D;\n\n    init(ctx: CanvasRenderingContext2D, player: PlayerRole): void {\n        // console.log(\"GameGUI init\");\n        this.ctx = ctx;\n        this.player = player;\n    }\n\n    draw(): void {\n    }\n\n    update(player: PlayerRole, state: Int8Array): boolean {\n        return false\n    }\n\n\n    loadState(fullState: Int8Array): void {\n    }\n\n    getState(): Int8Array {\n        return engine.getState()\n    }\n\n    isGameOver(): boolean {\n        return engine.isGameOver()\n    }\n\n    getWinner(): PlayerRole {\n        return engine.getWinner()\n    }\n}\n",
    "import {GameEngine, listener, PlayerRole} from \"../game/GameEngine\";\nimport {console} from \"../game/console\";\nimport {Chess, constants} from \"./constants\";\n\nclass Position {\n\n    constructor(public row: i32, public col: i32) {\n    }\n\n    static fromState(state: Int8Array): Position {\n        if (state.length != 2) {\n            throw ERROR(\"Invalid state\")\n        }\n        return new Position(state[0], state[1])\n    }\n\n    static fromIndex(idx: i32): Position {\n        if (idx < 0 || idx >= constants.boardSize) {\n            throw ERROR(\"Invalid index\")\n        }\n        return new Position(idx / constants.boardDimension, idx % constants.boardDimension)\n    }\n\n    toIndex(): i32 {\n        if (this.row >= constants.boardDimension || this.col >= constants.boardDimension) {\n            return -1\n        }\n        return constants.boardDimension * this.row + this.col;\n    }\n\n    toState(): Int8Array {\n        let state = new Int8Array(2);\n        state[0] = this.row;\n        state[1] = this.col;\n        return state;\n    }\n\n    toString(): String {\n        return this.row.toString() + \":\" + this.col.toString()\n    }\n}\n\nclass Chessboard {\n    readonly board: Int8Array = new Int8Array(constants.boardSize);\n\n    hasChess(row: i32, col: i32): boolean {\n        return constants.validRowAndCol(row, col) ? this.get(row, col) != Chess.None : false;\n    }\n\n    getChess(row: i32, col: i32): Chess {\n        return constants.validRowAndCol(row, col) ? this.get(row, col) : Chess.None\n    }\n\n    @inline\n    get(row: i32, col: i32): Chess {\n        return this.board[constants.boardDimension * row + col];\n    }\n\n    @inline\n    put(row: i32, col: i32, chess: Chess): void {\n        this.board[constants.boardDimension * row + col] = chess\n    }\n\n    @inline\n    clear(row: i32, col: i32): void {\n        this.board[constants.boardDimension * row + col] = Chess.None\n    }\n\n    putChess(row: i32, col: i32, chess: Chess): void {\n        if (constants.validRowAndCol(row, col)) {\n            this.put(row, col, chess);\n        } else {\n            throw ERROR(\"Invalid put position.\")\n        }\n    }\n\n    // @ts-ignore\n    @inline\n    isFull(): boolean {\n        return this.findEmptyPosition() == null;\n    }\n\n    // @ts-ignore\n    @inline\n    isEmpty(): boolean {\n        for (let i = 0, len = this.board.length; i < len; i++) {\n            if (this.board[i] != Chess.None) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // @ts-ignore\n    @inline\n    findEmptyPosition(): Position | null {\n        return this.findPosition(Chess.None);\n    }\n\n    findPosition(chess: Chess): Position | null {\n        let position: Position | null = null;\n        for (let i = 0, len = this.board.length; i < len; i++) {\n            if (this.board[i] == chess) {\n                position = Position.fromIndex(i);\n                break\n            }\n        }\n        return position\n    }\n\n    load(fullState: Int8Array): void {\n        let len = this.board.length;\n        assert(len == fullState.length);\n        for (let i = 0; i < len; i++) {\n            this.board[i] = fullState[i];\n        }\n    }\n\n    nextPlayer(): PlayerRole {\n        let chessDiff = 0;\n        for (let i = 0, len = this.board.length; i < len; i++) {\n            let value = this.board[i];\n            if (value == Chess.Black) {\n                chessDiff = chessDiff - 1;\n            } else if (value == Chess.White) {\n                chessDiff = chessDiff + 1;\n            }\n        }\n        if (chessDiff == 0) {\n            return PlayerRole.First\n        } else if (chessDiff > 0) {\n            return PlayerRole.Second\n        } else {\n            throw ERROR(\"Invalid state.\");\n        }\n    }\n}\n\nclass GomokuAction {\n    row: i32;\n    col: i32;\n    player: PlayerRole;\n}\n\nclass GomokuEngine extends GameEngine {\n\n    private readonly chessboard: Chessboard = new Chessboard();\n\n    lastAction: GomokuAction;\n    currentPlayer: PlayerRole = PlayerRole.First;\n    gameIsOver: boolean = false;\n\n    init(): void {\n        // console.log(\"GomokuEngine init\");\n    }\n\n    update(player: PlayerRole, state: Int8Array): boolean {\n        if (this.gameIsOver) {\n            // console.log(\"game is over.\")\n            return false\n        }\n        console.logAction(\"GomokuEngine update\", player, state);\n        if (state.length != 2) {\n            // console.log(\"Invalid state\");\n            return false;\n        }\n        if (this.currentPlayer != player) {\n            // console.log(\"Not your turn.\")\n            return false;\n        }\n        let row: i32 = state[0];\n        let col: i32 = state[1];\n        if (this.putChessOn(row, col)) {\n            listener.onUpdate(player, state);\n            this.lastAction = {\n                row,\n                col,\n                player: this.currentPlayer\n            };\n            if (!this.checkLastAction()) {\n                this.currentPlayer = constants.rivalPlayer(this.currentPlayer);\n            }\n            return true;\n        }\n        return false;\n    }\n\n    @inline\n    loadState(fullState: Int8Array): void {\n        this.chessboard.load(fullState);\n        this.currentPlayer = this.chessboard.nextPlayer();\n    }\n\n    @inline\n    getState(): Int8Array {\n        return this.chessboard.board;\n    }\n\n    @inline\n    isGameOver(): boolean {\n        return this.gameIsOver;\n    }\n\n    @inline\n    getWinner(): PlayerRole {\n        if(this.gameIsOver){\n            return this.currentPlayer;\n        }else{\n            return PlayerRole.None\n        }\n    }\n\n    private putChessOn(row: i32, col: i32): boolean {\n        if (constants.validRowAndCol(row, col) && !this.chessboard.hasChess(row, col)) {\n            this.chessboard.putChess(row, col, constants.chessOfPlayer(this.currentPlayer));\n            return true\n        }\n        return false\n    }\n\n    @inline\n    public getChessOn(row: i32, col: i32): Chess {\n        return this.chessboard.getChess(row, col)\n    }\n\n    /**\n     * return is gamer over.\n     */\n    private checkLastAction(): boolean {\n        let lastAction = this.lastAction;\n        let row = lastAction.row;\n        let col = lastAction.col;\n        let player = lastAction.player;\n        if (this.checkRow(row, player)\n            || this.checkColumn(col, player)\n            || this.checkMainDiagonal(row, col, player)\n            || this.checkSubDiagonal(row, col, player)) {\n\n            this.gameIsOver = true;\n            // console.logAction(\"Game is over, winner:\", this.currentPlayer, this.chessboard.board);\n            listener.onGameOver(this.currentPlayer)\n            return true;\n        }\n        return false;\n    }\n\n    private checkRow(row: i32, forPlayer: PlayerRole): boolean {\n        let count = 0\n        for (let col = 0, dim = constants.boardDimension; col < dim; col++) {\n            if (this.chessboard.getChess(row, col) == constants.chessOfPlayer(forPlayer)) {\n                count = count + 1\n                if (count == 5) {\n                    // console.log(\"checkRow gameIsOver\")\n                    return true\n                }\n            } else {\n                count = 0\n            }\n        }\n        return false\n    }\n\n    private checkColumn(col: i32, forPlayer: PlayerRole): boolean {\n        let count = 0\n        for (let row = 0, dim = constants.boardDimension; row <= dim; row++) {\n            if (this.chessboard.getChess(row, col) == constants.chessOfPlayer(forPlayer)) {\n                count = count + 1\n                if (count == 5) {\n                    // console.log(\"checkColumn gameIsOver\")\n                    return true\n                }\n            } else {\n                count = 0\n            }\n        }\n        return false\n    }\n\n    private checkMainDiagonal(row: i32, col: i32, forPlayer: PlayerRole): boolean {\n        let count = 0\n        let fromR: i32, fromC: i32, toR: i32, toC: i32\n        if (col >= row) {\n            fromR = 0\n            fromC = col - row\n            toR = 15 - col + row - 1\n            toC = 15 - 1\n        } else {\n            fromR = row - col\n            fromC = 0\n            toR = 15 - 1\n            toC = 15 + col - row - 1\n        }\n        while (fromR <= toR && fromC <= toC) {\n            if (this.chessboard.getChess(fromR, fromC) == constants.chessOfPlayer(forPlayer)) {\n                count = count + 1\n                if (count == 5) {\n                    // console.log(\"checkMainDiagonal gameIsOver\")\n                    return true\n                }\n            } else {\n                count = 0\n            }\n            fromR++\n            fromC++\n        }\n        return false\n    }\n\n    private checkSubDiagonal(row: i32, col: i32, forPlayer: PlayerRole): boolean {\n        let count = 0\n        let fromR: i32, fromC: i32, toR: i32, toC: i32\n        if (col + row <= 16) {\n            fromR = 0\n            fromC = row + col\n            toR = row + col\n            toC = 0\n        } else {\n            fromR = row + col - (15 - 1)\n            fromC = (15 - 1)\n            toR = (15 - 1)\n            toC = row + col - (15 - 1)\n        }\n        let chessboard = this.chessboard;\n        while (fromR <= toR && fromC >= toC) {\n            if (chessboard.getChess(fromR, fromC) == constants.chessOfPlayer(forPlayer)) {\n                count = count + 1\n                if (count == 5) {\n                    // console.log(\"checkSubDiagonal gameIsOver\")\n                    return true\n                }\n            } else {\n                count = 0\n            }\n            fromR++\n            fromC--\n        }\n        return false\n    }\n\n    @inline\n    getChessBoard(): Int8Array {\n        return this.chessboard.board\n    }\n\n}\n\nexport {GomokuAction, Chessboard, Position, GomokuEngine}\n",
    "import {\n  TypedArray,\n  FILL,\n  SORT,\n  SUBARRAY,\n  REDUCE,\n  REDUCE_RIGHT,\n  MAP,\n  FIND_INDEX,\n  SOME,\n  EVERY,\n  FOREACH,\n  REVERSE,\n} from \"./internal/typedarray\";\n\nimport {\n  COMPARATOR\n} from \"./internal/sort\";\n\nfunction clampToByte(value: i32): i32 {\n  return ~(value >> 31) & (((255 - value) >> 31) | value); // & 255\n}\n\nexport class Int8Array extends TypedArray<i8> {\n  @lazy static readonly BYTES_PER_ELEMENT: usize = sizeof<i8>();\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    return FILL<Int8Array, i8>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i8, b: i8) => i32 = COMPARATOR<i8>()): Int8Array {\n    return SORT<Int8Array, i8>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Int8Array {\n    return SUBARRAY<Int8Array, i8>(this, begin, end);\n  }\n\n  reduce<T>(\n    callbackfn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int8Array, i8, T>(this, callbackfn, initialValue);\n  }\n\n  reduceRight<T>(\n    callbackfn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int8Array, i8, T>(this, callbackfn, initialValue);\n  }\n\n  map(callbackfn: (value: i8, index: i32, self: Int8Array) => i8): Int8Array {\n    return MAP<Int8Array, i8>(this, callbackfn);\n  }\n\n  findIndex(callbackfn: (value: i8, index: i32, self: Int8Array) => bool): i32 {\n    return FIND_INDEX<Int8Array, i8>(this, callbackfn);\n  }\n\n  some(callbackfn: (value: i8, index: i32, self: Int8Array) => bool): bool {\n    return SOME<Int8Array, i8>(this, callbackfn);\n  }\n\n  every(callbackfn: (value: i8, index: i32, self: Int8Array) => bool): bool {\n    return EVERY<Int8Array, i8>(this, callbackfn);\n  }\n\n  forEach(callbackfn: (value: i8, index: i32, self: Int8Array) => void): void {\n    FOREACH<Int8Array, i8>(this, callbackfn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, i8>(this);\n  }\n}\n\nexport class Uint8Array extends TypedArray<u8> {\n  @lazy static readonly BYTES_PER_ELEMENT: usize = sizeof<u8>();\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return FILL<Uint8Array, u8>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8Array {\n    return SORT<Uint8Array, u8>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Uint8Array {\n    return SUBARRAY<Uint8Array, u8>(this, begin, end);\n  }\n\n  reduce<T>(\n    callbackfn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint8Array, u8, T>(this, callbackfn, initialValue);\n  }\n\n  reduceRight<T>(\n    callbackfn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint8Array, u8, T>(this, callbackfn, initialValue);\n  }\n\n  map(callbackfn: (value: u8, index: i32, self: Uint8Array) => u8): Uint8Array {\n    return MAP<Uint8Array, u8>(this, callbackfn);\n  }\n\n  findIndex(callbackfn: (value: u8, index: i32, self: Uint8Array) => bool): i32 {\n    return FIND_INDEX<Uint8Array, u8>(this, callbackfn);\n  }\n\n  some(callbackfn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\n    return SOME<Uint8Array, u8>(this, callbackfn);\n  }\n\n  every(callbackfn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\n    return EVERY<Uint8Array, u8>(this, callbackfn);\n  }\n\n  forEach(callbackfn: (value: u8, index: i32, self: Uint8Array) => void): void {\n    FOREACH<Uint8Array, u8>(this, callbackfn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, u8>(this);\n  }\n}\n\nexport class Uint8ClampedArray extends Uint8Array {\n  @lazy static readonly BYTES_PER_ELEMENT: usize = sizeof<u8>();\n\n  @inline @operator(\"[]=\")\n  protected __set(index: i32, value: i32): void {\n    super.__set(index, clampToByte(value));\n  }\n\n  @inline @operator(\"{}=\")\n  protected __unchecked_set(index: i32, value: i32): void {\n    super.__unchecked_set(index, clampToByte(value));\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return changetype<Uint8ClampedArray>(super.fill(value, start, end)); // safe because '.fill' reuses 'this'\n  }\n\n  sort(comparator: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8ClampedArray {\n    return changetype<Uint8ClampedArray>(super.sort(comparator)); // safe because '.sort' reuses 'this'\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Uint8ClampedArray {\n    return SUBARRAY<Uint8ClampedArray, u8>(this, begin, end);\n  }\n\n  reduce<T>(\n    callbackfn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint8ClampedArray, u8, T>(this, callbackfn, initialValue);\n  }\n\n  reduceRight<T>(\n    callbackfn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint8ClampedArray, u8, T>(this, callbackfn, initialValue);\n  }\n\n  map(callbackfn: (value: u8, index: i32, self: Uint8ClampedArray) => u8): Uint8ClampedArray {\n    return MAP<Uint8ClampedArray, u8>(this, callbackfn);\n  }\n\n  findIndex(callbackfn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): i32 {\n    return FIND_INDEX<Uint8ClampedArray, u8>(this, callbackfn);\n  }\n\n  some(callbackfn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\n    return SOME<Uint8ClampedArray, u8>(this, callbackfn);\n  }\n\n  every(callbackfn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\n    return EVERY<Uint8ClampedArray, u8>(this, callbackfn);\n  }\n\n  forEach(callbackfn: (value: u8, index: i32, self: Uint8ClampedArray) => void): void {\n    FOREACH<Uint8ClampedArray, u8>(this, callbackfn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, u8>(this);\n  }\n}\n\nexport class Int16Array extends TypedArray<i16> {\n  @lazy static readonly BYTES_PER_ELEMENT: usize = sizeof<i16>();\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    return FILL<Int16Array, i16>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i16, b: i16) => i32 = COMPARATOR<i16>()): Int16Array {\n    return SORT<Int16Array, i16>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Int16Array {\n    return SUBARRAY<Int16Array, i16>(this, begin, end);\n  }\n\n  reduce<T>(\n    callbackfn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int16Array, i16, T>(this, callbackfn, initialValue);\n  }\n\n  reduceRight<T>(\n    callbackfn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int16Array, i16, T>(this, callbackfn, initialValue);\n  }\n\n  map(callbackfn: (value: i16, index: i32, self: Int16Array) => i16): Int16Array {\n    return MAP<Int16Array, i16>(this, callbackfn);\n  }\n\n  findIndex(callbackfn: (value: i16, index: i32, self: Int16Array) => bool): i32 {\n    return FIND_INDEX<Int16Array, i16>(this, callbackfn);\n  }\n\n  some(callbackfn: (value: i16, index: i32, self: Int16Array) => bool): bool {\n    return SOME<Int16Array, i16>(this, callbackfn);\n  }\n\n  every(callbackfn: (value: i16, index: i32, self: Int16Array) => bool): bool {\n    return EVERY<Int16Array, i16>(this, callbackfn);\n  }\n\n  forEach(callbackfn: (value: i16, index: i32, self: Int16Array) => void): void {\n    FOREACH<Int16Array, i16>(this, callbackfn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, i16>(this);\n  }\n}\n\nexport class Uint16Array extends TypedArray<u16> {\n  @lazy static readonly BYTES_PER_ELEMENT: usize = sizeof<u16>();\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return FILL<Uint16Array, u16>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u16, b: u16) => i32 = COMPARATOR<u16>()): Uint16Array {\n    return SORT<Uint16Array, u16>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Uint16Array {\n    return SUBARRAY<Uint16Array, u16>(this, begin, end);\n  }\n\n  reduce<T>(\n    callbackfn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint16Array, u16, T>(this, callbackfn, initialValue);\n  }\n\n  reduceRight<T>(\n    callbackfn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint16Array, u16, T>(this, callbackfn, initialValue);\n  }\n\n  map(callbackfn: (value: u16, index: i32, self: Uint16Array) => u16): Uint16Array {\n    return MAP<Uint16Array, u16>(this, callbackfn);\n  }\n\n  findIndex(callbackfn: (value: u16, index: i32, self: Uint16Array) => bool): i32 {\n    return FIND_INDEX<Uint16Array, u16>(this, callbackfn);\n  }\n\n  some(callbackfn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\n    return SOME<Uint16Array, u16>(this, callbackfn);\n  }\n\n  every(callbackfn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\n    return EVERY<Uint16Array, u16>(this, callbackfn);\n  }\n\n  forEach(callbackfn: (value: u16, index: i32, self: Uint16Array) => void): void {\n    FOREACH<Uint16Array, u16>(this, callbackfn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, u16>(this);\n  }\n}\n\nexport class Int32Array extends TypedArray<i32> {\n  @lazy static readonly BYTES_PER_ELEMENT: usize = sizeof<i32>();\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    return FILL<Int32Array, i32>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i32, b: i32) => i32 = COMPARATOR<i32>()): Int32Array {\n    return SORT<Int32Array, i32>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Int32Array {\n    return SUBARRAY<Int32Array, i32>(this, begin, end);\n  }\n\n  reduce<T>(\n    callbackfn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int32Array, i32, T>(this, callbackfn, initialValue);\n  }\n\n  reduceRight<T>(\n    callbackfn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int32Array, i32, T>(this, callbackfn, initialValue);\n  }\n\n  map(callbackfn: (value: i32, index: i32, self: Int32Array) => i32): Int32Array {\n    return MAP<Int32Array, i32>(this, callbackfn);\n  }\n\n  findIndex(callbackfn: (value: i32, index: i32, self: Int32Array) => bool): i32 {\n    return FIND_INDEX<Int32Array, i32>(this, callbackfn);\n  }\n\n  some(callbackfn: (value: i32, index: i32, self: Int32Array) => bool): bool {\n    return SOME<Int32Array, i32>(this, callbackfn);\n  }\n\n  every(callbackfn: (value: i32, index: i32, self: Int32Array) => bool): bool {\n    return EVERY<Int32Array, i32>(this, callbackfn);\n  }\n\n  forEach(callbackfn: (value: i32, index: i32, self: Int32Array) => void): void {\n    FOREACH<Int32Array, i32>(this, callbackfn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, i32>(this);\n  }\n}\n\nexport class Uint32Array extends TypedArray<u32> {\n  @lazy static readonly BYTES_PER_ELEMENT: usize = sizeof<u32>();\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return FILL<Uint32Array, u32>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u32, b: u32) => i32 = COMPARATOR<u32>()): Uint32Array {\n    return SORT<Uint32Array, u32>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Uint32Array {\n    return SUBARRAY<Uint32Array, u32>(this, begin, end);\n  }\n\n  reduce<T>(\n    callbackfn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint32Array, u32, T>(this, callbackfn, initialValue);\n  }\n\n  reduceRight<T>(\n    callbackfn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint32Array, u32, T>(this, callbackfn, initialValue);\n  }\n\n  map(callbackfn: (value: u32, index: i32, self: Uint32Array) => u32): Uint32Array {\n    return MAP<Uint32Array, u32>(this, callbackfn);\n  }\n\n  findIndex(callbackfn: (value: u32, index: i32, self: Uint32Array) => bool): i32 {\n    return FIND_INDEX<Uint32Array, u32>(this, callbackfn);\n  }\n\n  some(callbackfn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\n    return SOME<Uint32Array, u32>(this, callbackfn);\n  }\n\n  every(callbackfn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\n    return EVERY<Uint32Array, u32>(this, callbackfn);\n  }\n\n  forEach(callbackfn: (value: u32, index: i32, self: Uint32Array) => void): void {\n    FOREACH<Uint32Array, u32>(this, callbackfn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, u32>(this);\n  }\n}\n\nexport class Int64Array extends TypedArray<i64> {\n  @lazy static readonly BYTES_PER_ELEMENT: usize = sizeof<i64>();\n\n  fill(value: i64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    return FILL<Int64Array, i64>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i64, b: i64) => i32 = COMPARATOR<i64>()): Int64Array {\n    return SORT<Int64Array, i64>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Int64Array {\n    return SUBARRAY<Int64Array, i64>(this, begin, end);\n  }\n\n  reduce<T>(\n    callbackfn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int64Array, i64, T>(this, callbackfn, initialValue);\n  }\n\n  reduceRight<T>(\n    callbackfn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int64Array, i64, T>(this, callbackfn, initialValue);\n  }\n\n  map(callbackfn: (value: i64, index: i32, self: Int64Array) => i64): Int64Array {\n    return MAP<Int64Array, i64>(this, callbackfn);\n  }\n\n  findIndex(callbackfn: (value: i64, index: i32, self: Int64Array) => bool): i32 {\n    return FIND_INDEX<Int64Array, i64>(this, callbackfn);\n  }\n\n  some(callbackfn: (value: i64, index: i32, self: Int64Array) => bool): bool {\n    return SOME<Int64Array, i64>(this, callbackfn);\n  }\n\n  every(callbackfn: (value: i64, index: i32, self: Int64Array) => bool): bool {\n    return EVERY<Int64Array, i64>(this, callbackfn);\n  }\n\n  forEach(callbackfn: (value: i64, index: i32, self: Int64Array) => void): void {\n    FOREACH<Int64Array, i64>(this, callbackfn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, i64>(this);\n  }\n}\n\nexport class Uint64Array extends TypedArray<u64> {\n  @lazy static readonly BYTES_PER_ELEMENT: usize = sizeof<u64>();\n\n  fill(value: u64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return FILL<Uint64Array, u64>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u64, b: u64) => i32 = COMPARATOR<u64>()): Uint64Array {\n    return SORT<Uint64Array, u64>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Uint64Array {\n    return SUBARRAY<Uint64Array, u64>(this, begin, end);\n  }\n\n  reduce<T>(\n    callbackfn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint64Array, u64, T>(this, callbackfn, initialValue);\n  }\n\n  reduceRight<T>(\n    callbackfn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint64Array, u64, T>(this, callbackfn, initialValue);\n  }\n\n  map(callbackfn: (value: u64, index: i32, self: Uint64Array) => u64): Uint64Array {\n    return MAP<Uint64Array, u64>(this, callbackfn);\n  }\n\n  findIndex(callbackfn: (value: u64, index: i32, self: Uint64Array) => bool): i32 {\n    return FIND_INDEX<Uint64Array, u64>(this, callbackfn);\n  }\n\n  some(callbackfn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\n    return SOME<Uint64Array, u64>(this, callbackfn);\n  }\n\n  every(callbackfn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\n    return EVERY<Uint64Array, u64>(this, callbackfn);\n  }\n\n  forEach(callbackfn: (value: u64, index: i32, self: Uint64Array) => void): void {\n    FOREACH<Uint64Array, u64>(this, callbackfn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, u64>(this);\n  }\n}\n\nexport class Float32Array extends TypedArray<f32> {\n  @lazy static readonly BYTES_PER_ELEMENT: usize = sizeof<f32>();\n\n  fill(value: f32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    return FILL<Float32Array, f32>(this, value, start, end);\n  }\n\n  sort(comparator: (a: f32, b: f32) => i32 = COMPARATOR<f32>()): Float32Array {\n    return SORT<Float32Array, f32>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Float32Array {\n    return SUBARRAY<Float32Array, f32>(this, begin, end);\n  }\n\n  reduce<T>(\n    callbackfn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Float32Array, f32, T>(this, callbackfn, initialValue);\n  }\n\n  reduceRight<T>(\n    callbackfn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Float32Array, f32, T>(this, callbackfn, initialValue);\n  }\n\n  map(callbackfn: (value: f32, index: i32, self: Float32Array) => f32): Float32Array {\n    return MAP<Float32Array, f32>(this, callbackfn);\n  }\n\n  findIndex(callbackfn: (value: f32, index: i32, self: Float32Array) => bool): i32 {\n    return FIND_INDEX<Float32Array, f32>(this, callbackfn);\n  }\n\n  some(callbackfn: (value: f32, index: i32, self: Float32Array) => bool): bool {\n    return SOME<Float32Array, f32>(this, callbackfn);\n  }\n\n  every(callbackfn: (value: f32, index: i32, self: Float32Array) => bool): bool {\n    return EVERY<Float32Array, f32>(this, callbackfn);\n  }\n\n  forEach(callbackfn: (value: f32, index: i32, self: Float32Array) => void): void {\n    FOREACH<Float32Array, f32>(this, callbackfn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, f32>(this);\n  }\n}\n\nexport class Float64Array extends TypedArray<f64> {\n  @lazy static readonly BYTES_PER_ELEMENT: usize = sizeof<f64>();\n\n  fill(value: f64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    return FILL<Float64Array, f64>(this, value, start, end);\n  }\n\n  sort(comparator: (a: f64, b: f64) => i32 = COMPARATOR<f64>()): Float64Array {\n    return SORT<Float64Array, f64>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Float64Array {\n    return SUBARRAY<Float64Array, f64>(this, begin, end);\n  }\n\n  reduce<T>(\n    callbackfn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Float64Array, f64, T>(this, callbackfn, initialValue);\n  }\n\n  reduceRight<T>(\n    callbackfn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Float64Array, f64, T>(this, callbackfn, initialValue);\n  }\n\n  map(callbackfn: (value: f64, index: i32, self: Float64Array) => f64): Float64Array {\n    return MAP<Float64Array, f64>(this, callbackfn);\n  }\n\n  findIndex(callbackfn: (value: f64, index: i32, self: Float64Array) => bool): i32 {\n    return FIND_INDEX<Float64Array, f64>(this, callbackfn);\n  }\n\n  some(callbackfn: (value: f64, index: i32, self: Float64Array) => bool): bool {\n    return SOME<Float64Array, f64>(this, callbackfn);\n  }\n\n  every(callbackfn: (value: f64, index: i32, self: Float64Array) => bool): bool {\n    return EVERY<Float64Array, f64>(this, callbackfn);\n  }\n\n  forEach(callbackfn: (value: f64, index: i32, self: Float64Array) => void): void {\n    FOREACH<Float64Array, f64>(this, callbackfn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, f64>(this);\n  }\n}\n",
    "@inline\nexport function arraysEqual(left: Float64Array, right: Float64Array): bool {\n  var len: i32 = left.length;\n  var valid = true;\n  if (len == right.length) {\n    for (var i = 0; i < len; i++) {\n      if (unchecked(left[i]) != unchecked(right[i])) {\n        valid = false;\n        break;\n      }\n    }\n  } else {\n    valid = false;\n  }\n  return valid;\n}\n\n@inline\nexport function checkDoubleArray(value: Float64Array): Float64Array {\n  var len: i32 = value.length;\n  var double: bool = <bool>(len & 1);\n  var result: Float64Array = new Float64Array(double ? len * 2 : len);\n  var doublelen: i32;\n  var i: i32 = 0;\n  for (;i < len; ++i) {\n    unchecked(result[i] = value[i]);\n  }\n  if (double) {\n    doublelen = len << 1;\n    for(;i < doublelen; i++) {\n      unchecked(result[i] = value[i - len]);\n    }\n  }\n  return result;\n}\n"
  ]
}
