{"version":3,"sources":["node_modules/as2d/node_modules/assemblyscript/lib/loader/index.js","../../src/shared/CanvasPatternRepetition.ts","../../src/shared/FillRule.ts","../../src/shared/ImageSmoothingQuality.ts","../../src/shared/GlobalCompositeOperationValue.ts","../../src/shared/CanvasDirection.ts","../../src/shared/TextAlign.ts","../../src/shared/TextBaseline.ts","../../src/shared/LineCap.ts","../../src/shared/LineJoin.ts","../../src/glue/AS2DGlue.ts","../../src/shared/GlobalCompositeOperation.ts","../src/index.ts","node_modules/assemblyscript/lib/loader/index.js","src/vm.ts","src/index.ts"],"names":[],"mappings":"AaAA,aAEA,MAAA,EAAA,oBAAA,eACA,EAAA,SAGA,SAAA,EAAA,EAAA,EAAA,GACA,IACA,EAAA,EAAA,IAAA,EACA,EAFA,EAAA,IAAA,GAGA,EAAA,GAEA,KAAA,EADA,MACA,CACA,IAAA,EAAA,EAAA,EAFA,KAEA,GACA,EAAA,GAAA,OAAA,EAAA,MAAA,KAHA,KAIA,EAAA,EAAA,SAAA,EAAA,GAAA,GACA,EAAA,KAAA,OAAA,aAAA,MAAA,OAAA,IACA,GAAA,EAEA,OAAA,EAAA,KAAA,IAAA,OAAA,aAAA,MAAA,OAAA,EAAA,SAAA,EAAA,EAAA,IAIA,SAAA,EAAA,GACA,IAAA,EAAA,GAEA,SAAA,EAAA,EAAA,GACA,IAAA,EAAA,MAAA,gBACA,IAAA,EAAA,EAAA,OACA,OAAA,EAAA,IAAA,YAAA,GAAA,IAAA,YAAA,GAAA,GAIA,IAAA,EAAA,EAAA,IAAA,EAAA,KAAA,GAYA,OAXA,EAAA,MAAA,EAAA,OAAA,SAAA,EAAA,EAAA,EAAA,GACA,IAAA,EAAA,EAAA,QAAA,EAAA,OACA,MAAA,MAAA,UAAA,EAAA,EAAA,GAAA,OAAA,EAAA,EAAA,GAAA,IAAA,EAAA,IAAA,IAEA,EAAA,MAAA,EAAA,OAAA,SAAA,EAAA,GACA,IAAA,EAAA,EAAA,QAAA,EAAA,OACA,QAAA,IAAA,UAAA,EAAA,EAAA,IAAA,EAAA,IAAA,IAAA,MAAA,UAAA,MAAA,KAAA,UAAA,EAAA,EAAA,GAAA,KAAA,QAEA,EAAA,KAAA,EAAA,MAAA,KACA,EAAA,KAAA,EAAA,MAAA,KAEA,EAIA,SAAA,EAAA,EAAA,GACA,IASA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EATA,EAAA,EAAA,QACA,EAAA,EAAA,OACA,EAAA,EAAA,mBACA,EAAA,EAAA,eACA,EAAA,EAAA,eACA,EAAA,EAAA,MACA,EAAA,EAAA,UAAA,aAMA,SAAA,IAEA,IAAA,EAAA,SACA,EAAA,EAAA,OACA,EAAA,IAAA,UAAA,GACA,EAAA,IAAA,WAAA,GACA,EAAA,IAAA,WAAA,GACA,EAAA,IAAA,YAAA,GACA,EAAA,IAAA,WAAA,GACA,EAAA,IAAA,YAAA,GACA,IACA,EAAA,IAAA,cAAA,GACA,EAAA,IAAA,eAAA,IAEA,EAAA,IAAA,aAAA,GACA,EAAA,IAAA,aAAA,IAkHA,OA/GA,IAaA,EAAA,UAVA,SAAA,GACA,IAAA,EAAA,EAAA,OACA,EAAA,EAAA,GAAA,GAAA,IACA,EAAA,EAAA,IAAA,EACA,IACA,EAAA,IAAA,GAAA,EACA,IAAA,IAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,EAAA,GAAA,EAAA,WAAA,GACA,OAAA,GAWA,EAAA,UALA,SAAA,GAEA,OADA,IACA,EAAA,EAAA,EAAA,IA0CA,EAAA,SA/BA,SAAA,EAAA,EAAA,GACA,IAAA,EAAA,EAAA,YACA,IAAA,UACA,EAAA,EACA,EAAA,WAEA,IAAA,IAAA,EAAA,EAAA,QAEA,IAAA,EAAA,EAAA,kBACA,IAAA,EAAA,MAAA,MAAA,qBACA,IAAA,EAAA,EAAA,EACA,EAAA,EAAA,IACA,EAAA,EAlBA,SAAA,GAEA,OAAA,GAAA,GAAA,KAAA,MAAA,EADA,EACA,GAgBA,CAAA,IAOA,GANA,IACA,EAAA,IAAA,GAAA,EACA,EAAA,EAAA,IAAA,GAAA,EACA,EAAA,EAAA,IAAA,GAAA,EACA,EAAA,IAAA,GAAA,EACA,EAAA,EAAA,IAAA,GAAA,EACA,GAEA,GADA,IAAA,EAAA,EAAA,EAAA,EAAA,GAAA,IAAA,GACA,EAAA,OAAA,IAAA,EAAA,CACA,IAAA,EAAA,EAAA,EAAA,OACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,SAEA,GACA,EAAA,EAAA,EAAA,EAAA,GAEA,OAAA,GAgBA,EAAA,SAVA,SAAA,EAAA,GACA,IAAA,EAAA,EAAA,kBACA,IAAA,EAAA,MAAA,MAAA,qBACA,IACA,IAAA,EAAA,EAAA,IAAA,GACA,EAAA,EAAA,EAAA,IAAA,GACA,EAAA,EAAA,EAAA,IAAA,GACA,OAAA,IAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,GAAA,IAaA,EAAA,UAPA,SAAA,GACA,IACA,IAAA,EAAA,EAAA,IAAA,GACA,EAAA,GACA,EAAA,IAiBA,EAAA,YARA,SAAA,GACA,mBAAA,EAAA,WAAA,EAAA,EAAA,UACA,IAAA,EAAA,EAAA,OAGA,OAFA,EAAA,KAAA,GACA,EAAA,IAAA,EAAA,GACA,GAUA,EAAA,YAJA,SAAA,GACA,OAAA,EAAA,EAAA,IAAA,GAAA,IAMA,EAAA,OAAA,EAAA,QAAA,EACA,EAAA,MAAA,EAAA,OAAA,EAGA,EAAA,EAAA,OAAA,iBAAA,EAAA,CACA,GAAA,CAAA,IAAA,WAAA,OAAA,IAAA,IACA,GAAA,CAAA,IAAA,WAAA,OAAA,IAAA,IACA,IAAA,CAAA,IAAA,WAAA,OAAA,IAAA,IACA,IAAA,CAAA,IAAA,WAAA,OAAA,IAAA,IACA,IAAA,CAAA,IAAA,WAAA,OAAA,IAAA,IACA,IAAA,CAAA,IAAA,WAAA,OAAA,IAAA,IACA,IAAA,CAAA,IAAA,WAAA,OAAA,IAAA,IACA,IAAA,CAAA,IAAA,WAAA,OAAA,IAAA,IACA,IAAA,CAAA,IAAA,WAAA,OAAA,IAAA,IACA,IAAA,CAAA,IAAA,WAAA,OAAA,IAAA,OAKA,SAAA,EAAA,EAAA,GACA,IAAA,EAAA,IAAA,KACA,EAAA,EAAA,QACA,KAAA,IAKA,OADA,EAAA,SAAA,EACA,EAIA,SAAA,EAAA,EAAA,GACA,OAAA,EACA,EAAA,IAAA,EAAA,KACA,IAAA,YAAA,SAAA,EAAA,IAOA,SAAA,EAAA,EAAA,GACA,OAAA,EAAA,IAAA,YAAA,OAAA,GAAA,GAMA,eAAA,EAAA,EAAA,GACA,OAAA,EACA,EAAA,IAAA,EAAA,YACA,YAAA,qBAAA,EAAA,IAAA,UAOA,SAAA,EAAA,EAAA,GACA,IAAA,EAAA,EAAA,OAAA,OAAA,GAAA,GACA,EAAA,EAAA,UAAA,aACA,SAAA,EAAA,EAAA,GACA,OAAA,OAAA,UAAA,eAAA,KAAA,EAAA,GAEA,IAAA,IAAA,KAAA,EAAA,CACA,IAAA,EAAA,EAAA,GAAA,SACA,IAAA,EAAA,EAAA,GACA,EAAA,EAAA,MAAA,KACA,EAAA,EACA,KAAA,EAAA,OAAA,GAAA,CACA,IAAA,EAAA,EAAA,QACA,EAAA,EAAA,KAAA,EAAA,GAAA,IACA,EAAA,EAAA,GAEA,IAAA,EAAA,EAAA,GACA,EAAA,EAAA,QAAA,KACA,GAAA,GAAA,EAAA,CACA,IAAA,EAAA,EAAA,UAAA,EAAA,GACA,EAAA,EAAA,GACA,QAAA,IAAA,IAAA,EAAA,UAAA,CACA,IAAA,EAAA,YAAA,GACA,OAAA,EAAA,KAAA,EAAA,UAAA,YAAA,KAAA,KAEA,EAAA,UAAA,GACA,EAAA,KAAA,SAAA,GACA,OAAA,OAAA,OAAA,EAAA,UAAA,CAAA,CAAA,GAAA,CAAA,MAAA,EAAA,UAAA,MAEA,GAAA,OAAA,oBAAA,GAAA,QAAA,GACA,OAAA,eAAA,EAAA,EAAA,OAAA,yBAAA,EAAA,KAEA,EAAA,GAAA,EAIA,GAFA,EAAA,EAAA,UAAA,EAAA,GACA,EAAA,EAAA,GAAA,UACA,cAAA,KAAA,IACA,IAAA,EAAA,EAAA,EAAA,EAAA,UAAA,IAAA,CACA,IAAA,EAAA,EAAA,EAAA,QAAA,OAAA,SACA,EAAA,EAAA,EAAA,QAAA,OAAA,SACA,OAAA,eAAA,EAAA,EAAA,CACA,IAAA,WAAA,OAAA,EAAA,KAAA,KACA,IAAA,SAAA,GAAA,EAAA,KAAA,GAAA,IACA,YAAA,SAIA,gBAAA,EACA,EAAA,GAAA,EAAA,EAAA,GAEA,OAAA,eAAA,EAAA,EAAA,CACA,MAAA,YAAA,GAEA,OADA,EAAA,EAAA,QACA,EAAA,KAAA,MAAA,UAMA,cAAA,KAAA,GACA,EAAA,EAAA,EAAA,EAAA,UAAA,KACA,OAAA,eAAA,EAAA,EAAA,CACA,IAAA,EAAA,EAAA,QAAA,OAAA,SACA,IAAA,EAAA,EAAA,QAAA,OAAA,SACA,YAAA,IAIA,EAAA,GADA,mBAAA,EACA,EAAA,EAAA,GAEA,EAKA,OAAA,EA/FA,QAAA,YAAA,EAOA,QAAA,kBAAA,EAUA,QAAA,qBAAA,EAiFA,QAAA,SAAA;AbnUA,aAEA,MAAA,EAAA,oBAAA,eACA,EAAA,SAGA,SAAA,EAAA,EAAA,EAAA,GACA,IACA,EAAA,EAAA,IAAA,EACA,EAFA,EAAA,IAAA,GAGA,EAAA,GAEA,KAAA,EADA,MACA,CACA,IAAA,EAAA,EAAA,EAFA,KAEA,GACA,EAAA,GAAA,OAAA,EAAA,MAAA,KAHA,KAIA,EAAA,EAAA,SAAA,EAAA,GAAA,GACA,EAAA,KAAA,OAAA,aAAA,MAAA,OAAA,IACA,GAAA,EAEA,OAAA,EAAA,KAAA,IAAA,OAAA,aAAA,MAAA,OAAA,EAAA,SAAA,EAAA,EAAA,IAIA,SAAA,EAAA,GACA,IAAA,EAAA,GAEA,SAAA,EAAA,EAAA,GACA,IAAA,EAAA,MAAA,gBACA,IAAA,EAAA,EAAA,OACA,OAAA,EAAA,IAAA,YAAA,GAAA,IAAA,YAAA,GAAA,GAIA,IAAA,EAAA,EAAA,IAAA,EAAA,KAAA,GAYA,OAXA,EAAA,MAAA,EAAA,OAAA,SAAA,EAAA,EAAA,EAAA,GACA,IAAA,EAAA,EAAA,QAAA,EAAA,OACA,MAAA,MAAA,UAAA,EAAA,EAAA,GAAA,OAAA,EAAA,EAAA,GAAA,IAAA,EAAA,IAAA,IAEA,EAAA,MAAA,EAAA,OAAA,SAAA,EAAA,GACA,IAAA,EAAA,EAAA,QAAA,EAAA,OACA,QAAA,IAAA,UAAA,EAAA,EAAA,IAAA,EAAA,IAAA,IAAA,MAAA,UAAA,MAAA,KAAA,UAAA,EAAA,EAAA,GAAA,KAAA,QAEA,EAAA,KAAA,EAAA,MAAA,KACA,EAAA,KAAA,EAAA,MAAA,KAEA,EAIA,SAAA,EAAA,EAAA,GACA,IASA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EATA,EAAA,EAAA,QACA,EAAA,EAAA,OACA,EAAA,EAAA,mBACA,EAAA,EAAA,eACA,EAAA,EAAA,eACA,EAAA,EAAA,MACA,EAAA,EAAA,UAAA,aAMA,SAAA,IAEA,IAAA,EAAA,SACA,EAAA,EAAA,OACA,EAAA,IAAA,UAAA,GACA,EAAA,IAAA,WAAA,GACA,EAAA,IAAA,WAAA,GACA,EAAA,IAAA,YAAA,GACA,EAAA,IAAA,WAAA,GACA,EAAA,IAAA,YAAA,GACA,IACA,EAAA,IAAA,cAAA,GACA,EAAA,IAAA,eAAA,IAEA,EAAA,IAAA,aAAA,GACA,EAAA,IAAA,aAAA,IAkHA,OA/GA,IAaA,EAAA,UAVA,SAAA,GACA,IAAA,EAAA,EAAA,OACA,EAAA,EAAA,GAAA,GAAA,IACA,EAAA,EAAA,IAAA,EACA,IACA,EAAA,IAAA,GAAA,EACA,IAAA,IAAA,EAAA,EAAA,EAAA,IAAA,EAAA,EAAA,EAAA,GAAA,EAAA,WAAA,GACA,OAAA,GAWA,EAAA,UALA,SAAA,GAEA,OADA,IACA,EAAA,EAAA,EAAA,IA0CA,EAAA,SA/BA,SAAA,EAAA,EAAA,GACA,IAAA,EAAA,EAAA,YACA,IAAA,UACA,EAAA,EACA,EAAA,WAEA,IAAA,IAAA,EAAA,EAAA,QAEA,IAAA,EAAA,EAAA,kBACA,IAAA,EAAA,MAAA,MAAA,qBACA,IAAA,EAAA,EAAA,EACA,EAAA,EAAA,IACA,EAAA,EAlBA,SAAA,GAEA,OAAA,GAAA,GAAA,KAAA,MAAA,EADA,EACA,GAgBA,CAAA,IAOA,GANA,IACA,EAAA,IAAA,GAAA,EACA,EAAA,EAAA,IAAA,GAAA,EACA,EAAA,EAAA,IAAA,GAAA,EACA,EAAA,IAAA,GAAA,EACA,EAAA,EAAA,IAAA,GAAA,EACA,GAEA,GADA,IAAA,EAAA,EAAA,EAAA,EAAA,GAAA,IAAA,GACA,EAAA,OAAA,IAAA,EAAA,CACA,IAAA,EAAA,EAAA,EAAA,OACA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,SAEA,GACA,EAAA,EAAA,EAAA,EAAA,GAEA,OAAA,GAgBA,EAAA,SAVA,SAAA,EAAA,GACA,IAAA,EAAA,EAAA,kBACA,IAAA,EAAA,MAAA,MAAA,qBACA,IACA,IAAA,EAAA,EAAA,IAAA,GACA,EAAA,EAAA,EAAA,IAAA,GACA,EAAA,EAAA,EAAA,IAAA,GACA,OAAA,IAAA,EAAA,EAAA,EAAA,EAAA,GAAA,EAAA,GAAA,IAaA,EAAA,UAPA,SAAA,GACA,IACA,IAAA,EAAA,EAAA,IAAA,GACA,EAAA,GACA,EAAA,IAiBA,EAAA,YARA,SAAA,GACA,mBAAA,EAAA,WAAA,EAAA,EAAA,UACA,IAAA,EAAA,EAAA,OAGA,OAFA,EAAA,KAAA,GACA,EAAA,IAAA,EAAA,GACA,GAUA,EAAA,YAJA,SAAA,GACA,OAAA,EAAA,EAAA,IAAA,GAAA,IAMA,EAAA,OAAA,EAAA,QAAA,EACA,EAAA,MAAA,EAAA,OAAA,EAGA,EAAA,EAAA,OAAA,iBAAA,EAAA,CACA,GAAA,CAAA,IAAA,WAAA,OAAA,IAAA,IACA,GAAA,CAAA,IAAA,WAAA,OAAA,IAAA,IACA,IAAA,CAAA,IAAA,WAAA,OAAA,IAAA,IACA,IAAA,CAAA,IAAA,WAAA,OAAA,IAAA,IACA,IAAA,CAAA,IAAA,WAAA,OAAA,IAAA,IACA,IAAA,CAAA,IAAA,WAAA,OAAA,IAAA,IACA,IAAA,CAAA,IAAA,WAAA,OAAA,IAAA,IACA,IAAA,CAAA,IAAA,WAAA,OAAA,IAAA,IACA,IAAA,CAAA,IAAA,WAAA,OAAA,IAAA,IACA,IAAA,CAAA,IAAA,WAAA,OAAA,IAAA,OAKA,SAAA,EAAA,EAAA,GACA,IAAA,EAAA,IAAA,KACA,EAAA,EAAA,QACA,KAAA,IAKA,OADA,EAAA,SAAA,EACA,EAIA,SAAA,EAAA,EAAA,GACA,OAAA,EACA,EAAA,IAAA,EAAA,KACA,IAAA,YAAA,SAAA,EAAA,IAOA,SAAA,EAAA,EAAA,GACA,OAAA,EAAA,IAAA,YAAA,OAAA,GAAA,GAMA,eAAA,EAAA,EAAA,GACA,OAAA,EACA,EAAA,IAAA,EAAA,YACA,YAAA,qBAAA,EAAA,IAAA,UAOA,SAAA,EAAA,EAAA,GACA,IAAA,EAAA,EAAA,OAAA,OAAA,GAAA,GACA,EAAA,EAAA,UAAA,aACA,SAAA,EAAA,EAAA,GACA,OAAA,OAAA,UAAA,eAAA,KAAA,EAAA,GAEA,IAAA,IAAA,KAAA,EAAA,CACA,IAAA,EAAA,EAAA,GAAA,SACA,IAAA,EAAA,EAAA,GACA,EAAA,EAAA,MAAA,KACA,EAAA,EACA,KAAA,EAAA,OAAA,GAAA,CACA,IAAA,EAAA,EAAA,QACA,EAAA,EAAA,KAAA,EAAA,GAAA,IACA,EAAA,EAAA,GAEA,IAAA,EAAA,EAAA,GACA,EAAA,EAAA,QAAA,KACA,GAAA,GAAA,EAAA,CACA,IAAA,EAAA,EAAA,UAAA,EAAA,GACA,EAAA,EAAA,GACA,QAAA,IAAA,IAAA,EAAA,UAAA,CACA,IAAA,EAAA,YAAA,GACA,OAAA,EAAA,KAAA,EAAA,UAAA,YAAA,KAAA,KAEA,EAAA,UAAA,GACA,EAAA,KAAA,SAAA,GACA,OAAA,OAAA,OAAA,EAAA,UAAA,CAAA,CAAA,GAAA,CAAA,MAAA,EAAA,UAAA,MAEA,GAAA,OAAA,oBAAA,GAAA,QAAA,GACA,OAAA,eAAA,EAAA,EAAA,OAAA,yBAAA,EAAA,KAEA,EAAA,GAAA,EAIA,GAFA,EAAA,EAAA,UAAA,EAAA,GACA,EAAA,EAAA,GAAA,UACA,cAAA,KAAA,IACA,IAAA,EAAA,EAAA,EAAA,EAAA,UAAA,IAAA,CACA,IAAA,EAAA,EAAA,EAAA,QAAA,OAAA,SACA,EAAA,EAAA,EAAA,QAAA,OAAA,SACA,OAAA,eAAA,EAAA,EAAA,CACA,IAAA,WAAA,OAAA,EAAA,KAAA,KACA,IAAA,SAAA,GAAA,EAAA,KAAA,GAAA,IACA,YAAA,SAIA,gBAAA,EACA,EAAA,GAAA,EAAA,EAAA,GAEA,OAAA,eAAA,EAAA,EAAA,CACA,MAAA,YAAA,GAEA,OADA,EAAA,EAAA,QACA,EAAA,KAAA,MAAA,UAMA,cAAA,KAAA,GACA,EAAA,EAAA,EAAA,EAAA,UAAA,KACA,OAAA,eAAA,EAAA,EAAA,CACA,IAAA,EAAA,EAAA,QAAA,OAAA,SACA,IAAA,EAAA,EAAA,QAAA,OAAA,SACA,YAAA,IAIA,EAAA,GADA,mBAAA,EACA,EAAA,EAAA,GAEA,EAKA,OAAA,EA/FA,QAAA,YAAA,EAOA,QAAA,kBAAA,EAUA,QAAA,qBAAA,EAiFA,QAAA,SAAA;;aChUA,IAAY,yDAAZ,SAAY,GAIV,EAAA,EAAA,OAAA,GAAA,SAIA,EAAA,EAAA,SAAA,GAAA,WAIA,EAAA,EAAA,SAAA,GAAA,WAIA,EAAA,EAAA,UAAA,GAAA,YAhBF,CAAY,EAAA,QAAA,0BAAA,QAAA,wBAAuB;;aCHnC,IAAY,yDAAZ,SAAY,GACV,EAAA,EAAA,QAAA,GAAA,UACA,EAAA,EAAA,QAAA,GAAA,UAFF,CAAY,EAAA,QAAA,WAAA,QAAA,SAAQ;;aCApB,IAAY,yDAAZ,SAAY,GACV,EAAA,EAAA,IAAA,GAAA,MACA,EAAA,EAAA,OAAA,GAAA,SACA,EAAA,EAAA,KAAA,GAAA,OAHF,CAAY,EAAA,QAAA,wBAAA,QAAA,sBAAqB;;aCIjC,IAAY,yDAAZ,SAAY,GAIV,EAAA,EAAA,eAAA,GAAA,cAKA,EAAA,EAAA,aAAA,GAAA,YAIA,EAAA,EAAA,cAAA,GAAA,aAIA,EAAA,EAAA,eAAA,GAAA,cAIA,EAAA,EAAA,oBAAA,GAAA,mBAKA,EAAA,EAAA,kBAAA,GAAA,iBAIA,EAAA,EAAA,mBAAA,GAAA,kBAKA,EAAA,EAAA,oBAAA,GAAA,mBAIA,EAAA,EAAA,QAAA,GAAA,UAIA,EAAA,EAAA,KAAA,GAAA,OAIA,EAAA,EAAA,IAAA,IAAA,MAKA,EAAA,EAAA,SAAA,IAAA,WAKA,EAAA,EAAA,OAAA,IAAA,SAKA,EAAA,EAAA,QAAA,IAAA,UAIA,EAAA,EAAA,OAAA,IAAA,SAIA,EAAA,EAAA,QAAA,IAAA,UAIA,EAAA,EAAA,eAAA,IAAA,cAIA,EAAA,EAAA,cAAA,IAAA,aAIA,EAAA,EAAA,cAAA,IAAA,aAIA,EAAA,EAAA,cAAA,IAAA,aAKA,EAAA,EAAA,WAAA,IAAA,aAIA,EAAA,EAAA,UAAA,IAAA,YAIA,EAAA,EAAA,IAAA,IAAA,MAIA,EAAA,EAAA,WAAA,IAAA,aAIA,EAAA,EAAA,MAAA,IAAA,QAIA,EAAA,EAAA,WAAA,IAAA,aA/GF,CAAY,EAAA,QAAA,gCAAA,QAAA,8BAA6B;;aCAzC,IAAY,yDAAZ,SAAY,GAIV,EAAA,EAAA,IAAA,GAAA,MAIA,EAAA,EAAA,IAAA,GAAA,MAIA,EAAA,EAAA,QAAA,GAAA,UAZF,CAAY,EAAA,QAAA,kBAAA,QAAA,gBAAe;;aCE3B,IAAY,yDAAZ,SAAY,GAIV,EAAA,EAAA,KAAA,GAAA,OAIA,EAAA,EAAA,MAAA,GAAA,QAIA,EAAA,EAAA,OAAA,GAAA,SAIA,EAAA,EAAA,MAAA,GAAA,QAIA,EAAA,EAAA,IAAA,GAAA,MApBF,CAAY,EAAA,QAAA,YAAA,QAAA,UAAS;;aCHrB,IAAY,yDAAZ,SAAY,GAIV,EAAA,EAAA,IAAA,GAAA,MAIA,EAAA,EAAA,QAAA,GAAA,UAIA,EAAA,EAAA,OAAA,GAAA,SAIA,EAAA,EAAA,WAAA,GAAA,aAIA,EAAA,EAAA,YAAA,GAAA,cAIA,EAAA,EAAA,OAAA,GAAA,SAxBF,CAAY,EAAA,QAAA,eAAA,QAAA,aAAY;;aCHxB,IAAY,yDAAZ,SAAY,GACV,EAAA,EAAA,KAAA,GAAA,OACA,EAAA,EAAA,MAAA,GAAA,QACA,EAAA,EAAA,OAAA,GAAA,SAHF,CAAY,EAAA,QAAA,UAAA,QAAA,QAAO;;aCQnB,IAAY,yDAAZ,SAAY,GAMV,EAAA,EAAA,MAAA,GAAA,QAKA,EAAA,EAAA,MAAA,GAAA,QAMA,EAAA,EAAA,MAAA,GAAA,QAjBF,CAAY,EAAA,QAAA,WAAA,QAAA,SAAQ;;k6CCRpB,IAAA,EAAA,QAAA,6BAEA,EAAA,QAAA,qCAEA,EAAA,QAAA,sBACA,EAAA,QAAA,mCACA,EAAA,QAAA,2CACA,EAAA,QAAA,6BACA,EAAA,QAAA,uBACA,EAAA,QAAA,0BACA,EAAA,QAAA,qBACA,EAAA,QAAA,sBAEM,EAAO,CACX,KAAQ,EACR,MAAS,GAGX,EAAA,WAAA,SAAA,IACS,KAAA,QAAe,KACf,KAAA,KAAyC,KACxC,KAAA,IAAc,EAuWxB,OArWS,EAAA,UAAA,kBAAP,SAAyB,EAAa,GAKpC,OAJA,KAAK,QAAU,EACf,KAAK,cACL,KAAK,KAAO,EAAA,kBAAkB,EAAQ,KAAK,SAC3C,KAAK,cACE,KAAK,MAGD,EAAA,UAAA,qBAAb,SAAkC,EAA6B,iGAGjD,OAFZ,KAAK,QAAU,EACf,KAAK,cACL,EAAA,KAAY,CAAA,EAAM,EAAA,qBAAqB,EAAU,KAAK,iBAEtD,OAFA,EAAK,KAAO,EAAA,OACZ,KAAK,cACL,CAAA,EAAO,KAAK,YAGP,EAAA,UAAA,YAAP,SAAmB,EAAa,GAK9B,OAJA,KAAK,QAAU,EACf,KAAK,cACL,KAAK,KAAO,EAAA,YAAY,EAAQ,KAAK,SACrC,KAAK,cACE,KAAK,MAGN,EAAA,UAAA,YAAR,WACE,KAAK,QAAQ,aAAe,CAC1B,aAAc,KAAK,aAAa,KAAK,MACrC,qBAAsB,KAAK,qBAAqB,KAAK,MACrD,cAAe,KAAK,cAAc,KAAK,MACvC,qBAAsB,KAAK,qBAAqB,KAAK,MACrD,sBAAuB,KAAK,sBAAsB,KAAK,MACvD,qBAAsB,KAAK,qBAAqB,KAAK,MACrD,aAAc,KAAK,aAAa,KAAK,MACrC,cAAe,KAAK,cAAc,KAAK,MACvC,gBAAiB,KAAK,gBAAgB,KAAK,MAC3C,UAAW,KAAK,UAAU,KAAK,MAC/B,YAAa,KAAK,YAAY,KAAK,MACnC,OAAQ,KAAK,OAAO,KAAK,QAIrB,EAAA,UAAA,YAAR,WACE,KAAK,KAAM,SAAW,GACtB,KAAK,KAAM,UAAY,GACvB,KAAK,KAAM,OAAS,GACpB,KAAK,KAAM,QAAU,GACrB,KAAK,KAAM,SAAW,GACtB,KAAK,KAAM,WAAa,KAAK,WAAW,KAAK,OAGvC,EAAA,UAAA,WAAR,SAAmB,EAAc,GAI/B,OAHA,KAAK,IAAM,EACX,KAAK,KAAM,SAAS,KAAK,IAAM,EAC/B,KAAK,KAAM,cAAc,KAAK,KAAM,UAAU,GAAO,KAAK,IACnD,KAAK,IAGN,EAAA,UAAA,qBAAR,SAA6B,EAAe,EAAY,EAAY,EAAY,GAE9E,GADA,KAAK,IAAM,GACN,KAAK,KAAM,SAAS,GAAQ,MAAM,IAAI,MAAM,uBAAyB,GAE1E,OADA,KAAK,KAAM,UAAU,KAAK,IAAM,KAAK,KAAM,SAAS,GAAO,qBAAqB,EAAI,EAAI,EAAI,GACrF,KAAK,IAGN,EAAA,UAAA,qBAAR,SAA6B,EAAe,EAAY,EAAY,EAAY,EAAY,EAAY,GAEtG,GADA,KAAK,IAAM,GACN,KAAK,KAAM,SAAS,GAAQ,MAAM,IAAI,MAAM,uBAAyB,GAE1E,OADA,KAAK,KAAM,UAAU,KAAK,IAAM,KAAK,KAAM,SAAS,GAAO,qBAAqB,EAAI,EAAI,EAAI,EAAI,EAAI,GAC7F,KAAK,IAGN,EAAA,UAAA,aAAR,SAAqB,EAAe,EAAgB,GAClD,IAAK,KAAK,KAAM,UAAU,GAAQ,MAAM,IAAI,MAAM,yBAA2B,GAC7E,KAAK,KAAM,UAAU,GAAO,aAAa,EAAQ,KAAK,KAAM,UAAU,KAGhE,EAAA,UAAA,UAAR,SAAkB,EAAoB,GAAtC,IAAA,EAAA,KACM,EAAc,KAAK,KAAM,UAAU,GACvC,KAAK,IAAM,EACX,IAAI,EAAiB,KAAK,GAS1B,OARA,KAAK,KAAM,QAAQ,GAAU,MAAM,GAChC,KAAK,SAAA,GAAK,OAAA,EAAE,SACZ,KAAK,mBACL,KAAK,SAAA,GAGJ,OAFA,EAAK,KAAM,eAAe,EAAY,EAAE,MAAO,EAAE,QACjD,EAAK,KAAM,OAAO,GAAU,EACrB,IAEJ,KAAK,IAGN,EAAA,UAAA,cAAR,SAAsB,EAAkB,EAAe,GAErD,GADA,KAAK,IAAM,GACN,KAAK,KAAM,SAAS,GAAW,MAAM,IAAI,MAAM,uBAAyB,GAC7E,IAAK,KAAK,KAAM,OAAO,GAAQ,MAAM,IAAI,MAAM,sBAAwB,GAKvE,OAJA,KAAK,KAAM,SAAS,KAAK,IAAM,KAAK,KAAM,SAAS,GAAU,cAC3D,KAAK,KAAM,OAAO,GAClB,EAAA,wBAAwB,GAAY,QAAQ,IAAK,MAE5C,KAAK,IAGP,EAAA,UAAA,YAAP,SAAmB,EAAkB,GAInC,OADoC,KAAK,KAAM,SAAS,GAC7C,YAAY,KAAK,KAAM,UAAU,IAAO,OAG7C,EAAA,UAAA,OAAR,SAAe,EAAkB,GAC/B,IAAK,KAAK,KAAM,SAAS,GAAW,MAAM,IAAI,MAAM,uBAAyB,GAM7E,IALA,IAAI,EAAgC,KAAK,KACrC,EAAgC,EAAK,SAAS,GAC9C,EAAO,IAAI,aAAa,EAAK,OAAO,OAAQ,EAAS,OACrD,EAAI,EACJ,EAA0C,GACvC,EAAI,OAAkB,IAAP,EAAK,IAAiC,CAC1D,OAAQ,EAAK,IACX,KAAA,EACE,EAAI,IAAI,EAAK,EAAI,GAAI,EAAK,EAAI,GAAI,EAAK,EAAI,GAAI,EAAK,EAAI,GAAI,EAAK,EAAI,GAAoB,IAAhB,EAAK,EAAI,IAClF,MAEF,KAAA,EACE,EAAI,MAAM,EAAK,EAAI,GAAI,EAAK,EAAI,GAAI,EAAK,EAAI,GAAI,EAAK,EAAI,GAAI,EAAK,EAAI,IACvE,MAEF,KAAA,EACE,EAAI,YACJ,MAEF,KAAA,EACE,EAAI,cAAc,EAAK,EAAI,GAAI,EAAK,EAAI,GAAI,EAAK,EAAI,GAAI,EAAK,EAAI,GAAI,EAAK,EAAI,GAAI,EAAK,EAAI,IAC5F,MAEF,KAAA,EACE,EAAI,OACJ,MAEF,KAAA,EACE,EAAI,YACJ,MAEF,KAAA,EACE,EAAI,UAAU,EAAK,EAAI,GAAI,EAAK,EAAI,GAAI,EAAK,EAAI,GAAI,EAAK,EAAI,IAC9D,MAEF,KAAA,EACE,EAAI,UAAY,EAAA,gBAAgB,EAAK,EAAI,IACzC,MAEF,KAAA,GACE,EAAI,UAAU,EAAK,OAAO,EAAK,EAAI,IAAK,EAAK,EAAI,GAAI,EAAK,EAAI,GAAI,EAAK,EAAI,GAAI,EAAK,EAAI,GAAI,EAAK,EAAI,GAAI,EAAK,EAAI,GAAI,EAAK,EAAI,GAAI,EAAK,EAAI,KAC5I,MAEF,KAAA,GACE,EAAI,QAAQ,EAAK,EAAI,GAAI,EAAK,EAAI,GAAI,EAAK,EAAI,GAAI,EAAK,EAAI,GAAI,EAAK,EAAI,GAAI,EAAK,EAAI,GAAI,EAAK,EAAI,GAAoB,IAAhB,EAAK,EAAI,IAChH,MAEF,KAAA,GACE,EAAI,KAAK,EAAA,SAAS,EAAK,EAAI,KAC3B,MAEF,KAAA,GACE,EAAI,UAAY,EAAK,UAAU,EAAK,EAAI,IACxC,MAEF,KAAA,GACE,EAAI,UAAY,EAAK,SAAS,EAAK,EAAI,IACvC,MAEF,KAAA,GACE,EAAI,SAAS,EAAK,EAAI,GAAI,EAAK,EAAI,GAAI,EAAK,EAAI,GAAI,EAAK,EAAI,IAC7D,MAEF,KAAA,GACE,EAAI,UAAY,EAAQ,EAAK,EAAI,MAAQ,EAAQ,EAAK,EAAI,IAAM,EAAK,UAAU,EAAK,EAAI,KACxF,MAEF,KAAA,GACE,EAAI,SACF,EAAQ,EAAK,EAAI,MAAQ,EAAQ,EAAK,EAAI,IAAM,EAAK,UAAU,EAAK,EAAI,KACxE,EAAK,EAAI,GACT,EAAK,EAAI,IAEX,MAEF,KAAA,GACE,EAAI,SACF,EAAQ,EAAK,EAAI,MAAQ,EAAQ,EAAK,EAAI,IAAM,EAAK,UAAU,EAAK,EAAI,KACxE,EAAK,EAAI,GACT,EAAK,EAAI,GACT,EAAK,EAAI,IAEX,MAEF,KAAA,GACE,EAAI,OAAS,EAAQ,EAAK,EAAI,MAAQ,EAAQ,EAAK,EAAI,IAAM,EAAK,UAAU,EAAK,EAAI,KACrF,MAEF,KAAA,GACE,EAAI,KAAO,EAAQ,EAAK,EAAI,MAAQ,EAAQ,EAAK,EAAI,IAAM,EAAK,UAAU,EAAK,EAAI,KACnF,MAEF,KAAA,GACE,EAAI,YAAc,EAAK,EAAI,GAC3B,MAEF,KAAA,GACE,EAAI,yBAA2B,EAAA,8BAA8B,EAAK,EAAI,IACtE,MAEF,KAAA,GACE,EAAI,sBAAwC,IAAhB,EAAK,EAAI,GACrC,MAEF,KAAA,GACE,EAAI,sBAAwB,EAAA,sBAAsB,EAAK,EAAI,IAC3D,MAEF,KAAA,GACE,EAAI,QAAU,EAAA,QAAQ,EAAK,EAAI,IAC/B,MAEF,KAAA,GAEE,EAAI,YAAY,EAAK,SAAS,aAAc,EAAK,EAAI,KACrD,MAEF,KAAA,GACE,EAAI,eAAiB,EAAK,EAAI,GAC9B,MAEF,KAAA,GACE,EAAI,SAAW,EAAA,SAAS,EAAK,EAAI,IACjC,MAEF,KAAA,GACE,EAAI,OAAO,EAAK,EAAI,GAAI,EAAK,EAAI,IACjC,MAEF,KAAA,GACE,EAAI,UAAY,EAAK,EAAI,GACzB,MAEF,KAAA,GACE,EAAI,WAAa,EAAK,EAAI,GAC1B,MAEF,KAAA,GACE,EAAI,OAAO,EAAK,EAAI,GAAI,EAAK,EAAI,IACjC,MAEF,KAAA,GACE,EAAI,iBAAiB,EAAK,EAAI,GAAI,EAAK,EAAI,GAAI,EAAK,EAAI,GAAI,EAAK,EAAI,IACrE,MAEF,KAAA,GACE,EAAI,KAAK,EAAK,EAAI,GAAI,EAAK,EAAI,GAAI,EAAK,EAAI,GAAI,EAAK,EAAI,IACzD,MAEF,KAAA,GACE,EAAI,UACJ,MAEF,KAAA,GACE,EAAI,OACJ,MAEF,KAAA,GACE,EAAI,aAAa,EAAK,EAAI,GAAI,EAAK,EAAI,GAAI,EAAK,EAAI,GAAI,EAAK,EAAI,GAAI,EAAK,EAAI,GAAI,EAAK,EAAI,IAC3F,MAEF,KAAA,GACE,EAAI,WAAa,EAAK,EAAI,GAC1B,MAEF,KAAA,GACE,EAAI,YAAc,EAAQ,EAAK,EAAI,MAAQ,EAAQ,EAAK,EAAI,IAAM,EAAK,UAAU,EAAK,EAAI,KAC1F,MAEF,KAAA,GACE,EAAI,cAAgB,EAAK,EAAI,GAC7B,MAEF,KAAA,GACE,EAAI,cAAgB,EAAK,EAAI,GAC7B,MAEF,KAAA,GACE,EAAI,SACJ,MAEF,KAAA,GACE,EAAI,YAAc,EAAK,UAAU,EAAK,EAAI,IAC1C,MAEF,KAAA,GACE,EAAI,YAAc,EAAK,SAAS,EAAK,EAAI,IACzC,MAEF,KAAA,GACE,EAAI,WAAW,EAAK,EAAI,GAAI,EAAK,EAAI,GAAI,EAAK,EAAI,GAAI,EAAK,EAAI,IAC/D,MAEF,KAAA,GACE,EAAI,YAAc,EAAQ,EAAK,EAAI,MAAQ,EAAQ,EAAK,EAAI,IAAM,EAAK,UAAU,EAAK,EAAI,KAC1F,MAEF,KAAA,GACE,EAAI,WACF,EAAQ,EAAK,EAAI,MAAQ,EAAQ,EAAK,EAAI,IAAM,EAAK,UAAU,EAAK,EAAI,KACxE,EAAK,EAAI,GACT,EAAK,EAAI,IAEX,MAEF,KAAA,GACE,EAAI,WACF,EAAQ,EAAK,EAAI,MAAQ,EAAQ,EAAK,EAAI,IAAM,EAAK,UAAU,EAAK,EAAI,KACxE,EAAK,EAAI,GACT,EAAK,EAAI,GACT,EAAK,EAAI,IAEX,MAEF,KAAA,GACE,EAAI,UAAY,EAAA,UAAU,EAAK,EAAI,IACnC,MAEF,KAAA,GACE,EAAI,aAAe,EAAA,aAAa,EAAK,EAAI,IAI7C,EAAI,EAAK,EAAI,KAIjB,EAAA,UAAA,qBAAA,SAAqB,UACZ,KAAK,KAAM,SAAS,IAG7B,EAAA,UAAA,aAAA,SAAa,UACJ,KAAK,KAAM,OAAO,IAG3B,EAAA,UAAA,sBAAA,SAAsB,UACb,KAAK,KAAM,UAAU,IAG9B,EAAA,UAAA,cAAA,SAAc,EAAY,EAAW,EAAW,GAC9C,OAAO,EAAW,KAAK,KAAM,SAAS,GAAK,cAAc,EAAG,EAAG,EAAA,SAAS,IAAW,aAGrF,EAAA,UAAA,gBAAA,SAAgB,EAAY,EAAW,GACrC,OAAO,EAAW,KAAK,KAAM,SAAS,GAAK,gBAAgB,EAAG,GAAG,aAErE,EA1WA,GAAa,QAAA,SAAA;;;;aCdb,IAAY,yDAAZ,SAAY,GAIV,EAAA,EAAA,YAAA,GAAA,cAKA,EAAA,EAAA,UAAA,GAAA,YAIA,EAAA,EAAA,WAAA,GAAA,aAIA,EAAA,EAAA,YAAA,GAAA,cAIA,EAAA,EAAA,iBAAA,GAAA,mBAKA,EAAA,EAAA,eAAA,GAAA,iBAIA,EAAA,EAAA,gBAAA,GAAA,kBAKA,EAAA,EAAA,iBAAA,GAAA,mBAIA,EAAA,EAAA,QAAA,GAAA,UAIA,EAAA,EAAA,KAAA,GAAA,OAIA,EAAA,EAAA,IAAA,IAAA,MAKA,EAAA,EAAA,SAAA,IAAA,WAKA,EAAA,EAAA,OAAA,IAAA,SAKA,EAAA,EAAA,QAAA,IAAA,UAIA,EAAA,EAAA,OAAA,IAAA,SAIA,EAAA,EAAA,QAAA,IAAA,UAIA,EAAA,EAAA,YAAA,IAAA,cAIA,EAAA,EAAA,WAAA,IAAA,aAIA,EAAA,EAAA,WAAA,IAAA,aAIA,EAAA,EAAA,WAAA,IAAA,aAKA,EAAA,EAAA,WAAA,IAAA,aAIA,EAAA,EAAA,UAAA,IAAA,YAIA,EAAA,EAAA,IAAA,IAAA,MAIA,EAAA,EAAA,WAAA,IAAA,aAIA,EAAA,EAAA,MAAA,IAAA,QAIA,EAAA,EAAA,WAAA,IAAA,aA/GF,CAAY,EAAA,QAAA,2BAAA,QAAA,yBAAwB;;8ICFpC,IAAA,EAAA,QAAA,mBAEA,SAAgB,EAAqB,EAAgB,GAEnD,YAFmD,IAAA,IAAA,EAAA,KAC3B,IAAI,EAAA,UAChB,kBAAkB,EAAQ,GAGxC,SAAgB,EAAe,EAAU,GAEvC,YAFuC,IAAA,IAAA,EAAA,KACf,IAAI,EAAA,UAChB,YAAY,EAAK,GAG/B,SAAgB,EAAwB,EAA6B,GAEnE,YAFmE,IAAA,IAAA,EAAA,KAC3C,IAAI,EAAA,UAChB,qBAAqB,EAAU,GAZ7C,QAAA,kBAAA,EAKA,QAAA,YAAA,EAKA,QAAA,qBAAA,EAKA,EAAA,QAAA,oBAEA,EAAA,QAAA,6BACA,EAAA,QAAA,+BACA,EAAA,QAAA,qCACA,EAAA,QAAA,sBACA,EAAA,QAAA,sCACA,EAAA,QAAA,2CACA,EAAA,QAAA,mCACA,EAAA,QAAA,qBACA,EAAA,QAAA,sBACA,EAAA,QAAA,uBACA,EAAA,QAAA;;AEkHA,aAAA,IAAA,EAAA,MAAA,KAAA,WAAA,WAAA,IAAA,EAAA,SAAA,EAAA,GAAA,OAAA,EAAA,OAAA,gBAAA,CAAA,UAAA,cAAA,OAAA,SAAA,EAAA,GAAA,EAAA,UAAA,IAAA,SAAA,EAAA,GAAA,IAAA,IAAA,KAAA,EAAA,EAAA,eAAA,KAAA,EAAA,GAAA,EAAA,MAAA,EAAA,IAAA,OAAA,SAAA,EAAA,GAAA,SAAA,IAAA,KAAA,YAAA,EAAA,EAAA,EAAA,GAAA,EAAA,UAAA,OAAA,EAAA,OAAA,OAAA,IAAA,EAAA,UAAA,EAAA,UAAA,IAAA,IAAA,GAAA,EAAA,MAAA,KAAA,WAAA,SAAA,EAAA,EAAA,EAAA,GAAA,OAAA,IAAA,IAAA,EAAA,UAAA,SAAA,EAAA,GAAA,SAAA,EAAA,GAAA,IAAA,EAAA,EAAA,KAAA,IAAA,MAAA,GAAA,EAAA,IAAA,SAAA,EAAA,GAAA,IAAA,EAAA,EAAA,MAAA,IAAA,MAAA,GAAA,EAAA,IAAA,SAAA,EAAA,GAAA,EAAA,KAAA,EAAA,EAAA,OAAA,IAAA,EAAA,SAAA,GAAA,EAAA,EAAA,SAAA,KAAA,EAAA,GAAA,GAAA,EAAA,EAAA,MAAA,EAAA,GAAA,KAAA,WAAA,EAAA,MAAA,KAAA,aAAA,SAAA,EAAA,GAAA,IAAA,EAAA,EAAA,EAAA,EAAA,EAAA,CAAA,MAAA,EAAA,KAAA,WAAA,GAAA,EAAA,EAAA,GAAA,MAAA,EAAA,GAAA,OAAA,EAAA,IAAA,KAAA,GAAA,IAAA,IAAA,OAAA,EAAA,CAAA,KAAA,EAAA,GAAA,MAAA,EAAA,GAAA,OAAA,EAAA,IAAA,mBAAA,SAAA,EAAA,OAAA,UAAA,WAAA,OAAA,OAAA,EAAA,SAAA,EAAA,GAAA,OAAA,SAAA,GAAA,OAAA,SAAA,GAAA,GAAA,EAAA,MAAA,IAAA,UAAA,mCAAA,KAAA,GAAA,IAAA,GAAA,EAAA,EAAA,IAAA,EAAA,EAAA,EAAA,GAAA,EAAA,OAAA,EAAA,GAAA,EAAA,SAAA,EAAA,EAAA,SAAA,EAAA,KAAA,GAAA,GAAA,EAAA,SAAA,EAAA,EAAA,KAAA,EAAA,EAAA,KAAA,KAAA,OAAA,EAAA,OAAA,EAAA,EAAA,IAAA,EAAA,CAAA,EAAA,EAAA,GAAA,EAAA,QAAA,EAAA,IAAA,KAAA,EAAA,KAAA,EAAA,EAAA,EAAA,MAAA,KAAA,EAAA,OAAA,EAAA,QAAA,CAAA,MAAA,EAAA,GAAA,MAAA,GAAA,KAAA,EAAA,EAAA,QAAA,EAAA,EAAA,GAAA,EAAA,CAAA,GAAA,SAAA,KAAA,EAAA,EAAA,EAAA,IAAA,MAAA,EAAA,KAAA,MAAA,SAAA,QAAA,KAAA,GAAA,EAAA,EAAA,MAAA,OAAA,GAAA,EAAA,EAAA,OAAA,MAAA,IAAA,EAAA,IAAA,IAAA,EAAA,IAAA,CAAA,EAAA,EAAA,SAAA,GAAA,IAAA,EAAA,MAAA,GAAA,EAAA,GAAA,EAAA,IAAA,EAAA,GAAA,EAAA,IAAA,CAAA,EAAA,MAAA,EAAA,GAAA,MAAA,GAAA,IAAA,EAAA,IAAA,EAAA,MAAA,EAAA,GAAA,CAAA,EAAA,MAAA,EAAA,GAAA,EAAA,EAAA,MAAA,GAAA,GAAA,EAAA,MAAA,EAAA,GAAA,CAAA,EAAA,MAAA,EAAA,GAAA,EAAA,IAAA,KAAA,GAAA,MAAA,EAAA,IAAA,EAAA,IAAA,MAAA,EAAA,KAAA,MAAA,SAAA,EAAA,EAAA,KAAA,EAAA,GAAA,MAAA,GAAA,EAAA,CAAA,EAAA,GAAA,EAAA,EAAA,QAAA,EAAA,EAAA,EAAA,GAAA,EAAA,EAAA,GAAA,MAAA,EAAA,GAAA,MAAA,CAAA,MAAA,EAAA,GAAA,EAAA,QAAA,EAAA,MAAA,GAAA,CAAA,CAAA,EAAA,OAAA,EAAA,MAAA,KAAA,cAAA,SAAA,GAAA,GAAA,GAAA,EAAA,WAAA,OAAA,EAAA,IAAA,EAAA,GAAA,GAAA,MAAA,EAAA,IAAA,IAAA,KAAA,EAAA,OAAA,eAAA,KAAA,EAAA,KAAA,EAAA,GAAA,EAAA,IAAA,OAAA,EAAA,QAAA,EAAA,GAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAhJA,IA0EI,EACA,EA3EJ,EAAA,QAAA,QACA,EAAA,EAAA,QAAA,8BAMM,EAAM,CACR,WAAY,EACZ,UAAW,EACX,OAAQ,IAAI,YAAY,OAAO,CAC3B,QAAS,IAEb,MAAA,SAAM,EAAa,EAAc,EAAc,GAC3C,QAAQ,MAAM,mBAAqB,EAAO,IAAM,EAAO,IAAM,EAAS,SAAW,KAIzF,EAAA,WAAA,SAAA,IAAA,IAAA,EAAA,KACI,KAAA,OAAwB,KAMd,KAAA,UAAY,SAAC,GACf,OAAe,MAAf,EAAK,OACE,EAEA,EAAK,OAAO,UAAU,IAI3B,KAAA,SAAW,SAAC,EAA6B,GAC3C,OAAe,MAAf,EAAK,OACE,EAEA,EAAK,OAAO,SAAS,EAAM,IAG9C,OAnBI,EAAA,UAAA,KAAA,SAAK,GACI,KAAA,OAAS,GAkBtB,EAtBA,GA0BA,EAAA,SAAA,GAAA,SAAA,IAAA,IAAA,EAAA,OAAA,GAAA,EAAA,MAAA,KAAA,YAAA,KAoGA,OAlGW,EAAA,IAAM,SAAC,GACV,QAAQ,IAAI,EAAK,UAAU,KAExB,EAAA,KAAO,SAAC,EAAa,GACxB,QAAQ,IAAI,EAAK,UAAU,GAAM,IAE9B,EAAA,KAAO,SAAC,EAAa,GACxB,QAAQ,IAAI,EAAK,UAAU,GAAM,IAE9B,EAAA,UAAY,SAAC,EAAa,EAAgB,GAC7C,QAAQ,IAAI,EAAK,UAAU,GAAO,WAAY,EAAQ,EAAK,SAAS,UAAW,KAE5E,EAAA,MAAQ,SAAC,GACZ,MAAM,EAAK,UAAU,KAqF7B,EAnFA,OAjBsB,EAAA,EAAA,GAiBtB,EAjBA,CAAsB,GAmBtB,EAAA,SAAA,GAAA,SAAA,IAAA,IAAA,EAAA,OAAA,GAAA,EAAA,MAAA,KAAA,YAAA,KAiFA,OA/EW,EAAA,SAAW,SAAC,EAAgB,GAC/B,QAAQ,IAAI,oBAAqB,EAAQ,EAAK,SAAS,UAAW,KA8E1E,EA5EA,OALuB,EAAA,EAAA,GAKvB,EALA,CAAuB,GAQjB,EAAgB,IAAI,EACpB,EAAa,IAAI,EACjB,EAAW,IAAI,EAIrB,SAAgB,EAAK,EAAoB,EAAkF,EAAsC,EAA6B,EAAuC,GAgE1N,YAhEsJ,IAAA,IAAA,GAAA,QAA6B,IAAA,IAAA,EAAA,gCAAuC,IAAA,IAAA,EAAA,wBACjO,EAAU,EAAO,qBAAiC,MAAM,GAAY,CAChE,IAAK,EACL,QAAS,EACT,SAAU,CACN,SAAA,SAAS,EAAgB,GACrB,EAAS,SAAS,EAAQ,IAE9B,WAAA,SAAW,GACP,WAAW,WACP,EAAW,IACZ,SAGZ,KAAK,SAAA,GAIG,OAHP,EAAc,KAAK,GACnB,EAAS,KAAK,GACd,EAAO,OACA,IACR,KAAK,SAAA,GACG,OAAA,EAAA,qBAA8B,MAAM,GAAS,CAC5C,IAAK,EAAK,QAAS,EAAY,OAAQ,CAEvC,OAAA,SAAO,EAAgB,GACX,IAAA,EAAU,EAAO,SAAS,EAAO,SAAS,UAAW,IAClD,OAAA,EAAO,OAAO,EAAQ,IAErC,UAAA,SAAU,GACF,IAAA,EAAa,EAAO,SAAS,UAAW,GAC5C,QAAQ,IAAI,2BAA4B,GACpC,IAAA,EAAU,EAAO,SAAS,GAC1B,EAAO,UAAU,IAErB,SAAQ,WAEG,OADO,EAAO,SAAS,EAAO,SAAS,UAAW,EAAO,cAGpE,WAAU,WACC,OAAA,EAAO,iBAGvB,KAAK,SAAA,GACJ,EAAS,EACT,EAAW,KAAK,GACd,IACA,EAD4B,SAAS,cAAc,SACrC,WAAW,MAcxB,OAZH,EAAI,OAAO,iBAAiB,QAAS,SAAC,GAC9B,IAAA,EAAoB,EAAE,OAA6B,wBACnD,EAAe,EAAI,QAAQ,EAAE,QAAU,EAAK,KAAM,EAAE,QAAU,EAAK,KACnE,EAAmB,EAAI,SAAS,UAAW,GAC3C,EAAM,OAAS,GACf,EAAc,EAAO,KAI7B,EAAI,WAAW,OAAQ,GACvB,EAAI,KAAK,EAAY,GACrB,EAAI,OACD,MAQnB,SAAsB,EAAY,GAAlC,OAAA,EAAA,UAAA,OAAA,EAAA,WAAA,IAAA,EAAA,EAAA,OAAA,EAAA,KAAA,SAAA,GAAA,OAAA,EAAA,OAAA,KAAA,EACiB,MAAA,CAAA,EAAM,GADvB,KAAA,EAAA,OACQ,EAAS,EAAA,OACT,EAAU,EAAO,SAAS,GAC9B,EAAO,YAAY,GAHvB,CAAA,QAnEA,QAAA,KAAA,EAmEA,QAAA,YAAA;;AC3IA,aAAA,IAAA,EAAA,MAAA,KAAA,cAAA,SAAA,GAAA,GAAA,GAAA,EAAA,WAAA,OAAA,EAAA,IAAA,EAAA,GAAA,GAAA,MAAA,EAAA,IAAA,IAAA,KAAA,EAAA,OAAA,eAAA,KAAA,EAAA,KAAA,EAAA,GAAA,EAAA,IAAA,OAAA,EAAA,QAAA,EAAA,GAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IANA,IAAA,EAAA,EAAA,QAAA,SAEM,EAAa,SAEf,EAAgB,GAEpB,EAAG,KAAK,EAAG,SAAU,EAAO,GACxB,QAAQ,IAAI,eAAgB,GACxB,IAAA,EAAe,EAAO,WACtB,EAAY,EAAO,SAAS,UAAW,GAC3C,EAAgB,CAAC,MAAO,MAAM,KAAK,IAC/B,IAAA,EAAc,KAAK,UAAU,GACjC,aAAa,QAAQ,EAAY,GACjC,QAAQ,IAAI,uBAAwB,IACrC,SAAU,GACL,QAAQ,wBAA0B,EAAS,sBAC3C,QAAQ,IAAI,mBACZ,aAAa,WAAW,GACxB,SAAS,YAId,GAAM,KAAK,SAAA,GACN,IACI,IAAA,EAAW,aAAa,QAAQ,GAChC,GAAY,MAAZ,EAAkB,CAClB,QAAQ,IAAI,gBAAiB,GACzB,IAAA,EAAc,KAAK,MAAM,GAC7B,QAAQ,IAAI,cAAe,GACvB,IAAA,EAAa,UAAU,KAAK,EAAY,OAC5C,QAAQ,IAAI,oBAAqB,EAAW,QACxC,IAAA,EAAU,EAAQ,SAAS,GAC/B,EAAQ,UAAU,IAExB,MAAO,GACL,QAAQ,MAAM,GACd,aAAa,WAAW,GAE5B,EAAQ","file":"src.99201e6f.js","sourceRoot":"..","sourcesContent":["\"use strict\";\n\nconst hasBigInt64 = typeof BigUint64Array !== \"undefined\";\nconst thisPtr = Symbol();\n\n/** Gets a string from an U32 and an U16 view on a memory. */\nfunction getStringImpl(U32, U16, ptr) {\n  var dataLength = U32[ptr >>> 2];\n  var dataOffset = (ptr + 4) >>> 1;\n  var dataRemain = dataLength;\n  var parts = [];\n  const chunkSize = 1024;\n  while (dataRemain > chunkSize) {\n    let last = U16[dataOffset + chunkSize - 1];\n    let size = last >= 0xD800 && last < 0xDC00 ? chunkSize - 1 : chunkSize;\n    let part = U16.subarray(dataOffset, dataOffset += size);\n    parts.push(String.fromCharCode.apply(String, part));\n    dataRemain -= size;\n  }\n  return parts.join(\"\") + String.fromCharCode.apply(String, U16.subarray(dataOffset, dataOffset + dataRemain));\n}\n\n/** Prepares the base module prior to instantiation. */\nfunction preInstantiate(imports) {\n  var baseModule = {};\n\n  function getString(memory, ptr) {\n    if (!memory) return \"<yet unknown>\";\n    var buffer = memory.buffer;\n    return getStringImpl(new Uint32Array(buffer), new Uint16Array(buffer), ptr);\n  }\n\n  // add common imports used by stdlib for convenience\n  var env = (imports.env = imports.env || {});\n  env.abort = env.abort || function abort(mesg, file, line, colm) {\n    var memory = baseModule.memory || env.memory; // prefer exported, otherwise try imported\n    throw Error(\"abort: \" + getString(memory, mesg) + \" at \" + getString(memory, file) + \":\" + line + \":\" + colm);\n  }\n  env.trace = env.trace || function trace(mesg, n) {\n    var memory = baseModule.memory || env.memory;\n    console.log(\"trace: \" + getString(memory, mesg) + (n ? \" \" : \"\") + Array.prototype.slice.call(arguments, 2, 2 + n).join(\", \"));\n  }\n  imports.Math = imports.Math || Math;\n  imports.Date = imports.Date || Date;\n\n  return baseModule;\n}\n\n/** Prepares the final module once instantiation is complete. */\nfunction postInstantiate(baseModule, instance) {\n  var rawExports = instance.exports;\n  var memory = rawExports.memory;\n  var memory_allocate = rawExports[\"memory.allocate\"];\n  var memory_fill = rawExports[\"memory.fill\"];\n  var memory_free = rawExports[\"memory.free\"];\n  var table = rawExports.table;\n  var setargc = rawExports._setargc || function() {};\n\n  // Provide views for all sorts of basic values\n  var buffer, I8, U8, I16, U16, I32, U32, F32, F64, I64, U64;\n\n  /** Updates memory views if memory has grown meanwhile. */\n  function checkMem() {\n    // see: https://github.com/WebAssembly/design/issues/1210\n    if (buffer !== memory.buffer) {\n      buffer = memory.buffer;\n      I8  = new Int8Array(buffer);\n      U8  = new Uint8Array(buffer);\n      I16 = new Int16Array(buffer);\n      U16 = new Uint16Array(buffer);\n      I32 = new Int32Array(buffer);\n      U32 = new Uint32Array(buffer);\n      if (hasBigInt64) {\n        I64 = new BigInt64Array(buffer);\n        U64 = new BigUint64Array(buffer);\n      }\n      F32 = new Float32Array(buffer);\n      F64 = new Float64Array(buffer);\n    }\n  }\n  checkMem();\n\n  /** Allocates a new string in the module's memory and returns its pointer. */\n  function newString(str) {\n    var dataLength = str.length;\n    var ptr = memory_allocate(4 + (dataLength << 1));\n    var dataOffset = (4 + ptr) >>> 1;\n    checkMem();\n    U32[ptr >>> 2] = dataLength;\n    for (let i = 0; i < dataLength; ++i) U16[dataOffset + i] = str.charCodeAt(i);\n    return ptr;\n  }\n\n  baseModule.newString = newString;\n\n  /** Gets a string from the module's memory by its pointer. */\n  function getString(ptr) {\n    checkMem();\n    return getStringImpl(U32, U16, ptr);\n  }\n\n  baseModule.getString = getString;\n\n  function computeBufferSize(byteLength) {\n    const HEADER_SIZE = 8;\n    return 1 << (32 - Math.clz32(byteLength + HEADER_SIZE - 1));\n  }\n\n  /** Creates a new typed array in the module's memory and returns its pointer. */\n  function newArray(view, length, unsafe) {\n    var ctor = view.constructor;\n    if (ctor === Function) { // TypedArray constructor created in memory\n      ctor = view;\n      view = null;\n    } else { // TypedArray instance copied into memory\n      if (length === undefined) length = view.length;\n    }\n    var elementSize = ctor.BYTES_PER_ELEMENT;\n    if (!elementSize) throw Error(\"not a typed array\");\n    var byteLength = elementSize * length;\n    var ptr = memory_allocate(12); // TypedArray header\n    var buf = memory_allocate(computeBufferSize(byteLength)); // ArrayBuffer\n    checkMem();\n    U32[ ptr      >>> 2] = buf;        // .buffer\n    U32[(ptr + 4) >>> 2] = 0;          // .byteOffset\n    U32[(ptr + 8) >>> 2] = byteLength; // .byteLength\n    U32[ buf      >>> 2] = byteLength; // .byteLength\n    U32[(buf + 4) >>> 2] = 0;          // 0\n    if (view) {\n      new ctor(buffer, buf + 8, length).set(view);\n      if (view.length < length && !unsafe) {\n        let setLength = elementSize * view.length;\n        memory_fill(buf + 8 + setLength, 0, byteLength - setLength);\n      }\n    } else if (!unsafe) {\n      memory_fill(buf + 8, 0, byteLength);\n    }\n    return ptr;\n  }\n\n  baseModule.newArray = newArray;\n\n  /** Gets a view on a typed array in the module's memory by its pointer. */\n  function getArray(ctor, ptr) {\n    var elementSize = ctor.BYTES_PER_ELEMENT;\n    if (!elementSize) throw Error(\"not a typed array\");\n    checkMem();\n    var buf        = U32[ ptr      >>> 2];\n    var byteOffset = U32[(ptr + 4) >>> 2];\n    var byteLength = U32[(ptr + 8) >>> 2];\n    return new ctor(buffer, buf + 8 + byteOffset, (byteLength - byteOffset) / elementSize);\n  }\n\n  baseModule.getArray = getArray;\n\n  /** Frees a typed array in the module's memory. Must not be accessed anymore afterwards. */\n  function freeArray(ptr) {\n    checkMem();\n    var buf = U32[ptr >>> 2];\n    memory_free(buf);\n    memory_free(ptr);\n  }\n\n  baseModule.freeArray = freeArray;\n\n  /**\n   * Creates a new function in the module's table and returns its pointer. Note that only actual\n   * WebAssembly functions, i.e. as exported by the module, are supported.\n   */\n  function newFunction(fn) {\n    if (typeof fn.original === \"function\") fn = fn.original;\n    var index = table.length;\n    table.grow(1);\n    table.set(index, fn);\n    return index;\n  }\n\n  baseModule.newFunction = newFunction;\n\n  /** Gets a function by its pointer. */\n  function getFunction(ptr) {\n    return wrapFunction(table.get(ptr), setargc);\n  }\n\n  baseModule.getFunction = getFunction;\n\n  // Pull basic exports to baseModule so code in preInstantiate can use them\n  baseModule.memory = baseModule.memory || memory;\n  baseModule.table = baseModule.table || table;\n\n  // Demangle exports and provide the usual utility on the prototype\n  return demangle(rawExports, Object.defineProperties(baseModule, {\n    I8: { get: function() { checkMem(); return I8; } },\n    U8: { get: function() { checkMem(); return U8; } },\n    I16: { get: function() { checkMem(); return I16; } },\n    U16: { get: function() { checkMem(); return U16; } },\n    I32: { get: function() { checkMem(); return I32; } },\n    U32: { get: function() { checkMem(); return U32; } },\n    I64: { get: function() { checkMem(); return I64; } },\n    U64: { get: function() { checkMem(); return U64; } },\n    F32: { get: function() { checkMem(); return F32; } },\n    F64: { get: function() { checkMem(); return F64; } }\n  }));\n}\n\n/** Wraps a WebAssembly function while also taking care of variable arguments. */\nfunction wrapFunction(fn, setargc) {\n  var wrap = (...args) => {\n    setargc(args.length);\n    return fn(...args);\n  }\n  // adding a function to the table with `newFunction` is limited to actual WebAssembly functions,\n  // hence we can't use the wrapper and instead need to provide a reference to the original\n  wrap.original = fn;\n  return wrap;\n}\n\n/** Instantiates an AssemblyScript module using the specified imports. */\nfunction instantiate(module, imports) {\n  return postInstantiate(\n    preInstantiate(imports || (imports = {})),\n    new WebAssembly.Instance(module, imports)\n  );\n}\n\nexports.instantiate = instantiate;\n\n/** Instantiates an AssemblyScript module from a buffer using the specified imports. */\nfunction instantiateBuffer(buffer, imports) {\n  return instantiate(new WebAssembly.Module(buffer), imports);\n}\n\nexports.instantiateBuffer = instantiateBuffer;\n\n/** Instantiates an AssemblyScript module from a response using the specified imports. */\nasync function instantiateStreaming(response, imports) {\n  return postInstantiate(\n    preInstantiate(imports || (imports = {})),\n    (await WebAssembly.instantiateStreaming(response, imports)).instance\n  );\n}\n\nexports.instantiateStreaming = instantiateStreaming;\n\n/** Demangles an AssemblyScript module's exports to a friendly object structure. */\nfunction demangle(exports, baseModule) {\n  var module = baseModule ? Object.create(baseModule) : {};\n  var setargc = exports._setargc || function() {};\n  function hasOwnProperty(elem, prop) {\n    return Object.prototype.hasOwnProperty.call(elem, prop);\n  }\n  for (let internalName in exports) {\n    if (!hasOwnProperty(exports, internalName)) continue;\n    let elem = exports[internalName];\n    let parts = internalName.split(\".\");\n    let curr = module;\n    while (parts.length > 1) {\n      let part = parts.shift();\n      if (!hasOwnProperty(curr, part)) curr[part] = {};\n      curr = curr[part];\n    }\n    let name = parts[0];\n    let hash = name.indexOf(\"#\");\n    if (hash >= 0) {\n      let className = name.substring(0, hash);\n      let classElem = curr[className];\n      if (typeof classElem === \"undefined\" || !classElem.prototype) {\n        let ctor = function(...args) {\n          return ctor.wrap(ctor.prototype.constructor(0, ...args));\n        };\n        ctor.prototype = {};\n        ctor.wrap = function(thisValue) {\n          return Object.create(ctor.prototype, { [thisPtr]: { value: thisValue, writable: false } });\n        };\n        if (classElem) Object.getOwnPropertyNames(classElem).forEach(name =>\n          Object.defineProperty(ctor, name, Object.getOwnPropertyDescriptor(classElem, name))\n        );\n        curr[className] = ctor;\n      }\n      name = name.substring(hash + 1);\n      curr = curr[className].prototype;\n      if (/^(get|set):/.test(name)) {\n        if (!hasOwnProperty(curr, name = name.substring(4))) {\n          let getter = exports[internalName.replace(\"set:\", \"get:\")];\n          let setter = exports[internalName.replace(\"get:\", \"set:\")];\n          Object.defineProperty(curr, name, {\n            get: function() { return getter(this[thisPtr]); },\n            set: function(value) { setter(this[thisPtr], value); },\n            enumerable: true\n          });\n        }\n      } else {\n        if (name === 'constructor') {\n          curr[name] = wrapFunction(elem, setargc);\n        } else { // for methods\n          Object.defineProperty(curr, name, {\n            value: function (...args) {\n              setargc(args.length);\n              return elem(this[thisPtr], ...args);\n            }\n          });\n        }\n      }\n    } else {\n      if (/^(get|set):/.test(name)) {\n        if (!hasOwnProperty(curr, name = name.substring(4))) {\n          Object.defineProperty(curr, name, {\n            get: exports[internalName.replace(\"set:\", \"get:\")],\n            set: exports[internalName.replace(\"get:\", \"set:\")],\n            enumerable: true\n          });\n        }\n      } else if (typeof elem === \"function\") {\n        curr[name] = wrapFunction(elem, setargc);\n      } else {\n        curr[name] = elem;\n      }\n    }\n  }\n\n  return module;\n}\n\nexports.demangle = demangle;\n","/**\n * A value indicating how to repeat the pattern's image.\n */\nexport enum CanvasPatternRepetition {\n  /**\n   * A canvas pattern repetition indicating a repeating pattern in both the x and y directions.\n   */\n  repeat = 0,\n  /**\n   * A canvas pattern repetition indicating a repeating pattern only the x direction.\n   */\n  repeat_x = 1,\n  /**\n   * A canvas pattern repetition indicating a repeating pattern only the y direction.\n   */\n  repeat_y = 2,\n  /**\n   * A canvas pattern repetition indicationg no repeating pattern.\n   */\n  no_repeat = 3,\n}\n","export enum FillRule {\n  nonzero = 0,\n  evenodd = 1,\n}\n","export enum ImageSmoothingQuality {\n  low = 0,\n  medium = 1,\n  high = 2,\n}","/**\n * The GlobalCompositeOperation enum for the globalCompositeOperation property sets the type\n * of compositing operation to apply when drawing new shapes.\n */\nexport enum GlobalCompositeOperationValue {\n  /**\n   * This is the default setting and draws new shapes on top of the existing canvas content\n   */\n  \"source-over\" = 0,\n  /**\n   * The new shape is drawn only where both the new shape and the destination canvas overlap.\n   * Everything else is made transparent.\n   */\n  \"source-in\" = 1,\n  /**\n   * The new shape is drawn where it doesn't overlap the existing canvas content.\n   */\n  \"source-out\" = 2,\n  /**\n   * The new shape is only drawn where it overlaps the existing canvas content.\n   */\n  \"source-atop\" = 3,\n  /**\n   * New shapes are drawn behind the existing canvas content.\n   */\n  \"destination-over\" = 4,\n  /**\n   * The existing canvas content is kept where both the new shape and existing canvas content\n   * overlap. Everything else is made transparent.\n   */\n  \"destination-in\" = 5,\n  /**\n   * The existing content is kept where it doesn't overlap the new shape.\n   */\n  \"destination-out\" = 6,\n  /**\n   * The existing canvas is only kept where it overlaps the new shape. The new shape is drawn\n   * behind the canvas content.\n   */\n  \"destination-atop\" = 7,\n  /**\n   * Where both shapes overlap the color is determined by adding color values.\n   */\n  \"lighter\" = 8,\n  /**\n   * Only the new shape is shown.\n   */\n  \"copy\" = 9,\n  /**\n   * Shapes are made transparent where both overlap and drawn normal everywhere else.\n   */\n  \"xor\" = 10,\n  /**\n   * The pixels are of the top layer are multiplied with the corresponding pixel of the bottom\n   * layer. A darker picture is the result.\n   */\n  \"multiply\" = 11,\n  /**\n   * The pixels are inverted, multiplied, and inverted again. A lighter picture is the result\n   * (opposite of multiply)\n   */\n  \"screen\" = 12,\n  /**\n   * A combination of multiply and screen. Dark parts on the base layer become darker, and light\n   * parts become lighter.\n   */\n  \"overlay\" = 13,\n  /**\n   * Retains the darkest pixels of both layers.\n   */\n  \"darken\" = 14,\n  /**\n   * Retains the lightest pixels of both layers.\n   */\n  \"lighten\" = 15,\n  /**\n   * Divides the bottom layer by the inverted top layer.\n   */\n  \"color-dodge\" = 16,\n  /**\n   * Divides the inverted bottom layer by the top layer, and then inverts the result.\n   */\n  \"color-burn\" = 17,\n  /**\n   * A combination of multiply and screen like overlay, but with top and bottom layer swapped.\n   */\n  \"hard-light\" = 18,\n  /**\n   * A softer version of hard-light. Pure black or white does not result in pure black or white.\n   */\n  \"soft-light\" = 19,\n  /**\n   * Subtracts the bottom layer from the top layer or the other way round to always get a positive\n   * value.\n   */\n  \"difference\" = 20,\n  /**\n   * Like difference, but with lower contrast.\n   */\n  \"exclusion\" = 21,\n  /**\n   * Preserves the luma and chroma of the bottom layer, while adopting the hue of the top layer.\n   */\n  \"hue\" = 22,\n  /**\n   * Preserves the luma and hue of the bottom layer, while adopting the chroma of the top layer.\n   */\n  \"saturation\" = 23,\n  /**\n   * Preserves the luma of the bottom layer, while adopting the hue and chroma of the top layer.\n   */\n  \"color\" = 24,\n  /**\n   * Preserves the hue and chroma of the bottom layer, while adopting the luma of the top layer.\n   */\n  \"luminosity\" = 25,\n}\n","/**\n * The CanvasRenderingContext2D.direction value of the Canvas 2D API specifies the current text\n * direction used to draw text onto the canvas.\n */\nexport enum CanvasDirection {\n  /**\n   * The text direction is left-to-right.\n   */\n  ltr = 0,\n  /**\n   * The text direction is right-to-left.\n   */\n  rtl = 1,\n  /**\n   * The text direction is inherited from the <canvas> element or the Document as appropriate. Default value.\n   */\n  inherit = 2,\n}\n","/**\n * The TextAlign enum specifies the current text alignment used when drawing text.\n *\n * The alignment is relative to the x value of the fillText() method. For example, if textAlign is\n * \"center\", then the text's left edge will be at x - (textWidth / 2).\n */\nexport enum TextAlign {\n  /**\n   * The text is left-aligned.\n   **/\n  left = 0,\n  /**\n   * The text is right-aligned.\n   **/\n  right = 1,\n  /**\n   * The text is centered.\n   **/\n  center = 2,\n  /**\n   * The text is aligned at the normal start of the line (left-aligned for left-to-right locales, right-aligned for right-to-left locales).\n   **/\n  start = 3,\n  /**\n   * The text is aligned at the normal end of the line (right-aligned for left-to-right locales, left-aligned for right-to-left locales).\n   **/\n  end = 4,\n}\n","/**\n * The TextBasline enum specifies the current text baseline used when drawing text.\n */\nexport enum TextBaseline {\n  /**\n   * The text baseline is the top of the em square.\n   **/\n  top = 0,\n  /**\n   * The text baseline is the hanging baseline. (Used by Tibetan and other Indic scripts.)\n   **/\n  hanging = 1,\n  /**\n   * The text baseline is the middle of the em square.\n   **/\n  middle = 2,\n  /**\n   * The text baseline is the normal alphabetic baseline. Default value.\n   **/\n  alphabetic = 3,\n  /**\n   * The text baseline is the ideographic baseline; this is the bottom of the body of the characters, if the main body of characters protrudes beneath the alphabetic baseline. (Used by Chinese, Japanese, and Korean scripts.)\n   **/\n  ideographic = 4,\n  /**\n   * The text baseline is the bottom of the bounding box. This differs from the ideographic baseline in that the ideographic baseline doesn't consider descenders.\n   **/\n  bottom = 5,\n}","export enum LineCap {\n  butt = 0,\n  round = 1,\n  square = 2,\n}\n","/**\n * The LineJoin enum responsible for setting the lineJoin property of the Canvas 2D API determines\n * the shape used to join two line segments where they meet.\n *\n * This property has no effect wherever two connected segments have the same direction, because no\n * joining area will be added in this case. Degenerate segments with a length of zero (i.e., with\n * all endpoints and control points at the exact same position) are also ignored.\n */\nexport enum LineJoin {\n  /**\n   * Rounds off the corners of a shape by filling an additional sector of disc centered at the\n   * common endpoint of connected segments. The radius for these rounded corners is equal to the\n   * line width.\n   */\n  bevel = 0,\n  /**\n   * Fills an additional triangular area between the common endpoint of connected segments, and the\n   * separate outside rectangular corners of each segment.\n   */\n  round = 1,\n  /**\n   * Connected segments are joined by extending their outside edges to connect at a single point,\n   * with the effect of filling an additional lozenge-shaped area. This setting is affected by the\n   * miterLimit property. Default value.\n   */\n  miter = 2,\n}","import { ASUtil, instantiateBuffer, instantiate, instantiateStreaming } from \"assemblyscript/lib/loader\";\nimport { ICanvasSYS } from \"../util/ICanvasSYS\";\nimport { CanvasPatternRepetition } from \"../shared/CanvasPatternRepetition\";\nimport { CanvasInstruction } from \"../shared/CanvasInstruction\";\nimport { FillRule } from \"../shared/FillRule\";\nimport { ImageSmoothingQuality } from \"../shared/ImageSmoothingQuality\";\nimport { GlobalCompositeOperationValue } from \"../shared/GlobalCompositeOperationValue\";\nimport { CanvasDirection } from \"../shared/CanvasDirection\";\nimport { TextAlign } from \"../shared/TextAlign\";\nimport { TextBaseline } from \"../shared/TextBaseline\";\nimport { LineCap } from \"../shared/LineCap\";\nimport { LineJoin } from \"../shared/LineJoin\";\n\nconst bool = {\n  \"true\": 1,\n  \"false\": 0,\n};\n\nexport class AS2DGlue<T> {\n  public imports: any = null;\n  public wasm: (ASUtil & T & ICanvasSYS) | null = null;\n  private id: number = -1;\n\n  public instantiateBuffer(buffer: any, imports: any): ASUtil & T & ICanvasSYS {\n    this.imports = imports;\n    this.hookImports();\n    this.wasm = instantiateBuffer(buffer, this.imports) as any;\n    this.hookWasmApi();\n    return this.wasm!;\n  }\n\n  public async instantiateStreaming(response: Promise<Response>, imports: any): Promise<ASUtil & T & ICanvasSYS> {\n    this.imports = imports;\n    this.hookImports();\n    this.wasm = await instantiateStreaming(response, this.imports) as any;\n    this.hookWasmApi();\n    return this.wasm!;\n  }\n\n  public instantiate(module: any, imports: any): ASUtil & T & ICanvasSYS {\n    this.imports = imports;\n    this.hookImports();\n    this.wasm = instantiate(module, this.imports) as any;\n    this.hookWasmApi();\n    return this.wasm!;\n  }\n\n  private hookImports(): void {\n    this.imports.__canvas_sys = {\n      addColorStop: this.addColorStop.bind(this),\n      createLinearGradient: this.createLinearGradient.bind(this),\n      createPattern: this.createPattern.bind(this),\n      createRadialGradient: this.createRadialGradient.bind(this),\n      disposeCanvasGradient: this.disposeCanvasGradient.bind(this),\n      disposeCanvasPattern: this.disposeCanvasPattern.bind(this),\n      disposeImage: this.disposeImage.bind(this),\n      isPointInPath: this.isPointInPath.bind(this),\n      isPointInStroke: this.isPointInStroke.bind(this),\n      loadImage: this.loadImage.bind(this),\n      measureText: this.measureText.bind(this),\n      render: this.render.bind(this),\n    };\n  }\n\n  private hookWasmApi(): void {\n    this.wasm!.contexts = {};\n    this.wasm!.gradients = {};\n    this.wasm!.images = {};\n    this.wasm!.loading = {};\n    this.wasm!.patterns = {};\n    this.wasm!.useContext = this.useContext.bind(this);\n  }\n\n  private useContext(name: string, ctx: CanvasRenderingContext2D): number {\n    this.id += 1;\n    this.wasm!.contexts[this.id] = ctx;\n    this.wasm!.__use_context(this.wasm!.newString(name), this.id);\n    return this.id;\n  }\n\n  private createLinearGradient(objid: number, x0: number, y0: number, x1: number, y1: number): number {\n    this.id += 1;\n    if (!this.wasm!.contexts[objid]) throw new Error(\"Cannot find canvas: \" + objid);\n    this.wasm!.gradients[this.id] = this.wasm!.contexts[objid].createLinearGradient(x0, y0, x1, y1);\n    return this.id;\n  }\n\n  private createRadialGradient(objid: number, x0: number, y0: number, r0: number, x1: number, y1: number, r1: number): number {\n    this.id += 1;\n    if (!this.wasm!.contexts[objid]) throw new Error(\"Cannot find canvas: \" + objid);\n    this.wasm!.gradients[this.id] = this.wasm!.contexts[objid].createRadialGradient(x0, y0, r0, x1, y1, r1);\n    return this.id;\n  }\n\n  private addColorStop(objid: number, offset: number, color: number): void {\n    if (!this.wasm!.gradients[objid]) throw new Error(\"Cannot find gradient: \" + objid);\n    this.wasm!.gradients[objid].addColorStop(offset, this.wasm!.getString(color));\n  }\n\n  private loadImage(imgPointer: number, srcPointer: number): number {\n    var src: string = this.wasm!.getString(srcPointer);\n    this.id += 1;\n    var result: number = this.id;\n    this.wasm!.loading[result] = fetch(src)\n      .then(e => e.blob())\n      .then(createImageBitmap)\n      .then(e => {\n        this.wasm!.__image_loaded(imgPointer, e.width, e.height);\n        this.wasm!.images[result] = e;\n        return e;\n      });\n    return this.id;\n  }\n\n  private createPattern(cvsobjid: number, objid: number, repetition: CanvasPatternRepetition): number {\n    this.id += 1;\n    if (!this.wasm!.contexts[cvsobjid]) throw new Error(\"Cannot find canvas: \" + cvsobjid);\n    if (!this.wasm!.images[objid]) throw new Error(\"Cannot find image: \" + objid);\n    this.wasm!.patterns[this.id] = this.wasm!.contexts[cvsobjid].createPattern(\n      this.wasm!.images[objid],\n      CanvasPatternRepetition[repetition].replace(\"_\", \"-\"),\n    )!;\n    return this.id;\n  }\n\n  public measureText(cvsobjid: number, text: number): number {\n    // The canvas exists, because render was already called\n    // if (!this.wasm!.contexts[cvsobjid]) throw new Error(\"Cannot find canvas: \" + cvsobjid);\n    var ctx: CanvasRenderingContext2D = this.wasm!.contexts[cvsobjid];\n    return ctx.measureText(this.wasm!.getString(text)).width;\n  }\n\n  private render(cvsobjid: number, pointer: number): void {\n    if (!this.wasm!.contexts[cvsobjid]) throw new Error(\"Cannot find canvas: \" + cvsobjid);\n    var wasm: ASUtil & T & ICanvasSYS = this.wasm!;\n    var ctx: CanvasRenderingContext2D = wasm.contexts[cvsobjid];\n    var data = new Float64Array(wasm.memory.buffer, pointer, 0x10000);\n    var i = 0;\n    var strings: { [pointer: number]: string; } = {};\n    while (i < 0x10000 && data[i] !== CanvasInstruction.Commit) {\n      switch (data[i]) {\n        case CanvasInstruction.Arc: {\n          ctx.arc(data[i + 2], data[i + 3], data[i + 4], data[i + 5], data[i + 6], data[i + 7] === 1);\n          break;\n        }\n        case CanvasInstruction.ArcTo: {\n          ctx.arcTo(data[i + 2], data[i + 3], data[i + 4], data[i + 5], data[i + 6]);\n          break;\n        }\n        case CanvasInstruction.BeginPath: {\n          ctx.beginPath();\n          break;\n        }\n        case CanvasInstruction.BezierCurveTo: {\n          ctx.bezierCurveTo(data[i + 2], data[i + 3], data[i + 4], data[i + 5], data[i + 6], data[i + 7]);\n          break;\n        }\n        case CanvasInstruction.Clip: {\n          ctx.clip();\n          break;\n        }\n        case CanvasInstruction.ClosePath: {\n          ctx.closePath();\n          break;\n        }\n        case CanvasInstruction.ClearRect: {\n          ctx.clearRect(data[i + 2], data[i + 3], data[i + 4], data[i + 5]);\n          break;\n        }\n        case CanvasInstruction.Direction: {\n          ctx.direction = CanvasDirection[data[i + 2]] as \"rtl\" | \"ltr\" | \"inherit\";\n          break;\n        }\n        case CanvasInstruction.DrawImage: {\n          ctx.drawImage(wasm.images[data[i + 2]], data[i + 3], data[i + 4], data[i + 5], data[i + 6], data[i + 7], data[i + 8], data[i + 9], data[i + 10]);\n          break;\n        }\n        case CanvasInstruction.Ellipse: {\n          ctx.ellipse(data[i + 2], data[i + 3], data[i + 4], data[i + 5], data[i + 6], data[i + 7], data[i + 8], data[i + 9] === 1);\n          break;\n        }\n        case CanvasInstruction.Fill: {\n          ctx.fill(FillRule[data[i + 2]] as CanvasFillRule);\n          break;\n        }\n        case CanvasInstruction.FillGradient: {\n          ctx.fillStyle = wasm.gradients[data[i + 2]];\n          break;\n        }\n        case CanvasInstruction.FillPattern: {\n          ctx.fillStyle = wasm.patterns[data[i + 2]];\n          break;\n        }\n        case CanvasInstruction.FillRect: {\n          ctx.fillRect(data[i + 2], data[i + 3], data[i + 4], data[i + 5]);\n          break;\n        }\n        case CanvasInstruction.FillStyle: {\n          ctx.fillStyle = strings[data[i + 2]] || (strings[data[i + 2]] = wasm.getString(data[i + 2]));\n          break;\n        }\n        case CanvasInstruction.FillText: {\n          ctx.fillText(\n            strings[data[i + 2]] || (strings[data[i + 2]] = wasm.getString(data[i + 2])),\n            data[i + 3],\n            data[i + 4],\n          );\n          break;\n        }\n        case CanvasInstruction.FillTextWidth: {\n          ctx.fillText(\n            strings[data[i + 2]] || (strings[data[i + 2]] = wasm.getString(data[i + 2])),\n            data[i + 3],\n            data[i + 4],\n            data[i + 5],\n          );\n          break;\n        }\n        case CanvasInstruction.Filter: {\n          ctx.filter = strings[data[i + 2]] || (strings[data[i + 2]] = wasm.getString(data[i + 2]));\n          break;\n        }\n        case CanvasInstruction.Font: {\n          ctx.font = strings[data[i + 2]] || (strings[data[i + 2]] = wasm.getString(data[i + 2]));\n          break;\n        }\n        case CanvasInstruction.GlobalAlpha: {\n          ctx.globalAlpha = data[i + 2];\n          break;\n        }\n        case CanvasInstruction.GlobalCompositeOperation: {\n          ctx.globalCompositeOperation = GlobalCompositeOperationValue[data[i + 2]];\n          break;\n        }\n        case CanvasInstruction.ImageSmoothingEnabled: {\n          ctx.imageSmoothingEnabled = data[i + 1] === 1;\n          break;\n        }\n        case CanvasInstruction.ImageSmoothingQuality: {\n          ctx.imageSmoothingQuality = ImageSmoothingQuality[data[i + 2]] as \"low\" | \"medium\" | \"high\";\n          break;\n        }\n        case CanvasInstruction.LineCap: {\n          ctx.lineCap = LineCap[data[i + 2]] as CanvasLineCap;\n          break;\n        }\n        case CanvasInstruction.LineDash: {\n          // @ts-ignore: Float64Array is not a valid TypedArrayConstructor, and setLineDash accepts Float64Array\n          ctx.setLineDash(wasm.getArray(Float64Array, data[i + 2]));\n          break;\n        }\n        case CanvasInstruction.LineDashOffset: {\n          ctx.lineDashOffset = data[i + 2];\n          break;\n        }\n        case CanvasInstruction.LineJoin: {\n          ctx.lineJoin = LineJoin[data[i + 2]] as CanvasLineJoin;\n          break;\n        }\n        case CanvasInstruction.LineTo: {\n          ctx.lineTo(data[i + 2], data[i + 3]);\n          break;\n        }\n        case CanvasInstruction.LineWidth: {\n          ctx.lineWidth = data[i + 2];\n          break;\n        }\n        case CanvasInstruction.MiterLimit: {\n          ctx.miterLimit = data[i + 2];\n          break;\n        }\n        case CanvasInstruction.MoveTo: {\n          ctx.moveTo(data[i + 2], data[i + 3]);\n          break;\n        }\n        case CanvasInstruction.QuadraticCurveTo: {\n          ctx.quadraticCurveTo(data[i + 2], data[i + 3], data[i + 4], data[i + 5]);\n          break;\n        }\n        case CanvasInstruction.Rect: {\n          ctx.rect(data[i + 2], data[i + 3], data[i + 4], data[i + 5]);\n          break;\n        }\n        case CanvasInstruction.Restore: {\n          ctx.restore();\n          break;\n        }\n        case CanvasInstruction.Save: {\n          ctx.save();\n          break;\n        }\n        case CanvasInstruction.SetTransform: {\n          ctx.setTransform(data[i + 2], data[i + 3], data[i + 4], data[i + 5], data[i + 6], data[i + 7]);\n          break;\n        }\n        case CanvasInstruction.ShadowBlur: {\n          ctx.shadowBlur = data[i + 2];\n          break;\n        }\n        case CanvasInstruction.ShadowColor: {\n          ctx.shadowColor = strings[data[i + 2]] || (strings[data[i + 2]] = wasm.getString(data[i + 2]));\n          break;\n        }\n        case CanvasInstruction.ShadowOffsetX: {\n          ctx.shadowOffsetX = data[i + 2];\n          break;\n        }\n        case CanvasInstruction.ShadowOffsetY: {\n          ctx.shadowOffsetY = data[i + 2];\n          break;\n        }\n        case CanvasInstruction.Stroke: {\n          ctx.stroke();\n          break;\n        }\n        case CanvasInstruction.StrokeGradient: {\n          ctx.strokeStyle = wasm.gradients[data[i + 2]];\n          break;\n        }\n        case CanvasInstruction.StrokePattern: {\n          ctx.strokeStyle = wasm.patterns[data[i + 2]];\n          break;\n        }\n        case CanvasInstruction.StrokeRect: {\n          ctx.strokeRect(data[i + 2], data[i + 3], data[i + 4], data[i + 5]);\n          break;\n        }\n        case CanvasInstruction.StrokeStyle: {\n          ctx.strokeStyle = strings[data[i + 2]] || (strings[data[i + 2]] = wasm.getString(data[i + 2]));\n          break;\n        }\n        case CanvasInstruction.StrokeText: {\n          ctx.strokeText(\n            strings[data[i + 2]] || (strings[data[i + 2]] = wasm.getString(data[i + 2])),\n            data[i + 3],\n            data[i + 4],\n          );\n          break;\n        }\n        case CanvasInstruction.StrokeTextWidth: {\n          ctx.strokeText(\n            strings[data[i + 2]] || (strings[data[i + 2]] = wasm.getString(data[i + 2])),\n            data[i + 3],\n            data[i + 4],\n            data[i + 5],\n          );\n          break;\n        }\n        case CanvasInstruction.TextAlign: {\n          ctx.textAlign = TextAlign[data[i + 2]] as CanvasTextAlign;\n          break;\n        }\n        case CanvasInstruction.TextBaseline: {\n          ctx.textBaseline = TextBaseline[data[i + 2]] as CanvasTextBaseline;\n          break;\n        }\n      }\n      i = data[i + 1];\n    }\n  }\n\n  disposeCanvasPattern(id: number): void {\n    delete this.wasm!.patterns[id];\n  }\n\n  disposeImage(id: number): void {\n    delete this.wasm!.images[id];\n  }\n\n  disposeCanvasGradient(id: number): void {\n    delete this.wasm!.gradients[id];\n  }\n\n  isPointInPath(id: number, x: number, y: number, fillRule: FillRule): number {\n    return bool[(<any>this.wasm!.contexts[id]).isPointInPath(x, y, FillRule[fillRule]).toString() as \"true\" | \"false\"];\n  }\n\n  isPointInStroke(id: number, x: number, y: number): number {\n    return bool[(<any>this.wasm!.contexts[id]).isPointInStroke(x, y).toString() as \"true\" | \"false\"];\n  }\n}\n","/**\n * The GlobalCompositeOperation enum for the globalCompositeOperation property sets the type\n * of compositing operation to apply when drawing new shapes.\n */\nexport enum GlobalCompositeOperation {\n  /**\n   * This is the default setting and draws new shapes on top of the existing canvas content\n   */\n  source_over = 0,\n  /**\n   * The new shape is drawn only where both the new shape and the destination canvas overlap.\n   * Everything else is made transparent.\n   */\n  source_in = 1,\n  /**\n   * The new shape is drawn where it doesn't overlap the existing canvas content.\n   */\n  source_out = 2,\n  /**\n   * The new shape is only drawn where it overlaps the existing canvas content.\n   */\n  source_atop = 3,\n  /**\n   * New shapes are drawn behind the existing canvas content.\n   */\n  destination_over = 4,\n  /**\n   * The existing canvas content is kept where both the new shape and existing canvas content\n   * overlap. Everything else is made transparent.\n   */\n  destination_in = 5,\n  /**\n   * The existing content is kept where it doesn't overlap the new shape.\n   */\n  destination_out = 6,\n  /**\n   * The existing canvas is only kept where it overlaps the new shape. The new shape is drawn\n   * behind the canvas content.\n   */\n  destination_atop = 7,\n  /**\n   * Where both shapes overlap the color is determined by adding color values.\n   */\n  lighter = 8,\n  /**\n   * Only the new shape is shown.\n   */\n  copy = 9,\n  /**\n   * Shapes are made transparent where both overlap and drawn normal everywhere else.\n   */\n  xor = 10,\n  /**\n   * The pixels are of the top layer are multiplied with the corresponding pixel of the bottom\n   * layer. A darker picture is the result.\n   */\n  multiply = 11,\n  /**\n   * The pixels are inverted, multiplied, and inverted again. A lighter picture is the result\n   * (opposite of multiply)\n   */\n  screen = 12,\n  /**\n   * A combination of multiply and screen. Dark parts on the base layer become darker, and light\n   * parts become lighter.\n   */\n  overlay = 13,\n  /**\n   * Retains the darkest pixels of both layers.\n   */\n  darken = 14,\n  /**\n   * Retains the lightest pixels of both layers.\n   */\n  lighten = 15,\n  /**\n   * Divides the bottom layer by the inverted top layer.\n   */\n  color_dodge = 16,\n  /**\n   * Divides the inverted bottom layer by the top layer, and then inverts the result.\n   */\n  color_burn = 17,\n  /**\n   * A combination of multiply and screen like overlay, but with top and bottom layer swapped.\n   */\n  hard_light = 18,\n  /**\n   * A softer version of hard-light. Pure black or white does not result in pure black or white.\n   */\n  soft_light = 19,\n  /**\n   * Subtracts the bottom layer from the top layer or the other way round to always get a positive\n   * value.\n   */\n  difference = 20,\n  /**\n   * Like difference, but with lower contrast.\n   */\n  exclusion = 21,\n  /**\n   * Preserves the luma and chroma of the bottom layer, while adopting the hue of the top layer.\n   */\n  hue = 22,\n  /**\n   * Preserves the luma and hue of the bottom layer, while adopting the chroma of the top layer.\n   */\n  saturation = 23,\n  /**\n   * Preserves the luma of the bottom layer, while adopting the hue and chroma of the top layer.\n   */\n  color = 24,\n  /**\n   * Preserves the hue and chroma of the bottom layer, while adopting the luma of the top layer.\n   */\n  luminosity = 25,\n}\n","import * as vm from \"./vm\";\n\nconst storageKey = \"gomoku\";\n\nlet storageObject = {};\n\nvm.init(1, function (state, module) {\n    console.log(\"state update\", state);\n    let statePointer = module.getState();\n    let fullState = module.getArray(Int8Array, statePointer);\n    storageObject = {state: Array.from(fullState)};\n    let stateString = JSON.stringify(storageObject);\n    localStorage.setItem(storageKey, stateString);\n    console.log(\"update storage value\", stateString);\n}, function (player: number) {\n    if (confirm('Game over, winner is:' + player + ', restart again?')) {\n        console.log(\"remove storage.\");\n        localStorage.removeItem(storageKey);\n        location.reload();\n    } else {\n        // Do nothing!\n    }\n}, true).then(gameGUI => {\n    try {\n        let stateStr = localStorage.getItem(storageKey);\n        if (stateStr != null) {\n            console.log(\"storage value\", stateStr);\n            let stateObject = JSON.parse(stateStr);\n            console.log(\"stateObject\", stateObject);\n            let typedArray = Int8Array.from(stateObject.state);\n            console.log(\"typedArray length\", typedArray.length)\n            let pointer = gameGUI.newArray(typedArray);\n            gameGUI.loadState(pointer);\n        }\n    } catch (e) {\n        console.error(e);\n        localStorage.removeItem(storageKey);\n    }\n    gameGUI.startGame();\n});\n\n\n","\"use strict\";\n\nconst hasBigInt64 = typeof BigUint64Array !== \"undefined\";\nconst thisPtr = Symbol();\n\n/** Gets a string from an U32 and an U16 view on a memory. */\nfunction getStringImpl(U32, U16, ptr) {\n  var dataLength = U32[ptr >>> 2];\n  var dataOffset = (ptr + 4) >>> 1;\n  var dataRemain = dataLength;\n  var parts = [];\n  const chunkSize = 1024;\n  while (dataRemain > chunkSize) {\n    let last = U16[dataOffset + chunkSize - 1];\n    let size = last >= 0xD800 && last < 0xDC00 ? chunkSize - 1 : chunkSize;\n    let part = U16.subarray(dataOffset, dataOffset += size);\n    parts.push(String.fromCharCode.apply(String, part));\n    dataRemain -= size;\n  }\n  return parts.join(\"\") + String.fromCharCode.apply(String, U16.subarray(dataOffset, dataOffset + dataRemain));\n}\n\n/** Prepares the base module prior to instantiation. */\nfunction preInstantiate(imports) {\n  var baseModule = {};\n\n  function getString(memory, ptr) {\n    if (!memory) return \"<yet unknown>\";\n    var buffer = memory.buffer;\n    return getStringImpl(new Uint32Array(buffer), new Uint16Array(buffer), ptr);\n  }\n\n  // add common imports used by stdlib for convenience\n  var env = (imports.env = imports.env || {});\n  env.abort = env.abort || function abort(mesg, file, line, colm) {\n    var memory = baseModule.memory || env.memory; // prefer exported, otherwise try imported\n    throw Error(\"abort: \" + getString(memory, mesg) + \" at \" + getString(memory, file) + \":\" + line + \":\" + colm);\n  }\n  env.trace = env.trace || function trace(mesg, n) {\n    var memory = baseModule.memory || env.memory;\n    console.log(\"trace: \" + getString(memory, mesg) + (n ? \" \" : \"\") + Array.prototype.slice.call(arguments, 2, 2 + n).join(\", \"));\n  }\n  imports.Math = imports.Math || Math;\n  imports.Date = imports.Date || Date;\n\n  return baseModule;\n}\n\n/** Prepares the final module once instantiation is complete. */\nfunction postInstantiate(baseModule, instance) {\n  var rawExports = instance.exports;\n  var memory = rawExports.memory;\n  var memory_allocate = rawExports[\"memory.allocate\"];\n  var memory_fill = rawExports[\"memory.fill\"];\n  var memory_free = rawExports[\"memory.free\"];\n  var table = rawExports.table;\n  var setargc = rawExports._setargc || function() {};\n\n  // Provide views for all sorts of basic values\n  var buffer, I8, U8, I16, U16, I32, U32, F32, F64, I64, U64;\n\n  /** Updates memory views if memory has grown meanwhile. */\n  function checkMem() {\n    // see: https://github.com/WebAssembly/design/issues/1210\n    if (buffer !== memory.buffer) {\n      buffer = memory.buffer;\n      I8  = new Int8Array(buffer);\n      U8  = new Uint8Array(buffer);\n      I16 = new Int16Array(buffer);\n      U16 = new Uint16Array(buffer);\n      I32 = new Int32Array(buffer);\n      U32 = new Uint32Array(buffer);\n      if (hasBigInt64) {\n        I64 = new BigInt64Array(buffer);\n        U64 = new BigUint64Array(buffer);\n      }\n      F32 = new Float32Array(buffer);\n      F64 = new Float64Array(buffer);\n    }\n  }\n  checkMem();\n\n  /** Allocates a new string in the module's memory and returns its pointer. */\n  function newString(str) {\n    var dataLength = str.length;\n    var ptr = memory_allocate(4 + (dataLength << 1));\n    var dataOffset = (4 + ptr) >>> 1;\n    checkMem();\n    U32[ptr >>> 2] = dataLength;\n    for (let i = 0; i < dataLength; ++i) U16[dataOffset + i] = str.charCodeAt(i);\n    return ptr;\n  }\n\n  baseModule.newString = newString;\n\n  /** Gets a string from the module's memory by its pointer. */\n  function getString(ptr) {\n    checkMem();\n    return getStringImpl(U32, U16, ptr);\n  }\n\n  baseModule.getString = getString;\n\n  function computeBufferSize(byteLength) {\n    const HEADER_SIZE = 8;\n    return 1 << (32 - Math.clz32(byteLength + HEADER_SIZE - 1));\n  }\n\n  /** Creates a new typed array in the module's memory and returns its pointer. */\n  function newArray(view, length, unsafe) {\n    var ctor = view.constructor;\n    if (ctor === Function) { // TypedArray constructor created in memory\n      ctor = view;\n      view = null;\n    } else { // TypedArray instance copied into memory\n      if (length === undefined) length = view.length;\n    }\n    var elementSize = ctor.BYTES_PER_ELEMENT;\n    if (!elementSize) throw Error(\"not a typed array\");\n    var byteLength = elementSize * length;\n    var ptr = memory_allocate(12); // TypedArray header\n    var buf = memory_allocate(computeBufferSize(byteLength)); // ArrayBuffer\n    checkMem();\n    U32[ ptr      >>> 2] = buf;        // .buffer\n    U32[(ptr + 4) >>> 2] = 0;          // .byteOffset\n    U32[(ptr + 8) >>> 2] = byteLength; // .byteLength\n    U32[ buf      >>> 2] = byteLength; // .byteLength\n    U32[(buf + 4) >>> 2] = 0;          // 0\n    if (view) {\n      new ctor(buffer, buf + 8, length).set(view);\n      if (view.length < length && !unsafe) {\n        let setLength = elementSize * view.length;\n        memory_fill(buf + 8 + setLength, 0, byteLength - setLength);\n      }\n    } else if (!unsafe) {\n      memory_fill(buf + 8, 0, byteLength);\n    }\n    return ptr;\n  }\n\n  baseModule.newArray = newArray;\n\n  /** Gets a view on a typed array in the module's memory by its pointer. */\n  function getArray(ctor, ptr) {\n    var elementSize = ctor.BYTES_PER_ELEMENT;\n    if (!elementSize) throw Error(\"not a typed array\");\n    checkMem();\n    var buf        = U32[ ptr      >>> 2];\n    var byteOffset = U32[(ptr + 4) >>> 2];\n    var byteLength = U32[(ptr + 8) >>> 2];\n    return new ctor(buffer, buf + 8 + byteOffset, (byteLength - byteOffset) / elementSize);\n  }\n\n  baseModule.getArray = getArray;\n\n  /** Frees a typed array in the module's memory. Must not be accessed anymore afterwards. */\n  function freeArray(ptr) {\n    checkMem();\n    var buf = U32[ptr >>> 2];\n    memory_free(buf);\n    memory_free(ptr);\n  }\n\n  baseModule.freeArray = freeArray;\n\n  /**\n   * Creates a new function in the module's table and returns its pointer. Note that only actual\n   * WebAssembly functions, i.e. as exported by the module, are supported.\n   */\n  function newFunction(fn) {\n    if (typeof fn.original === \"function\") fn = fn.original;\n    var index = table.length;\n    table.grow(1);\n    table.set(index, fn);\n    return index;\n  }\n\n  baseModule.newFunction = newFunction;\n\n  /** Gets a function by its pointer. */\n  function getFunction(ptr) {\n    return wrapFunction(table.get(ptr), setargc);\n  }\n\n  baseModule.getFunction = getFunction;\n\n  // Pull basic exports to baseModule so code in preInstantiate can use them\n  baseModule.memory = baseModule.memory || memory;\n  baseModule.table = baseModule.table || table;\n\n  // Demangle exports and provide the usual utility on the prototype\n  return demangle(rawExports, Object.defineProperties(baseModule, {\n    I8: { get: function() { checkMem(); return I8; } },\n    U8: { get: function() { checkMem(); return U8; } },\n    I16: { get: function() { checkMem(); return I16; } },\n    U16: { get: function() { checkMem(); return U16; } },\n    I32: { get: function() { checkMem(); return I32; } },\n    U32: { get: function() { checkMem(); return U32; } },\n    I64: { get: function() { checkMem(); return I64; } },\n    U64: { get: function() { checkMem(); return U64; } },\n    F32: { get: function() { checkMem(); return F32; } },\n    F64: { get: function() { checkMem(); return F64; } }\n  }));\n}\n\n/** Wraps a WebAssembly function while also taking care of variable arguments. */\nfunction wrapFunction(fn, setargc) {\n  var wrap = (...args) => {\n    setargc(args.length);\n    return fn(...args);\n  }\n  // adding a function to the table with `newFunction` is limited to actual WebAssembly functions,\n  // hence we can't use the wrapper and instead need to provide a reference to the original\n  wrap.original = fn;\n  return wrap;\n}\n\n/** Instantiates an AssemblyScript module using the specified imports. */\nfunction instantiate(module, imports) {\n  return postInstantiate(\n    preInstantiate(imports || (imports = {})),\n    new WebAssembly.Instance(module, imports)\n  );\n}\n\nexports.instantiate = instantiate;\n\n/** Instantiates an AssemblyScript module from a buffer using the specified imports. */\nfunction instantiateBuffer(buffer, imports) {\n  return instantiate(new WebAssembly.Module(buffer), imports);\n}\n\nexports.instantiateBuffer = instantiateBuffer;\n\n/** Instantiates an AssemblyScript module from a response using the specified imports. */\nasync function instantiateStreaming(response, imports) {\n  return postInstantiate(\n    preInstantiate(imports || (imports = {})),\n    (await WebAssembly.instantiateStreaming(response, imports)).instance\n  );\n}\n\nexports.instantiateStreaming = instantiateStreaming;\n\n/** Demangles an AssemblyScript module's exports to a friendly object structure. */\nfunction demangle(exports, baseModule) {\n  var module = baseModule ? Object.create(baseModule) : {};\n  var setargc = exports._setargc || function() {};\n  function hasOwnProperty(elem, prop) {\n    return Object.prototype.hasOwnProperty.call(elem, prop);\n  }\n  for (let internalName in exports) {\n    if (!hasOwnProperty(exports, internalName)) continue;\n    let elem = exports[internalName];\n    let parts = internalName.split(\".\");\n    let curr = module;\n    while (parts.length > 1) {\n      let part = parts.shift();\n      if (!hasOwnProperty(curr, part)) curr[part] = {};\n      curr = curr[part];\n    }\n    let name = parts[0];\n    let hash = name.indexOf(\"#\");\n    if (hash >= 0) {\n      let className = name.substring(0, hash);\n      let classElem = curr[className];\n      if (typeof classElem === \"undefined\" || !classElem.prototype) {\n        let ctor = function(...args) {\n          return ctor.wrap(ctor.prototype.constructor(0, ...args));\n        };\n        ctor.prototype = {};\n        ctor.wrap = function(thisValue) {\n          return Object.create(ctor.prototype, { [thisPtr]: { value: thisValue, writable: false } });\n        };\n        if (classElem) Object.getOwnPropertyNames(classElem).forEach(name =>\n          Object.defineProperty(ctor, name, Object.getOwnPropertyDescriptor(classElem, name))\n        );\n        curr[className] = ctor;\n      }\n      name = name.substring(hash + 1);\n      curr = curr[className].prototype;\n      if (/^(get|set):/.test(name)) {\n        if (!hasOwnProperty(curr, name = name.substring(4))) {\n          let getter = exports[internalName.replace(\"set:\", \"get:\")];\n          let setter = exports[internalName.replace(\"get:\", \"set:\")];\n          Object.defineProperty(curr, name, {\n            get: function() { return getter(this[thisPtr]); },\n            set: function(value) { setter(this[thisPtr], value); },\n            enumerable: true\n          });\n        }\n      } else {\n        if (name === 'constructor') {\n          curr[name] = wrapFunction(elem, setargc);\n        } else { // for methods\n          Object.defineProperty(curr, name, {\n            value: function (...args) {\n              setargc(args.length);\n              return elem(this[thisPtr], ...args);\n            }\n          });\n        }\n      }\n    } else {\n      if (/^(get|set):/.test(name)) {\n        if (!hasOwnProperty(curr, name = name.substring(4))) {\n          Object.defineProperty(curr, name, {\n            get: exports[internalName.replace(\"set:\", \"get:\")],\n            set: exports[internalName.replace(\"get:\", \"set:\")],\n            enumerable: true\n          });\n        }\n      } else if (typeof elem === \"function\") {\n        curr[name] = wrapFunction(elem, setargc);\n      } else {\n        curr[name] = elem;\n      }\n    }\n  }\n\n  return module;\n}\n\nexports.demangle = demangle;\n","// this is a shallow wrapper for the assemblyscript loader\nimport {ICanvasSYS, instantiateStreaming} from \"as2d\";\nimport * as loader from \"assemblyscript/lib/loader\";\nimport {ASUtil, TypedArrayConstructor} from \"assemblyscript/lib/loader\";\nimport {GameGUI} from \"./GameGUI\";\nimport {GameEngine} from \"./GameEngine\";\n\n\nconst env = {\n    memoryBase: 0,\n    tableBase: 0,\n    memory: new WebAssembly.Memory({\n        initial: 0\n    }),\n    abort(msg: number, file: number, line: number, column: number) {\n        console.error(\"abort called at \" + file + \":\" + line + \":\" + column + \", msg:\" + msg);\n    }\n};\n\nclass ASModuleWrapper {\n    module: ASUtil | null = null;\n\n    init(module: ASUtil): void {\n        this.module = module;\n    }\n\n    protected getString = (value: number) => {\n        if (this.module == null) {\n            return value;\n        } else {\n            return this.module.getString(value);\n        }\n    };\n\n    protected getArray = (type: TypedArrayConstructor, value: number) => {\n        if (this.module == null) {\n            return value;\n        } else {\n            return this.module.getArray(type, value);\n        }\n    };\n}\n\n//function use array style for keep this ref.\n//see https://github.com/Microsoft/TypeScript/wiki/'this'-in-TypeScript\nclass Console extends ASModuleWrapper {\n\n    public log = (value: number) => {\n        console.log(this.getString(value));\n    };\n    public logf = (msg: number, value: number) => {\n        console.log(this.getString(msg), value)\n    };\n    public logi = (msg: number, value: number) => {\n        console.log(this.getString(msg), value)\n    };\n    public logAction = (msg: number, player: number, state: number) => {\n        console.log(this.getString(msg) + \" player:\", player, this.getArray(Int8Array, state))\n    };\n    public error = (value: number) => {\n        alert(this.getString(value));\n    };\n}\n\nclass Listener extends ASModuleWrapper {\n\n    public onUpdate = (player: number, state: number) => {\n        console.log(\"listener onUpdate\", player, this.getArray(Int8Array, state));\n    };\n}\n\n\nconst engineConsole = new Console();\nconst guiConsole = new Console();\nconst listener = new Listener();\nlet module: ICanvasSYS & ASUtil & GameGUI;\nlet promise: Promise<ICanvasSYS & ASUtil & GameGUI>;\n\nexport function init(playerRole: number, onStateUpdate: (state: Int8Array, module: ICanvasSYS & ASUtil & GameGUI) => void, onGameOver: (player: number) => void, playWithAI: boolean = false, engineURL = \"./engine_optimized.wasm\", guiURL = \"./gui_optimized.wasm\") {\n    promise = loader.instantiateStreaming<GameEngine>(fetch(engineURL), {\n        env: env,\n        console: engineConsole,\n        listener: {\n            onUpdate(player: number, state: number) {\n                listener.onUpdate(player, state);\n            },\n            onGameOver(player: number) {\n                setTimeout(() => {\n                    onGameOver(player);\n                }, 500);\n            }\n        }\n    }).then(engine => {\n        engineConsole.init(engine);\n        listener.init(engine);\n        engine.init();\n        return engine;\n    }).then(engine => {\n        return instantiateStreaming<GameGUI>(fetch(guiURL), {\n                env: env, console: guiConsole, engine: {\n\n                update(player: number, state: number) {\n                        let pointer = engine.newArray(module.getArray(Int8Array, state));\n                        return engine.update(player, pointer)\n                    },\n                loadState(fullState: number) {\n                    let stateArray = module.getArray(Int8Array, fullState);\n                    console.log(\"engine adapter loadState\", stateArray);\n                    let pointer = engine.newArray(stateArray);\n                        engine.loadState(pointer)\n                    },\n                    getState() {\n                        let pointer = module.newArray(engine.getArray(Int8Array, engine.getState()))\n                        return pointer\n                    },\n                    isGameOver() {\n                        return engine.isGameOver()\n                    }\n                }\n            }).then(gui => {\n                module = gui;\n                guiConsole.init(gui);\n            const canvas = <HTMLCanvasElement>document.querySelector(\"#as2d\");\n            const ctx = canvas!.getContext(\"2d\")!;\n\n                ctx.canvas.addEventListener(\"click\", (e) => {\n                    let rect: ClientRect = (e.target as HTMLCanvasElement).getBoundingClientRect();\n                    let statePointer = gui.onClick(e.clientX - rect.left, e.clientY - rect.top);\n                    let state: Int8Array = gui.getArray(Int8Array, statePointer);\n                    if (state.length > 0) {\n                        onStateUpdate(state, gui);\n                    }\n                });\n\n                gui.useContext(\"main\", ctx);\n                gui.init(playerRole, playWithAI);\n                gui.draw();\n            return gui\n            });\n\n        }\n    );\n    return promise;\n}\n\nexport async function rivalUpdate(state: Int8Array) {\n    let module = await promise;\n    let pointer = module.newArray(state);\n    module.rivalUpdate(pointer);\n}\n\n","import * as vm from \"./vm\";\n\nconst storageKey = \"gomoku\";\n\nlet storageObject = {};\n\nvm.init(1, function (state, module) {\n    console.log(\"state update\", state);\n    let statePointer = module.getState();\n    let fullState = module.getArray(Int8Array, statePointer);\n    storageObject = {state: Array.from(fullState)};\n    let stateString = JSON.stringify(storageObject);\n    localStorage.setItem(storageKey, stateString);\n    console.log(\"update storage value\", stateString);\n}, function (player: number) {\n    if (confirm('Game over, winner is:' + player + ', restart again?')) {\n        console.log(\"remove storage.\");\n        localStorage.removeItem(storageKey);\n        location.reload();\n    } else {\n        // Do nothing!\n    }\n}, true).then(gameGUI => {\n    try {\n        let stateStr = localStorage.getItem(storageKey);\n        if (stateStr != null) {\n            console.log(\"storage value\", stateStr);\n            let stateObject = JSON.parse(stateStr);\n            console.log(\"stateObject\", stateObject);\n            let typedArray = Int8Array.from(stateObject.state);\n            console.log(\"typedArray length\", typedArray.length)\n            let pointer = gameGUI.newArray(typedArray);\n            gameGUI.loadState(pointer);\n        }\n    } catch (e) {\n        console.error(e);\n        localStorage.removeItem(storageKey);\n    }\n    gameGUI.startGame();\n});\n\n\n"]}